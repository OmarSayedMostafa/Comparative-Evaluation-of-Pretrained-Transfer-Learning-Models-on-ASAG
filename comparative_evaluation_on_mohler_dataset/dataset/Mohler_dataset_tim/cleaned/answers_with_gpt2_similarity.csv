,id,answer,score_me,score_other,score_avg,gpt2_similarity_score
0,1.1,High risk problems are address in the prototype program to make sure that the program is feasible.  A prototype may also be used to show a company that the software can be possibly programmed.  ,4.0,3.0,3.5,0.999945774786739
1,1.1,To simulate portions of the desired final product with a quick and easy program that does a small specific job. It is a way to help see what the problem is and how you may solve it in the final project.,5.0,5.0,5.0,0.9999495994089032
2,1.1,A prototype program simulates the behaviors of portions of the desired software product to allow for error checking.,5.0,3.0,4.0,0.9999825026524445
3,1.1,"Defined in the Specification phase a prototype stimulates the behavior of portions of the desired software product.  Meaning, the role of a prototype is a temporary solution until the program itself is refined to be used extensively in problem solving.",5.0,5.0,5.0,0.9999879105037365
4,1.1,It is used to let the users have a first idea of the completed program and allow the clients to evaluate the program. This can generate much feedback including software specifications and project estimations of the total project.,3.0,3.0,3.0,0.999979263925501
5,1.1,To find problem and errors in a program before it is finalized,2.0,2.0,2.0,0.999930053016415
6,1.1,"To address major issues in the creation of the program. There is no way to account for all possible bugs in the program, but it is possible to prove the program is tangible. ",3.0,2.0,2.5,0.9999632529577019
7,1.1,you can break the whole program into prototype programs to simulate parts of the final program,5.0,5.0,5.0,0.9999738373961337
8,1.1,-To provide an example or model of how the finished program should perfom.  -Provides forsight of some of the challanges that would be encountered.  -Provides opportunity To introduce changes To the finished program.,5.0,2.0,3.5,0.9999851667893427
9,1.1,Simulating the behavior of only a portion of the desired software product.,5.0,5.0,5.0,0.9999515008988179
10,1.1,A program that stimulates the behavior of portions of the desired software product.,5.0,5.0,5.0,0.9999854255471164
11,1.1,A program that simulates the behavior of portions of the desired software product.,5.0,5.0,5.0,0.9999854255471164
12,1.1,To lay out the basics and give you a starting point in the actual problem solving.,2.0,2.0,2.0,0.9999645606264594
13,1.1,To simulate problem solving for parts of the problem,4.0,5.0,4.5,0.99997831452427
14,1.1,A prototype program provides a basic groundwork from which to further enhance and improve a solution to a problem.,2.0,2.0,2.0,0.9999775935064082
15,1.1,"A prototype program is a part of the Specification phase of Software Problem Solvin.  It's employed to illustrate how the key problem or problems will be solved in a program, and sometimes serves as a base program to expand upon.",4.0,5.0,4.5,0.9999673286433844
16,1.1,Program that simulates the behavior of portions of the desired software product,5.0,5.0,5.0,0.9999861689161772
17,1.1,it provides a limited proof of concept to verify with the client before actually programming the whole application. ,2.0,2.0,2.0,0.999976160440282
18,1.1,It tests the main function of the program while leaving out the finer details. ,2.0,2.0,2.0,0.9999563807692349
19,1.1,To get early feedback from users in early stages of development.  To show users a first idea of what the program will do/look like.  To make sure the program will meet requirements before intense programming begins.,3.0,2.0,2.5,0.9999819992721517
20,1.1,it simulates the behavior of portions of the desired software product,5.0,5.0,5.0,0.999986721261576
21,1.1,It simulates the behavior of portions of the desired software product.,5.0,5.0,5.0,0.9999878725023825
22,1.1,A prototype program is used in problem solving to collect data for the problem.,1.0,2.0,1.5,0.9999394499399687
23,1.1,To ease the understanding of problem under discussion and to ease the understanding of the program itself,2.0,3.0,2.5,0.9999892147887111
24,1.1,it simulates the behavior of portions of the desired software product,5.0,5.0,5.0,0.999986721261576
25,1.1,The role of a prototype program is to help spot key problems that may arise during the actual programing. ,2.0,2.0,2.0,0.9999654023689155
26,1.1,"the prototype program gives a general idea of what the end product will do,   without the time and effort to write out the entire program.",4.0,2.0,3.0,0.9999676680861009
27,1.1,to show that a certain part of the program works as it is supposed to,4.0,2.0,3.0,0.9999198580523507
28,1.1,"Prototype programming is an approach to programming that enables one to take an organized approach to developing an effective program with minimal errors and a strategic pattern when solving a problem. i.e. book gave an example of a costumer withdrawing money from a bank, the approach that was taking on a pseudo code level during the OOA/Design lvl before proceeding into creating a solution. ",3.0,2.0,2.5,0.9999833289662658
29,1.2,Refining and possibly the design if the testing phase reveals problems in the design. Production can be affected if the program is unworkable in its current form which will lead to a later production time than originally estimated. Also affects coding because after testing you may need to rewrite the code for the program to remove errors.,5.0,2.0,3.5,0.9999331067437205
30,1.2,The implementation phase and the maintenance phase are effected,3.0,5.0,4.0,0.9999430620324462
31,1.2,"Verification, coding, refining the solution and maintenance are all influenced by the testing stage.",4.0,5.0,4.5,0.9999048511777286
32,1.2,"In RUP the stages in the software life cycle are influenced by the testing stage is:  Elaboration phase- refined progject vision, iterative devilopment of core system, development of system requirements, more accurate time and cost estimates.  Construction phase- iterative development of remaining system.  Transition phase-testing and deployment of the system.",2.0,4.0,3.0,0.9999376778780211
33,1.2,"Refining the solution, Production and Maintenance are all influenced by the Testing stage. ",3.0,3.0,3.0,0.9998874903132637
34,1.2,"Elaboration, Construction, and Transition are all affected by testing",2.0,2.0,2.0,0.9998593394983495
35,1.2,"Refining, Production, Maintenance",3.0,4.0,3.5,0.9998584751948338
36,1.2,Refining the solution,3.0,5.0,4.0,0.9998918301654276
37,1.2,-Verification  -Debugging,3.0,1.0,2.0,0.9996622822088728
38,1.2,Refining and Coding,5.0,5.0,5.0,0.9999031204280616
39,1.2,"The second half of the Elaboration phase, Construction phase, and the Transition phase. ",2.0,3.0,2.5,0.9999231677621856
40,1.2,"The refining step, the production step, and the maintenance stage.  ",3.0,4.0,3.5,0.9999348387348119
41,1.2,"Elaboration, Construction, Transition",2.0,2.0,2.0,0.9998787089922658
42,1.2,Refining.,3.0,3.0,3.0,0.9998491088796714
43,1.2,"The testing stage has a direct influence on the final version of a program, being as it is the debugging and finalization of a software revision.",2.0,1.0,1.5,0.9999101473662839
44,1.2,"Directly: Refining, coding.  Because Refining is right before the Testing Phase and Coding is right after the Testing Phase.  Indirectly: Production, Maintenance.  Because Refining occurs before these last two stages in the Software Life Cycle.",5.0,5.0,5.0,0.9999096027945068
45,1.2,"Testing, refining, production, and maintenance.",3.0,4.0,3.5,0.9998457831449972
46,1.2,"Depending on how the work is done, Testing is spread throughout the  process as to prevent errors from showing up later on due to lack of foresight. ",2.0,1.0,1.5,0.999924946122479
47,1.2,"Elaboration, construction, and transition.",2.0,3.0,2.5,0.9998716813566282
48,1.2,"All stages are influenced except setting the program requirements.  If a test fails, it can change the whole design, implementation, etc of a program as well as the final outcome.",2.0,1.0,1.5,0.9999177503712364
49,1.2,"Refining, production, and maintenance",3.0,3.0,3.0,0.9999088339398713
50,1.2,coding and refining,5.0,5.0,5.0,0.9999031204280616
51,1.2,"refining, production, maintenance.",3.0,4.0,3.5,0.9999096078823725
52,1.2,"Removing logical errors, testing for valid data, random data and actual data.",2.0,0.0,1.0,0.9999016455411721
53,1.2,1- specification 2- design 3- risk analysis 4- verification 5- coding 6- testing 7- refining 8- production 9- maintenance,1.0,4.0,2.5,0.9998453469546027
54,1.2,"Refining stage, Production stage, and Maintenance stage.  ",3.0,4.0,3.5,0.9999236264007243
55,1.2,Testing could affect all parts of the life cycle; it could make you go back   to specification if it does not test well.,2.0,2.0,2.0,0.9999005649110959
56,1.2,coding,3.0,3.0,3.0,0.9996842919929435
57,1.2,"The Individual components and steps such as  analysis, design, and implementing code  as well as the entire system are tested for execution of the requirements identified during the analysis stage. i.e. Main output ",1.0,2.0,1.5,0.9999246285286041
58,1.3,"Modularability, the ability to reuse parts of the program later in another program sometimes with completely different goals for the program. Also it makes it easier to debug code by dividing up the code into classes that each do a specific job and when the program fails at one job you only have one class to debug. Good for security purposes because it allows you to let someone use a program which sorts lists without having to give them access to the source code. ALso allows you to use inheritance and polymorphism.",4.0,5.0,4.5,0.9999131638295309
59,1.3,"This type of programming is more flexible, making it easier to add and modify the program.  It is also a type of a fail safe program, you check each individual module.  This eliminates redundant code and makes the program easier to read for other programmers.  When debugging the program it is easier to track down the source of a problem within a module rather than a 2 million line program.",5.0,5.0,5.0,0.9999235106562211
60,1.3,The main advantages to object-oriented programming are that existing classes can be reused and program maintenance and verification are easier. ,3.0,4.0,3.5,0.9999645619889596
61,1.3,The advantages is that OOP allows us to build classes of objects.  Three principles that make up OOP are:  Encapsulation- Objects combine data and operations.  Inheritance- Classes can inherit properties from other classes.  Polymorphism- Objects can determine appropriate operations at execution time.,2.0,3.0,2.5,0.9999659006189507
62,1.3,Some advantages are existing classes can be reused and program maintenance and verification are easier to accomplish.,3.0,4.0,3.5,0.9999615140953263
63,1.3,Object oriented programming allows programmers to use an object with classes that can be changed and manipulated while not affecting the entire object at once. The classes all hold attrubutes that affect the object.,1.0,1.0,1.0,0.9999311455744644
64,1.3,"Reusable components, Extensibility, Maintainability, it reduces large problems into smaller more manageable problems.",4.0,4.0,4.0,0.9999813647930398
65,1.3,Encapsulation-objects combine data and operations Inheritance- classes can inherit properties from other classes Polymorphism- Objects can determine appropriate operations at execution time,2.0,3.0,2.5,0.9999535309631599
66,1.3,-Easier to debugg   -Reusability,3.0,3.0,3.0,0.9999360192500208
67,1.3,Re-usability  and ease of maintenance,3.0,5.0,4.0,0.9999858425550627
68,1.3,"One of the main advantages is you can hide inner details a technique known by encapsulation. Objects combine the data and operations but you cannot see how it works.   Another advantage is you can reuse classes that have been defined earlier in the program, a method known as inheritance.   Finally another advantage is objects can determine appropriate operations at execution time a technique known as polymorphism. ",5.0,5.0,5.0,0.9999537840610615
69,1.3,"Existing classes can be reused, and program maintenance and verification are easier.",3.0,4.0,3.5,0.9999747922400463
70,1.3,Using different modules allows for easier debugging,2.0,2.0,2.0,0.9999394734848599
71,1.3,"Data encapsulation concept,the use of functions or methods to manipulate data.",3.0,4.0,3.5,0.9999535868282479
72,1.3,"Modular, reusable code, allowing faster deployment of solutions, and a more general view of a solution.",5.0,4.0,4.5,0.9999823667812673
73,1.3,"Coding and Debugging programs are usually easier, as either the compiler will specify the object that is working incorrectly, or the function an object was assigned to will be easier to identify.  The code itself also looks more organized and is easier to read and will help to avoid redundant coding.  Post-programming maintenance is also easier.  Also, modules can be reused several times in other programs without too much hassle.   Abstraction is the art of breaking down one big problem into smaller, simpler problems and solving them.  Many of the smaller problems are shared between unique complex problems, and creating modules to these solve these smaller repeated problems can save time when you encounter them again.",5.0,5.0,5.0,0.9999564598208951
74,1.3,"Variables can remain private. The code is easily modified and reusable, as well as easily implemented. Not to mention easier to read and follow along as an observer.",4.0,5.0,4.5,0.9999751564010394
75,1.3,Data Abstraction and control... it is possible to isolate elements from other elements a lot easier and prevent tampering of data. ,3.0,4.0,3.5,0.9999734851594706
76,1.3,Encapsulation - Objects use operations without knowing how the operation works. Inheritance - cuts redundancy by reusing earlier classes. Polymorphism - objects select the correct operation to use in the situation.,5.0,3.0,4.0,0.999968428963128
77,1.3,"They make it easier to reuse and adapt previously written code and they separate complex programs into smaller, easier to understand classes.",5.0,4.0,4.5,0.9999624731047294
78,1.3,"Existing classes can be reused, Program maintenance and verification are easier ",3.0,4.0,3.5,0.999975713910533
79,1.3,"Existing classes can be feused, Program maintenance and verification are easier",3.0,4.0,3.5,0.999975713910533
80,1.3,"the main advantages to object-oriented programming  is data abstraction, easier maintenance, and re-usability.",5.0,5.0,5.0,0.9999839819189498
81,1.3,Existing classes can be reused Program maintenance and verifications are easy,3.0,5.0,4.0,0.9999641955446444
82,1.3,1- Existing classes can be reused 2- Program maintenance and verification are easier  ,3.0,4.0,3.5,0.9999653998680212
83,1.3,Information can be hidden. It is easier to debug. Programming is easier and more manageable. ,3.0,4.0,3.5,0.9999605365070605
84,1.3,"Existing classes can be reused, program maintenance and verification are   easier.",3.0,4.0,3.5,0.9999771773406659
85,1.3,existing classes can be reused program maintenance and verification are easier,3.0,4.0,3.5,0.9999558737416104
86,1.3,"Well for one encapsulation the values of the variables inside an object are private, unless methods are written to pass info outside of the object. As well as Inheritance where each subclass inherits all variables and methods of its super class.  Example in the book included obj clock and how obj alarm would still use clock from the first class. ",3.0,4.0,3.5,0.9999422484065154
87,1.4,At function â€˜int main ()â€™,5.0,5.0,5.0,0.9998501209835081
88,1.4,the Function main().,5.0,5.0,5.0,0.9999059161815159
89,1.4,c++ programs begin to execute in the main method.,5.0,5.0,5.0,0.999877901535515
90,1.4,A C++ program will begin to execute at the main() function. ,5.0,5.0,5.0,0.9998908957994613
91,1.4,They begin in the main() function.,5.0,5.0,5.0,0.9999124619308609
92,1.4,Int main(),5.0,5.0,5.0,0.9998525420123348
93,1.4,main method,5.0,5.0,5.0,0.9999173695438195
94,1.4,in the testing phase,0.0,0.0,0.0,0.9999194268836773
95,1.4,-At the MAIN function,5.0,5.0,5.0,0.9998190743310216
96,1.4,main,5.0,5.0,5.0,0.9998078415186732
97,1.4, They begin to execute at the funcion main().,5.0,5.0,5.0,0.9998842601221727
98,1.4,The main method.,5.0,5.0,5.0,0.9999572510703542
99,1.4,At the root,0.0,5.0,2.5,0.9999545716044335
100,1.4,In the main() function.,5.0,5.0,5.0,0.9999581272294694
101,1.4,C++ programs begin execution at main.,5.0,5.0,5.0,0.9997644275614267
102,1.4,In the Main function..?,5.0,5.0,5.0,0.999886403628427
103,1.4,"At the ""main()"" function",5.0,5.0,5.0,0.9999197578858329
104,1.4,The main function.,5.0,5.0,5.0,0.9999594721658649
105,1.4,The function main,5.0,5.0,5.0,0.9999020016585951
106,1.4,"After loading the required include statements and libraries, the main method begins the execution.",5.0,5.0,5.0,0.9998996386653402
107,1.4,main function,5.0,5.0,5.0,0.9998980872529175
108,1.4,main,5.0,5.0,5.0,0.9998078415186732
109,1.4,C++ programs begin execution at the main function.,5.0,5.0,5.0,0.9997934255929422
110,1.4,At main,5.0,5.0,5.0,0.9999151454592711
111,1.4,they beging to excute at main,5.0,5.0,5.0,0.9998676598353934
112,1.4,at the main function  int main() {},5.0,5.0,5.0,0.9999401606669192
113,1.4,C++ programs begin execution at the main function.,5.0,5.0,5.0,0.9997934255929422
114,1.4,"in the ""main"" function",5.0,5.0,5.0,0.9998972075146512
115,1.4,Within the main function,5.0,5.0,5.0,0.9999563312200458
116,1.5,Variable can be a integer or a string in a program.,1.0,3.0,2.0,0.9999499179209703
117,1.5,"In programming, a structure that holds data and is uniquely named by the programmer. It holds the data assigned to it until a new value is assigned or the program is finished. ",4.0,5.0,4.5,0.9999369943758933
118,1.5,A variable is a location in memory where a value can be stored.,5.0,5.0,5.0,0.999983066390066
119,1.5," Variable is a location in the computer's memory, in which a value can be stored and later can retrieve that value.",5.0,5.0,5.0,0.9999808216565966
120,1.5,"A variable is a location in the computer's memory where a value can be stored for use by a program. Each variable has a name, a value, a type and a size.",5.0,5.0,5.0,0.9999690299208094
121,1.5,A named object that can hold a numerical or letter value,2.0,5.0,3.5,0.9999658732611477
122,1.5,"It's a sybol or name for a value/number. Example: 'a_used_number' can stand for any given number, and the programmer can refer to that number by using the variable name.",3.0,5.0,4.0,0.999941808581124
123,1.5,A variable is a location in the computers memory where a value can be stored for use by a program,5.0,5.0,5.0,0.9999722489463265
124,1.5, -An identifier that holds a location in memory.,3.0,5.0,4.0,0.9999361015195817
125,1.5,a block of memory that holds a specific type of data,5.0,5.0,5.0,0.9999725057832495
126,1.5,  It is a location in the computer's memory where it can be stored for use by a program.,5.0,5.0,5.0,0.9999655878294943
127,1.5,A location in memory where value can be stored.,5.0,5.0,5.0,0.9999794903645446
128,1.5,a value/word that can assume any of a set of values,3.0,3.0,3.0,0.9999330854363376
129,1.5,A pointer to a location in memory.,3.0,5.0,4.0,0.9999503653145609
130,1.5,"A variable is the memory address for a specific type of stored data, or from a mathematical perspective, a symbol representing a fixed definition with changing values.",5.0,5.0,5.0,0.9999653114390293
131,1.5,A variable is a value that is subject to change in a computer's memory that can be used by programs.  Programs can change the value of the variable and recall it later or act on it directly.,5.0,5.0,5.0,0.999946051868443
132,1.5,a symbol that stands in for a value that may or may not change depending on the program. ,3.0,5.0,4.0,0.999943565113542
133,1.5,"a placeholder to hold information used in the program... for example: int can hold: 1, 2, 3, 4, 68, 72, 256, etc. float can hold: 1.54, 55.55, 1.24, 5.657, 8.8123, et. char can hold: A, B, C, D, E, F, !, 4, 5, 6, P, etc. ",4.0,5.0,4.5,0.999943053315189
134,1.5,a stored value used by the program,4.0,5.0,4.5,0.9999455500905695
135,1.5,"A way to store different values into the program, such as numbers, words, letters, etc.",4.0,5.0,4.5,0.9999524008954195
136,1.5,An object with a location in memory where value can be stored ,2.0,5.0,3.5,0.9999734450916289
137,1.5,location in memory where a value can be stored,5.0,5.0,5.0,0.9999756066855935
138,1.5,a variable is an object where data is stored.,2.0,5.0,3.5,0.9999702831381827
139,1.5,Location in memory where a value can be stored.,5.0,5.0,5.0,0.9999835870217333
140,1.5,it is a location in memory where value can be stored ,5.0,5.0,5.0,0.9999752233503832
141,1.5,A variable is the location in a computer's memory where a value can be stored for use by a program.,5.0,5.0,5.0,0.9999805570056224
142,1.5,A variable is a location in a computers memory where a value can be stored   for use by a program.,5.0,5.0,5.0,0.9999756334423242
143,1.5,a location in memory where data can be stored and retrieved,5.0,5.0,5.0,0.999963636647732
144,1.5,"Is a method or identifier I would say,  we use to bind a data object to memory location; which is then stored in a location that can be accessed when and manipulated later when the variable name is called. ",5.0,5.0,5.0,0.9999673448701644
145,1.6,"They can be declared right before they are used, but it is a good practice to declare them at the beginning of the program and label what they are food.",1.0,3.0,2.0,0.9999541148246319
146,1.6,In the Function main() before using the variable.,1.0,5.0,3.0,0.9998430987245774
147,1.6,"Local variables are declared inside the method or function they will be used in at the beginning of the method. Global variables are declared outside of any function or method, generally before functions are defined.",5.0,5.0,5.0,0.9999800778791665
148,1.6,Variables are declared where ever it is defined either inside a block locally or outside a block globally.,4.0,5.0,4.5,0.9999763562390275
149,1.6,Variables are declared before they are actually used. They can be declared before main() to use globally,3.0,5.0,4.0,0.9999720599937078
150,1.6,"For good programing practice they should be declared before main(), but should at least be declared before they are used.",2.0,3.0,2.5,0.9999732609587756
151,1.6,"They can be declared globally just before the main method (but also outside of it)... or variables can be subject to only the method they're scoped within, but would still be declared at the beginning of that method (but inside of it).",5.0,5.0,5.0,0.9999720655002142
152,1.6,local variables are declared inside the method while global variables are declared in the body.,5.0,5.0,5.0,0.9999780408443246
153,1.6, -Any where in the main function.,1.0,3.0,2.0,0.9999030454861101
154,1.6,"Globally for an entire program, and locally for individual functions (including FOR statements)",4.0,5.0,4.5,0.9999795249379243
155,1.6, They are usually declared at the beginning before they can be used in the program. They always contain a name and a data type. ,2.0,4.0,3.0,0.9999614133286697
156,1.6,Inside the method.,2.0,3.0,2.5,0.9998486521885921
157,1.6,at the top,1.0,2.0,1.5,0.9998117927110386
158,1.6,Global variables are declared in the body of the code. Local variables are declared in the function they are to be used (unless the function is being passed a variable). Variables should always be declared before use.,5.0,5.0,5.0,0.9999845074779543
159,1.6,Variables are usually declared at the beginning of a module of C++ code.,2.0,3.0,2.5,0.9999870421888791
160,1.6,"In the main function, usually at the top of code.  They can be declared almost anywhere, but must be declared before the code can use or act upon them.",3.0,4.0,3.5,0.9999601797430643
161,1.6,in the very beginning of the program. Before the main() starts. ,1.0,3.0,2.0,0.9999774521214045
162,1.6,"In the declaration of Functions, for statements, and while statements. in the body of If, For, while, do while, statements, in namespaces, headers, etc  ( almost anywhere. ) anywhere in the program, as long as it is on it's own line.",2.0,3.0,2.5,0.9999683645983611
163,1.6,After declaration of the variable's data type.,1.0,1.0,1.0,0.9999274175569612
164,1.6,"anywhere in the code, can be at the top, or in the middle of the code, or anywhere.",3.0,3.0,3.0,0.9999362594186464
165,1.6,Before they are used.,2.0,2.0,2.0,0.9999095750506947
166,1.6,Anywhere in the same scope before they are used,3.0,4.0,3.5,0.9999233401638141
167,1.6,variables can be declared in classes and methods.,1.0,4.0,2.5,0.9999880408368106
168,1.6,inside the function scope and outside of the function scope in case of global variables,5.0,5.0,5.0,0.9998095955351554
169,1.6,global variables are declared in the main function local variables are declared in any other function,3.0,5.0,4.0,0.9999823518051637
170,1.6,"Variables are usually declared at the very beginning of a C++ program, but can be declared any in the program as long as they appear before they are called upon.",4.0,4.0,4.0,0.9999649483543048
171,1.6,"Variables are declared in the main function, before any operation is   attempted with the variables.",1.0,3.0,2.0,0.9999842268880484
172,1.6,"anywhere, but where you declare them depends on where you want them to be accessible (their scope)",4.0,5.0,4.5,0.9999574303013159
173,1.6,It depends if itâ€™s a global then they have to be declared out side the source code to be used in every scope however a local variable is one declared in a local function etc. which obviously doesnâ€™t need to be declared outside the variable seeing how it is used for the function or block its being called for. ,4.0,5.0,4.5,0.9999672052235787
174,1.7,"""The â€œdoâ€ statement first evaluates the condition and then executes the lines of code in the statement 0 or more times. 	The â€œdo whileâ€ statement executes the lines of code and then it evaluates the condition. """,4.0,5.0,4.5,0.9998794649952166
175,1.7,do...while statements evaluate whether or not to loop after running the block contained within it at least once. So the main differance is that while statements have a possibility of never being used. Do ... while statements on the other hand are always run at least once before evaluating whether to run again.,5.0,5.0,5.0,0.9999669387635721
176,1.7,"The main difference between a while and a do...while loop is that the do...while loop always cycles through the loop at least once, but the while loop does not always do so.",5.0,5.0,5.0,0.9999388667984953
177,1.7,While loop used to execute a block of code as long as some condition is true.  A do...while loop used to execute a block of code as long as some condition is satisfied.  The difference between while and do...while is while loop tests its condition before the execution of its contents and the do...while loop tests its condition after the execution of its contents at least once.,5.0,5.0,5.0,0.9999459560633458
178,1.7,"The termination condition of a do...while statement is usually at the end of the loop so it will run at least once. As for the while statement, if the condition is false to begin with, then the loop will never run.",5.0,5.0,5.0,0.9999284853822691
179,1.7,A while loop will check the statement to make sure it is true before executing. A do while loop will execute before checking the statement to see if it should run again.,5.0,5.0,5.0,0.9999194230819046
180,1.7,"A while statement will test the condition of the while loop FIRST - there is a chance the loop will never run. A do...while loop will ALWAYS run once, and then the while test will determine if it will run again.",5.0,5.0,5.0,0.999958236675009
181,1.7,a do while loop always executes once. A while loop's conditional statement has to be true for it to run.,5.0,5.0,5.0,0.9999794605332741
182,1.7,"-WHILE statement --The condition is checked for validity, then is repeated until the conditon is false.    -Do...WHILE statement--The code is performed at least once then checked for valid condition.  Will continue to                             ",5.0,5.0,5.0,0.99995151963189
183,1.7,"while statements will evaluate the statement BEFORE executing a cycle of the loop, including the first cycle, meaning that a while loop will not always execute. A do...while will run evaluate the statement AFTER running through a cycle of the loop, ensuring that the loop always executes at least one time.",5.0,5.0,5.0,0.9999168992648734
184,1.7,  The main difference between a do and a do...while statement is in a do...while statement is the statements in a do block are always executed atleast once.   The while statement will only execute if its condition is true.,5.0,5.0,5.0,0.9999721379817802
185,1.7,The loop of a do...while statement always executes once.,4.0,5.0,4.5,0.9999827967927827
186,1.7,"a while statement will only process if the statement is met, while a do...while will always process once, then only continue if the statement is met.",5.0,5.0,5.0,0.9998289379951807
187,1.7,"Do ...while runs the embedded code at least once, the do command does not necessarily",4.0,4.0,4.0,0.9999695148577328
188,1.7,"While tests for true first before running, do...while runs once first before checking.",5.0,5.0,5.0,0.9999281486832696
189,1.7,A do...while statement's body always executes at least once.  Where as a while statement will not execute at all unless the condition for the while is true.,5.0,5.0,5.0,0.9999706468517426
190,1.7,The statements within the block of the do while loop will always be executed at least once regardless of the conditions. Whereas the while loops may never be executed if the conditions are not met. ,5.0,5.0,5.0,0.9999369381042433
191,1.7,"a do... while loop will always run through once, while an while loop performs a test before running through the loop.",5.0,5.0,5.0,0.9999688053118075
192,1.7,A while statement tests the condition before it can start. A do...while statement loops through once before the condition is tested.,5.0,5.0,5.0,0.9999530438571611
193,1.7,"A while loop terminates at the beginning of the loop, a do/while terminates at the end of the loop.",3.0,4.0,3.5,0.9999174480681948
194,1.7,the loop body always executes at least once ,3.0,4.0,3.5,0.9999552736382614
195,1.7,"While loop evaluates its expression at the top of its loop and decides if it needs to execute, and the do-while always executes at least once and then evaluates its expression at the bottom of its loop.",5.0,5.0,5.0,0.9998479986583533
196,1.7,"A do...while statement will always execute the ""do"" piece of code at least once before checking the condition. A while statement will always check the condition first.",5.0,5.0,5.0,0.999950133709697
197,1.7,"A do-while passes atleast 1 time before checking the condition, however, a while would fail to enter the loop if the condition fails in its first place.",5.0,5.0,5.0,0.9999622772526834
198,1.7,"a while loop checks if the condition is true or not first, if it was true, it excutes the statement. a do.. while loop executes the statement before it checks the condition. if the condition was true it would excute the statement again. so a do...while loop would excute the statement atleast once.",5.0,5.0,5.0,0.9999152373783478
199,1.7,NO ANSWER,0.0,0.0,0.0,0.9997224460114088
200,1.7,"A do...while loop will always execute atleast once, a while loop may never   execute depending on teh conditions.",5.0,5.0,5.0,0.9999763595593193
201,1.7,"a while loop is pre-check (it checks the condition statement before it executes the code within the while block)  a do while loop is post-check (it checks the condition AFTER the block executes, it runs at least once no matter what the condition statement is)",5.0,5.0,5.0,0.9999498356673755
202,1.7,"))     What is the main difference between a while and a do...while statement? The do while construct consists of a block of code and a condition. First, the code within the block is executed, and then the condition is evaluated, this is done until it is proven false. The difference between the While loop is it tests the condition before the code within the block is executed. ",5.0,5.0,5.0,0.9999669017462783
203,2.1,"For us it is usually a set, get, and displayMessge or other messages that tell you what properties a class has but does not reveal its implementations. You could have anything you want in your own class definition.",1.0,3.0,2.0,0.9999364713807838
204,2.1,The attributes of said class. Also whether or not it is a subclass. Also whether it is public private or protected.,4.0,4.0,4.0,0.9999279604599612
205,2.1,Information telling the compiler what data members and member functions belong to the class.,5.0,5.0,5.0,0.9999606316700801
206,2.1,"Since class is user defined, the body of the declaration can contain members, that can be either data or function declarations, and optionally access specifiers.  Example for specifiers would be public, private, and protected.  There is the keyword Class and the Class body is enclosed with brackets ({}). ",5.0,5.0,5.0,0.9999680149494574
207,2.1,An object and data.,1.0,3.0,2.0,0.9998897378185236
208,2.1,"It's specific class name, includes only information defined by that class... implementation details... etc.",2.0,4.0,3.0,0.9998877826277828
209,2.1,data members and member functions.,5.0,5.0,5.0,0.9999631419805635
210,2.1,A class definition usually contains the function and its data members,5.0,5.0,5.0,0.9999297755773021
211,2.1,Data members and member functions,5.0,5.0,5.0,0.9999606284861517
212,2.1,member functions,3.0,4.0,3.5,0.9998686505173409
213,2.1,Member functions and data members belonging to the class.,5.0,5.0,5.0,0.9999705939035535
214,2.1,a public and private area that includes the functions and variables that are used in the class,5.0,4.0,4.5,0.9999262784087181
215,2.1,"the keyword class followed by they class name, on the inside you declare public and private declarations of your class",3.0,4.0,3.5,0.9999682634259848
216,2.1,A class definition typically includes function definitions.,3.0,3.0,3.0,0.9999599907227867
217,2.1,"It begins with Class, followed by the class name, then usually a constructor, data members and member functions that delineates the class is included in any class's definition.",5.0,5.0,5.0,0.9999703816403888
218,2.1,the data and methods ,5.0,4.0,4.5,0.9999249244495125
219,2.1,"A constructor, functions, and variables that are accessible to by that class, and possibly other classes depending on how they are done.",5.0,4.0,4.5,0.9999355915360473
220,2.1,Member functions and data members.,5.0,5.0,5.0,0.9999129336348552
221,2.1,"public section and private section, and there must be a semicolon to set the end",1.0,4.0,2.5,0.9998764132392594
222,2.1,member funtions and data members,5.0,5.0,5.0,0.9999606907664668
223,2.1,Data members and Member functions,5.0,5.0,5.0,0.9999545199996182
224,2.1,data members and member functions,5.0,5.0,5.0,0.9999374548453558
225,2.1,"the class name and its public data types such as constructors, methods, functions.",2.0,5.0,3.5,0.9999507622285955
226,2.1,"a constructor and several data members, and at least one public data member or method",4.0,5.0,4.5,0.9999536037858808
227,2.1,"class name, two curly prenthesis, public and private",1.0,3.0,2.0,0.9999681388110482
228,2.1,data members and member functions,5.0,5.0,5.0,0.9999374548453558
229,2.1,Data and functions,5.0,4.0,4.5,0.9998886131539859
230,2.1,functions and data members that belong to the class,5.0,5.0,5.0,0.9999469750077209
231,2.1,"class variables, function definitions for the class",5.0,5.0,5.0,0.999967800491577
232,2.1,"A class is an expanded concept of a data structure, it holds both the data and the functions being executed ",5.0,4.0,4.5,0.9999552417599825
233,2.2, Data members are the data components of a particular class.  A member function are the functioning components of the class.,1.0,5.0,3.0,0.9999690193762575
234,2.2, A field variable is a variable that is declared as a member of a class. A local variable is avariable that isdeclared local to a method.,1.0,4.0,2.5,0.9999658216326612
235,2.2,"Data members are declared inside the class, but outside of any member functions. Unlike with local variables, each object of the class keeps its own copy of the data members stored in memory.",4.0,5.0,4.5,0.9999728132484057
236,2.2,Data member are variables that represent an attribute in a class definition.  Local variables declared in a function body cannot be used outside of that function body.  When a function terminates the values of its local variables are lost.,4.0,5.0,4.5,0.9999670696651352
237,2.2,A local variable cannot be accessed outside the function in which it is declared. Data members normally are private. Variables of functions declared private are accessible only to member functions of the class in which they are declared.,5.0,5.0,5.0,0.9999891613806597
238,2.2,"A data member is part of a C++ class or structure that stores data of a certain type... A local variable inside a member function is only available inside that function, and can be used to derive a desired outcome.",4.0,5.0,4.5,0.9999541877416367
239,2.2,A local variable can only be accessed within the scope of its declaration.,3.0,4.0,3.5,0.9999796251456436
240,2.2,Data members are the atributes of the function and can be used outside the function. Local variable can not be used outside the function and the value is lost after the function terminates.,4.0,5.0,4.5,0.9999239640088876
241,2.2,"data members are permanent attributes of the class, local variables inside a member function are lost when the scope of the member function ends.",3.0,5.0,4.0,0.9999720259190741
242,2.2,data members are declared in a class definition but outside the bodies of a class's member-function definitions. Local variables are declared in a function definition's body,3.0,5.0,4.0,0.9999722716733521
243,2.2,"A data member is globally accessible, while a local variable is only accessible inside the member function.",4.0,5.0,4.5,0.9998955782892518
244,2.2,A variable inside a member function can only be accessed inside that member and a data member can be accessed throughought the program.,5.0,5.0,5.0,0.9999682295867646
245,2.2,Local variables are used only within the scope of its declaration,5.0,4.0,4.5,0.9999606258702041
246,2.2,"A data member is a more general term describing all objects instantiated within a member function.  ""Local"" in local variables refers more to the scope of a variable, which may be located in anything from a control structure to a class.  Local variables whose scope are in a member function are the same as data members of member functions.",0.0,4.0,2.0,0.9999698889581659
247,2.2,A data member exists permanently in that program's memory as long as it's run.  A local variable inside a member function is temporal and only used to operate in the function and exists as long as the function is run.,2.0,5.0,3.5,0.9999675984202855
248,2.2,"local variables can only be used within the function, where as data members can be set to public access and can be used throughout",5.0,5.0,5.0,0.9999376616744796
249,2.2,"The local variable is lost once it exits the block of code, while the data member is not.",4.0,5.0,4.5,0.999928317594186
250,2.2,Every member function can access and modify a data member. A local variable can only be used from the line of declaration to the next closing } before it is lost from memory.,4.0,5.0,4.5,0.9999632037210288
251,2.2,"data member is accessible to all functions in the class, where local variable is only available to the member function and value is lost when function closes",5.0,5.0,5.0,0.9999145522178905
252,2.2,Data members are variables that are declared inside the class definition but outside of the bodies of the class member functions. Local variables can only be used within the function declaration.,4.0,5.0,4.5,0.9999898449409734
253,2.2,"The data member can be accessed outside of the class, whereas the local variable cannot.",3.0,5.0,4.0,0.9999766631886853
254,2.2,"Local variables cannot be used outside of that function body. When a function terminates the values of its local variables are lost. Where as data members are variables in a class definition, and they exist throughout the life of the object. ",5.0,5.0,5.0,0.999970594255201
255,2.2,a local variable in a member function has to be static. a data member can change its value freely.,0.0,4.0,2.0,0.9998810393955522
256,2.2,"a local variable is only useable within the function it is defined, whereas a data member is available to any method within its class",5.0,5.0,5.0,0.9999337850216813
257,2.2,Variable declared in a function defination's body cannot be used outside of that function.  Data members accessible only to member function of that class.,5.0,5.0,5.0,0.9999453283536838
258,2.2,"data members   local variables are declared in a function definitionâ€™s body. they Cannot be used outside of that function body. When a function terminates, the values of its local variables are lost.   ",5.0,4.0,4.5,0.9999718039608195
259,2.2,local variable is only available in the function.,4.0,5.0,4.5,0.9998520067297338
260,2.2,local variables are accessed inside member functions only while data members   can be accessed throughout the class,4.0,5.0,4.5,0.9999819000646323
261,2.2,"A data member is accessible anywhere in the class, while i local variable in a member function is only accessible in that particular function, and is freed after the function exits.",5.0,5.0,5.0,0.9999480122611398
262,2.2,"a Data member is encapsulated within a class or object,  it is static and can be shared by all instances of that class.  however local variable's are only used from the function or block in which it is declared and not the whole class. other wise they would be called global variables. ",3.0,5.0,4.0,0.9999551497172969
263,2.3, A constructor initializes an object or objects of a class.  A function of a class performs a task such as display a line of text or do some kind of mathematical operations.,2.0,3.0,2.5,0.9999764936986351
264,2.3,"all constructors are functions but not all functions are constructors. Also functions can have nearly infinite purposes, while constructors always create an instance of whichever class you are using. You can change how a constructor does something but not what it does. With functions you can change not only the how but also the what.",2.0,4.0,3.0,0.9999823777503721
265,2.3,"Unlike regular functions, constructors are only used to initialize an objectâ€™s data when it is created. Constructors must also be given the same name as the class and cannot return any values. ",5.0,5.0,5.0,0.9999830277330313
266,2.3,"A constructor typically used to intialize data members and allocate resources, for instance memory, files, etc.  Also a constructor cannot return values.  Functions are operations that maybe globally defined.",4.0,5.0,4.5,0.9999824772511585
267,2.3,"Constructors cannot return values, so they cannot specify a return type. Normally, constructors are declared public.",3.0,5.0,4.0,0.9999844199993957
268,2.3,A constructor is a method that starts new instances of a class. (Example: Employee employee1(parameters) starts a new instance of object of type Employee). A function is simply a module w/in a program that completes its single desired task.,2.0,4.0,3.0,0.999988015351438
269,2.3,A constructor is called whenever a new object of that class is made.,4.0,3.0,3.5,0.9999849784016105
270,2.3,A constructor does not return any date and has no return type.  Functions can return date or not return data can have a return type.,3.0,5.0,4.0,0.9999608551758576
271,2.3,"A constructor is automatically called whenever an instance of a class is created, a function must be explicitly called by the user. ",4.0,4.0,4.0,0.9999896787956374
272,2.3,"constructors cannot return values, so they cannot specify a return type like functions can.",3.0,5.0,4.0,0.9999751264000598
273,2.3,A constructor is a function used to initialize an object's data when it is created.,4.0,3.0,3.5,0.9999786728514894
274,2.3,a constructor initialises everything so that nothing is left empty or with random varioubles and a function modifies those variables with data.,2.0,3.0,2.5,0.9999703293643356
275,2.3,A constructor initialized values at the execution of its instantiation. It provides default values.,4.0,3.0,3.5,0.9999741775352854
276,2.3,"A constructor sets up the default values of variables when an object is instantiated, whereas a function allows interaction with that object.",4.0,4.0,4.0,0.9999907438115394
277,2.3,"A constructor is used to create an object that can be employed in the main function of a program.  This may or may not execute code along with it.  A function is a set of code that executes when called, but does not create a new object.",3.0,3.0,3.0,0.9999698206799328
278,2.3,a constructor initializes data members but the functions actually perform tasks. Constructors cant return values either. ,3.0,5.0,4.0,0.9999553194971912
279,2.3,"a constructor does not need a type, and it is used to initialize the variables.",3.0,4.0,3.5,0.9999841464496784
280,2.3,Constructors don't have a return type.,3.0,5.0,4.0,0.9999694775017886
281,2.3,constructor creates the class object into memory where functions perform actions against that object,2.0,4.0,3.0,0.999976693922418
282,2.3,constructors cannot return values,3.0,5.0,4.0,0.9999405724221847
283,2.3,A constructor initializes values and a function usual performs some sort of operation.,2.0,3.0,2.5,0.9999797910279404
284,2.3,A constructor is a function used to initialize an object's data when it is created. It's call is made implicitly when the object is created and must be defined with the same name as the class. Constructor also cannot return a value like a function can.,5.0,5.0,5.0,0.9999813359730414
285,2.3,A constructor is used to create an instance of a class and has the same name as that class. A function cannot have the same name as a class and computes data.,4.0,4.0,4.0,0.9999513153751961
286,2.3,"a constructor is a function that initializes a class instance, a function performs whatever task it is written for",2.0,4.0,3.0,0.9999854818545643
287,2.3,"A constructor cannot return values, not even void, but function get a return value.",3.0,5.0,4.0,0.9999581692150714
288,2.3,"a constructor cannot return values, its not even void. it is used to initialize an object's data when it is created. whereas, a function is created to do a specific task, and it can return values.",5.0,5.0,5.0,0.9999663241950434
289,2.3,A constructor initializes an object. A function is part of an object.,1.0,4.0,2.5,0.9999644862554343
290,2.3,constructors initialize the data that is then used in the calculations of a   function,2.0,3.0,2.5,0.9999768861537733
291,2.3,"a constructor is called when the class is created, a function can be called any time.",4.0,3.0,3.5,0.9999580330694451
292,2.3,"constructor is a special block of statements called when an object is created, either when it is declared statically or constructed on the stack. However a function is a portion of code within a larger program, which performs a specific task and independent to the rest of the code. ",4.0,4.0,4.0,0.9999871162225089
293,2.4,The compiler creates a default constructor when we do not define one in our class file,5.0,5.0,5.0,0.9999799495703252
294,2.4,during compilation,2.0,5.0,3.5,0.9998628328262094
295,2.4,When the class does not explicitly include a constructor.,5.0,5.0,5.0,0.9999634774616843
296,2.4,When no parameters are set is when a default constructor is used.  ,3.0,3.0,3.0,0.9999708488401571
297,2.4,When a class does not explicitly include a constructor.,5.0,5.0,5.0,0.9999680724679665
298,2.4,When there are no arguments passed.,1.0,2.0,1.5,0.9999377380674048
299,2.4,when there is not one already for a specific class,5.0,5.0,5.0,0.9999542074033284
300,2.4,When it the programs compiles,2.0,5.0,3.5,0.9998801517844362
301,2.4,when a constructor is not provided by the programmer of the class,5.0,5.0,5.0,0.9999808580251281
302,2.4,In any class that does not explicitly include a constructor.,5.0,5.0,5.0,0.9999749451645122
303,2.4,Before the main function of the code.,0.0,2.0,1.0,0.999918368288498
304,2.4,whenevery you dont specifiy your own,5.0,5.0,5.0,0.9999326734116945
305,2.4,When non are provided,5.0,5.0,5.0,0.9997814504070851
306,2.4,C++ will create a default constructor when no other constructor is present.,5.0,5.0,5.0,0.9999836248359881
307,2.4,"When no constructor was specified in the constructor's class, but the class is instantiated in a program.",5.0,5.0,5.0,0.9999735956175141
308,2.4,"When no constructor exists when one is needed, a parameterless default constructor is declared.",5.0,5.0,5.0,0.9999784056368197
309,2.4,"The Compiler creates this automatically for you, unless you specifically create one.",5.0,5.0,5.0,0.9999795292549256
310,2.4,In any class that doesn't explicitly include a constructor.,5.0,5.0,5.0,0.9999656689650325
311,2.4,when no user-defined constructor exists,5.0,5.0,5.0,0.9998247482348386
312,2.4,"If a class does not explicitly include a constructor, the compiler creates one.",5.0,5.0,5.0,0.999979449731399
313,2.4,When you do not provide your own constructor.,5.0,5.0,5.0,0.9999703026808985
314,2.4,When a class does not explicitly include a constructor.,5.0,5.0,5.0,0.9999680724679665
315,2.4,C++ creates a default constructor during compilation if one is not provided.,5.0,5.0,5.0,0.9999802643083439
316,2.4,when a class does not explicitly include a constructor,5.0,5.0,5.0,0.999962482052534
317,2.4,The compiler will provide one when class does not explictly include a consructor.,5.0,5.0,5.0,0.9999673197822079
318,2.4,when the programmer does not explicitly include a constructor,5.0,5.0,5.0,0.9999714485438509
319,2.4,When one is not explicitly stated.,5.0,5.0,5.0,0.9999422725482648
320,2.4,when one is not explicitly included by a class ,5.0,5.0,5.0,0.9999516841317831
321,2.4,When you dont specify any constructors.,5.0,5.0,5.0,0.999946819228491
322,2.4,"at the very beginning when you run a complier, matter a fact in C++ it generates its own default constructor for the class provided if no other constructors have been provided by user",5.0,5.0,5.0,0.9999769612760028
323,2.5,Just one per class.,0.0,0.0,0.0,0.9998730506970875
324,2.5,As many as you want so long as they have different parameters.,5.0,5.0,5.0,0.9998456548761345
325,2.5,"There is no limit to the number of constructors in a class because like functions, constructors can be overloaded.",5.0,5.0,5.0,0.9999085856511121
326,2.5,It depends what type of class is being defined.  Typically you would have a constructor call for each object.,1.0,2.0,1.5,0.9999012718838954
327,2.5,"In C++, the constructor can be overloaded in that there can be more than one constructor for a class, each having different parameters.",5.0,5.0,5.0,0.9998912230637249
328,2.5,1,0.0,0.0,0.0,0.9998079123722537
329,2.5,any number you want,5.0,5.0,5.0,0.9998847618340739
330,2.5,One,0.0,0.0,0.0,0.9993966534806754
331,2.5,"by default just one, but they may be overloaded to create as many constructors as necessary",5.0,5.0,5.0,0.9998898660311689
332,2.5,as many as you want,5.0,5.0,5.0,0.9997852453375715
333,2.5,"As many as you want, with different parameters.",5.0,5.0,5.0,0.9998971663535188
334,2.5,infinite,5.0,5.0,5.0,0.9995382818357325
335,2.5,as many as you need,5.0,5.0,5.0,0.9997860115084075
336,2.5,"As many as are needed, depending on how many variables one wishes to directly modify or leave as default when instantiating an object.",5.0,5.0,5.0,0.9999053563614478
337,2.5,"A very large amount of constructors can be created for any given class through overloading.  When two constructors with a different type or number of parameters are created, they are said to be overloaded, and C++ can recognize which constructor to use based on the type of the variables that are passed/returned.",5.0,5.0,5.0,0.999906944295874
338,2.5,It depends on the number of objects. Each object should have a constructor.,1.0,4.0,2.5,0.9999474257421621
339,2.5,"Theoretically unlimited, as long as they are defined by the programmer.",5.0,5.0,5.0,0.999911596264925
340,2.5,As many as needed.,5.0,5.0,5.0,0.9998761748395181
341,2.5,as many as wanted/needed,5.0,5.0,5.0,0.9998831042538937
342,2.5,several,4.0,5.0,4.5,0.9995382818357325
343,2.5,One,0.0,0.0,0.0,0.9993966534806754
344,2.5,one,0.0,0.0,0.0,0.9996891446729929
345,2.5,There can be infinite constructors as long as the signature is different.,5.0,5.0,5.0,0.9998891909041594
346,2.5,that depends on the number of data members in the class,0.0,3.0,1.5,0.999915991975391
347,2.5,one,0.0,0.0,0.0,0.9996891446729929
348,2.5,you can overload constructors as you need,5.0,5.0,5.0,0.9998848554206635
349,2.5,As many as the programmer wants to create. ,5.0,5.0,5.0,0.9999090164609015
350,2.5,one,0.0,0.0,0.0,0.9996891446729929
351,2.5,"as many as you want, as long as they each have a unique argument list",5.0,5.0,5.0,0.9997989102185374
352,2.5,as many as the user decides to use. ,5.0,5.0,5.0,0.9998860127496353
353,2.6, A function definition does not require any additional information that needs to be passed inside its parenthesis  to execute. While a definition prototype requires more than one parameters to be passed in order to complete its  task.,5.0,3.0,4.0,0.9999475345153535
354,2.6,"The FUNCTION PROTOTYPE is where the programmer declares that he/she is using a function other than main( ). This is like declaring a variable, the programmer knows that he/she will be using in the future, but has yet to say where they are going to use it, or how. This is answers the question who, it gives the function a name and character. The function prototype, by common practice is placed at the beginning of the program after the #includes and before main( ). The FUNCTION DEFINITION is the guts of the function. This is where the programmer decides what the function is going to do and tells it how to do it. It takes whatever information it is given and performs the operations. It works sort of like the brain, the brain takes in input and based upon that input performs in some way producing an output. The function defintion is placed outside of main( ) and any other functions. A function is its own entity and should be thought of as such.",1.0,4.0,2.5,0.9999442792027615
355,2.6,"A function prototype tells the compiler the function name, return type and the number and type of parameters without revealing the implementations contained in the function definition.",5.0,5.0,5.0,0.9999772441362689
356,2.6,Function prototype is a declaration.  Function definitions (w/multiple parameters) often require more than one piece of information. to perform their tasks.,3.0,3.0,3.0,0.9999388847479137
357,2.6,"A function prototype is a declaration of a function that tells the compiler the function's name, its return type and the types of its parameters.",5.0,5.0,5.0,0.9999760423892133
358,2.6,A prototype shows only return types and necessary parameters. The definition includes names for those parameters and defines what the object is actually capable of doing.,5.0,4.0,4.5,0.9999470840145446
359,2.6,prototype only tells the user what data types go into a function and what type is returned.,5.0,4.0,4.5,0.9999346751496566
360,2.6,Function prototype is located in the .h file and only contains the access function name and paramater type.  Function definition contains the code for the function to perform its activity.,4.0,5.0,4.5,0.9999620883400184
361,2.6,"a function prototype is used to reference the compiler to a function that will be defined later on, a function definition is the actual function itself, complete with return type, parameters, etc...",4.0,4.0,4.0,0.9999598134826604
362,2.6,A function prototype describes a class's public interface without revealing the class's member function implementations,5.0,4.0,4.5,0.999945207620938
363,2.6,"Function definitions are just that, the definition. The prototype is what the compiler uses to check that calls to function are correct.",1.0,3.0,2.0,0.9999427918433668
364,2.6,a prototype does not include any actual code where the function has all the code that is executed in the program.,3.0,3.0,3.0,0.9999451487616434
365,2.6,a prototype declares what will be used in the program and the definition ,3.0,3.0,3.0,0.9999000476799805
366,2.6,"A function prototype lays out the name, return type, and the number and types of parameters the function expects to receive in a certain order.  The details for function prototypes are in the function definition.",5.0,5.0,5.0,0.9999626742191877
367,2.6,"A function definition is the code that defines the function placed in the {} brackets that determines that function's operation.  A function prototype shows the function's public interface without exposing implementation.  It shows name, return type and type of paramaters.",5.0,5.0,5.0,0.9999778883069598
368,2.6,"A function prototype is just a declaration of the function existing, and cant be used as an actual function. A function has to be created with a definition within to tell the compiler what the function does.",3.0,4.0,3.5,0.9999666225014742
369,2.6,the Prototype creates a framework to call the function definition. While a function definition is where the function is actually programmed out and created into a final product.,5.0,4.0,4.5,0.9999605301241822
370,2.6,A function prototype describes the class's public interface without providing how the function works. A function definition contains the inner workings of the function.,5.0,4.0,4.5,0.9999671136931868
371,2.6,"prototype states all functions in that class before compilation, where the definition actually holds the source for the functions",3.0,4.0,3.5,0.9999397052724414
372,2.6,"Function prototypes tell the compiler the function names, its return type, and the types of its parameters where as, function definitions actually implement the member functions.",5.0,5.0,5.0,0.9999580573452346
373,2.6,A function prototype just specifies parameters.  A function definition includes parameters and a code body.,4.0,4.0,4.0,0.9999493901528854
374,2.6,Function prototypes describe the class's public interface,5.0,4.0,4.5,0.9999347805720804
375,2.6,"A prototype only declares name, return type, and input type. A definition also defines the scope, variables, process, and return function ",4.0,5.0,4.5,0.9999491578849345
376,2.6,"a function prototype simply declares the functions parameters, the function definition includes any necessary variables and the function's actual code",4.0,4.0,4.0,0.9999644068575683
377,2.6,"A functgion prototype is a declaration of a function , while function definition specifies what a function does",3.0,4.0,3.5,0.9999444606411985
378,2.6,"in a function prototype you include the return type, the name of the function, and its parameters if any are needed.  in a function definition you write the code of what the function will do. ",5.0,5.0,5.0,0.9999527748764074
379,2.6,"A function definition contains all the code for a function to work. A function prototype just shows the output, input and function name.",5.0,4.0,4.5,0.9999572543456461
380,2.6,"function prototype describe the class's public interface without revealing   the class's member function implementations,  function definitions show what   implementations are being done",5.0,4.0,4.5,0.9999576077730016
381,2.6,"A function prototype only names the function, its return type, and it's argument list, while a definition defines the above as well as what the function actually does.",5.0,5.0,5.0,0.9999426997004643
382,2.6,function prototype describes a classes interface without reviling whatever is inside as for the function definition can't do that.  ,5.0,4.0,4.5,0.9999275380159492
383,2.7,the role of a header file list all the functions a class can do while hiding the inner workings of its functions ,5.0,4.0,4.5,0.9998891683227805
384,2.7,The main role of header file is it is used to share information among various files.,3.0,3.0,3.0,0.9999234893727011
385,2.7,Header files separate files in which classes are defined and allow the compiler to recognize classes when used elsewhere.,4.0,3.0,3.5,0.9999098805106791
386,2.7,No,0.0,0.0,0.0,0.9996185702948635
387,2.7,"A header file consists of ""reusable"" source code such as a class in a file that by convention has a .h filename extension. This differs from .cpp files that contain ""source-code.""",4.0,3.0,3.5,0.9998949964310806
388,2.7,"To provide information about the contents of a library. It includes the definition of classes, declarations of functions, data types, and constants.",5.0,4.0,4.5,0.9999059314414286
389,2.7,the header file shows the user what types go into and come out of a function but does not allow a user to manipulate the actual code for the function.,5.0,4.0,4.5,0.9998633019692715
390,2.7,Header files declares the class member functions.,3.0,4.0,3.5,0.9999179342224119
391,2.7,A header file allows for the separation of declaration and implementation into separate files. ,5.0,3.0,4.0,0.9999099363501496
392,2.7,the header file has access to the C++ Standard Library and makes certain classes like class string work.,0.0,3.0,1.5,0.999952560353988
393,2.7,â€œInstructâ€ the compiler on how to interface with library and user-written components.,2.0,3.0,2.5,0.9998762574015142
394,2.7,create a comon area to contain reusable functions.,3.0,3.0,3.0,0.9997606744952752
395,2.7,to declare the functions being used in the classes,3.0,3.0,3.0,0.9998703664149483
396,2.7,"#include ""hat.h""  allows the use of the hat container, so called from the act of pulling names from a hat.  The header file for hat includes functions for storage and retrieval of it's contents, mainly put(), peek(), and pull().",0.0,3.0,1.5,0.9999165038323015
397,2.7,To hold reusable content or modules separate from the actual  source-code file that can be easily referenced and employed for different programs.,5.0,3.0,4.0,0.9998894310787576
398,2.7,a header file is a file used to store a list of prototye functions and data members.,5.0,5.0,5.0,0.9999267790336526
399,2.7,"A header file is a cross communication method between source files, to help limit the size of each individual program. Without header files a program will be 1 large lump of code and thus fairly hard to debug and traverse.",3.0,4.0,3.5,0.9998882019710558
400,2.7,It contains reusable source code for use by other classes.,3.0,3.0,3.0,0.99984147615178
401,2.7,"to separate the source code from the main function, allows the methods/classes to be included in the program without direct coding. allows re usability.",4.0,3.0,3.5,0.9998966414017194
402,2.7,Header files have reusable source code in a file that a programer can use. ,3.0,2.0,2.5,0.999921762677261
403,2.7,To hide the definition and details of a class.  Also to help readability of the main C++ file.,4.0,3.0,3.5,0.9999195508016059
404,2.7,To allow the compiler to recognize the classes when used elsewhere.,3.0,4.0,3.5,0.9998957323504123
405,2.7,"A header file declares a class, its data, and functions available through that class.",5.0,3.0,4.0,0.9999572400784009
406,2.7,header files contain code which can be used in multiple files,3.0,3.0,3.0,0.9999317700982632
407,2.7,Allow compiler to recognize the classes when used elsewhere,3.0,3.0,3.0,0.9998824566977343
408,2.7,Allow compiler to recognize the classes when used elsewhere ,3.0,4.0,3.5,0.9998824566977343
409,2.7,To promote function reusuablitly,3.0,3.0,3.0,0.9997866444296333
410,2.7,class definitions are placed here,3.0,3.0,3.0,0.9998985312809819
411,2.7,A header file usually contains class and/or function prototypes.,4.0,5.0,4.5,0.9999146632726249
412,2.7,contains all the standard C++ library's i.e. string ,0.0,2.0,1.0,0.9998784088075474
413,3.1,"It includes the name of the program, the type of parameters it can take. It should also include a brief description of what the function does.",4.0,5.0,4.5,0.9999607570226554
414,3.1,it includes the specific information about the function such as input and output variable types and how many of each.,1.0,5.0,3.0,0.9998702175883253
415,3.1,The function signature includes the name of the function and the types of its arguments.,5.0,5.0,5.0,0.9999779624023449
416,3.1,"A function signature consists of the function prototype.  This tells you the general information about a function, its name, parameters, what scope it is in, and other miscellaneous information.",4.0,5.0,4.5,0.9999464342120028
417,3.1,It includes the name of the function and the types of its arguments.,5.0,5.0,5.0,0.9999732367975246
418,3.1,"Name, paramaters, scope, and other general function information",4.0,5.0,4.5,0.9998724929371043
419,3.1,It includes a function name and parameter list. Does not include return type. Function signatures must be different.,5.0,5.0,5.0,0.9999336128109639
420,3.1,input parameters and return type,1.0,5.0,3.0,0.9998680317969976
421,3.1,The portion of the function prototyp tha has the function name and the arguments but NOT the return type.,5.0,5.0,5.0,0.9999453741569391
422,3.1,Name of the function and the types of it's arguments,5.0,5.0,5.0,0.999980175951578
423,3.1,The name of the function and the types of its arguments.,5.0,5.0,5.0,0.9999992079246406
424,3.1,Includes the name of the function and the types of its arguments.,5.0,5.0,5.0,0.9999863702365445
425,3.1,"identification of a function and the data types of its parameters, it has the name, and the data type variables ",5.0,5.0,5.0,0.9999626379825002
426,3.1,"a return type, and input parameters",1.0,5.0,3.0,0.9998631081092404
427,3.1,The function signature includes the method name and the input types. ,5.0,5.0,5.0,0.999898753906388
428,3.1,"A function signature includes the name of the function and types of arguments, but not the return type.  ",5.0,5.0,5.0,0.9999487148917409
429,3.1,The signature can include a result type and thrown errors. ,1.0,3.0,2.0,0.999917769894232
430,3.1,"function name, and input paramaters",5.0,5.0,5.0,0.9998884995018483
431,3.1,"The name of the function and the types of its arguments. This includes the number, type, and order the parameters appear in.",5.0,5.0,5.0,0.9999818540544883
432,3.1,the name of the function and the types of its arguments,5.0,5.0,5.0,0.9999656437319903
433,3.1,A function signature includes the name of the function and the types of its arguments,5.0,5.0,5.0,0.9999753649255909
434,3.1,"A function signature includes a function's return type, parameters and semi-colon.",1.0,5.0,3.0,0.9998902693328291
435,3.1,the name of the function and the types of its arguments,5.0,5.0,5.0,0.9999656437319903
436,3.1,the function's name and parameters,5.0,5.0,5.0,0.9999273475740011
437,3.1,The name of the function and the types of its arguments.,5.0,5.0,5.0,0.9999992079246406
438,3.1,The portion of a function prototype that includes the name of the function and the types of its arguments,5.0,5.0,5.0,0.9999181985804549
439,3.1,the name of the function and its parameters,5.0,5.0,5.0,0.9999701152102137
440,3.1,The function name and parameters,5.0,5.0,5.0,0.9999304575930696
441,3.1,name of function and types of arguments,5.0,5.0,5.0,0.9999360176547608
442,3.1,a function's return type and parameter list,1.0,5.0,3.0,0.9998471191100188
443,3.1,"it includes the name of the function, and the types of its arguments. it does not specify the function return type. Function in the same scope must have unqiue signatures. ",5.0,5.0,5.0,0.9999661395172045
444,3.2,Any functions that follows their deceleration that  are in the source code file are allowed to have access the variables.  Also global scope variables retrain their value throughout the execution of the program.,5.0,5.0,5.0,0.9998090451970832
445,3.2,they can be accessed by any C++ file anywhere.,0.0,5.0,2.5,0.9997887673381995
446,3.2,Global variables have file scope.,5.0,5.0,5.0,0.9999025777528566
447,3.2,The scope of global variables are created by placing variable declarations outside any class or function definition.  Global variables retain their values throughout the execution of the program and they can be referenced by any function that follows their declarations or definitions in the source file.,0.0,5.0,2.5,0.9998190756323504
448,3.2,A global variable is an identifier that retains it's value throughout the execution of the program. It has file scope.,5.0,5.0,5.0,0.9998584635394819
449,3.2,Global Variables can be used in any function as long as the appropriate .h file that holds the variable is included,3.0,5.0,4.0,0.9997759877210299
450,3.2,They can be accessed by any part of the program. It can be referenced by any function that follows the declarations or definitions in the source file.,5.0,5.0,5.0,0.9998149347464895
451,3.2,can be accesed by any classes that have and object of that variables class in it,1.0,5.0,3.0,0.9998111367479541
452,3.2,Global variables have file-scope.  The variable is know to all functions throught the file,5.0,5.0,5.0,0.9998351744295505
453,3.2,The entire program,4.0,5.0,4.5,0.9998490677893008
454,3.2,They have file scope when placed outside a function.,5.0,5.0,5.0,0.9998648439334217
455,3.2,File scope.,5.0,5.0,5.0,1.0
456,3.2,They can be used throughout the program,4.0,5.0,4.5,0.999841868489944
457,3.2,Global variable can b accessed by any class wit an object in the variables class,1.0,5.0,3.0,0.9998375691099918
458,3.2,The scope of global variables is at the file level.,5.0,5.0,5.0,0.9998868460795417
459,3.2,Global variables all have file scope.,5.0,5.0,5.0,0.9998873743075277
460,3.2,it is accessible by all functions within a program,4.0,5.0,4.5,0.9998460401341626
461,3.2,"variables accessible anywhere in the program, as long as they are public.",4.0,5.0,4.5,0.9998184954393826
462,3.2,They can be referenced by any function following their declaration or definition inside the source file.,5.0,5.0,5.0,0.9998434664608139
463,3.2,"globally, anywhere in the program.",4.0,5.0,4.5,0.9998653513098085
464,3.2,Global variables have a file scope,5.0,5.0,5.0,0.9998664046186605
465,3.2,The entire program.,4.0,5.0,4.5,0.9998761721164034
466,3.2,throughout the execution of the program,4.0,5.0,4.5,0.9998174487610051
467,3.2,"If a variable is declared global, any function or class can use that variable.",4.0,5.0,4.5,0.9998753658112561
468,3.2,The entire program or file.,5.0,5.0,5.0,0.9999048764402415
469,3.2,throught the programm,4.0,5.0,4.5,0.9996486067663903
470,3.2,the whole code,4.0,5.0,4.5,0.999801923748438
471,3.2,File scope,5.0,5.0,5.0,0.9999465117519756
472,3.2,can be referenced by any function that follows their declarations or definitions in the source file,5.0,5.0,5.0,0.9998296562225804
473,3.2,global variables have program scope (accessible anywhere in program),4.0,5.0,4.5,0.9998904520620367
474,3.2,variables that exist throught the entire script. their values can be changed anytime in the code and fucntions. ,4.0,5.0,4.5,0.999820290323164
475,3.3,It expands the function's definition in that place.  Once the functions is called you can use it as many times as you need.  The compiler just expands on the function.,4.0,5.0,4.5,0.999966494382655
476,3.3,"When the compiler inline-expands a function call, the function's code gets inserted into the caller's code stream (conceptually similar to what happens with a #define macro). This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code â€” optimize the called code into the caller.   ",4.0,5.0,4.5,0.9999465242757393
477,3.3,The inline keyword advises the compiler to copy the function's code in place to avoid function calls; however the compiler can and typically does ignore the inline qualifier for all but the smallest functions.,5.0,5.0,5.0,0.999948864352219
478,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2.0,4.0,3.0,0.9999431606000441
479,3.3,"Placing the qualifier inline before a function's return type in the function definition ""advises"" the compiler to generate a copy of the function's code in place to avoid a function call.",5.0,5.0,5.0,0.9999579256299848
480,3.3,You declare your inline function in the header or before your int main(). You then can call that function at anytime in your main program quickly and easily.,0.0,4.0,2.0,0.9999636544362522
481,3.3,"It expands a small function out... making your code longer, but also makes it run faster.",4.0,4.0,4.0,0.9999510060694294
482,3.3,the function is not treated as a separate unit like other functions,4.0,3.0,3.5,0.9999611301403428
483,3.3,"When the program compiles,it will copy the function inplace, avoiding a function call.",5.0,5.0,5.0,0.9999636700233343
484,3.3,"It replaces all instances of that function call with the inline code itself, resulting in longer but faster programs.",5.0,5.0,5.0,0.9999362370449928
485,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2.0,4.0,3.0,0.9999431606000441
486,3.3,Ignores the inline qualifier and typically does so for all but the smallest functions.,2.0,4.0,3.0,0.9999399171718872
487,3.3,If the function is small enough it will expand it but it will run faster as it will avoid making so many calls to the function.,5.0,4.0,4.5,0.9999651164655903
488,3.3,it treats them as the same function,2.0,2.0,2.0,0.9999490735745359
489,3.3,"Inline functions are copied in place, instead of being referenced.",5.0,5.0,5.0,0.9999216005703859
490,3.3,"For inline functions, the compiler creates a copy of the function's code in place so it doesn't have to make a function call and add to the function call stack.",5.0,5.0,5.0,0.9999708379943774
491,3.3,it generates a copy of the function's coding which eliminates calling the function,5.0,5.0,5.0,0.9999511347460204
492,3.3,not answered,0.0,0.0,0.0,0.9995603538385917
493,3.3,It generates a copy of the function's code by by inserting it in the program.,4.0,5.0,4.5,0.9999667449862232
494,3.3,"tells the compiler to make a copy of function's code in place to avoid a function call.  it typically ignores it, except for the smallest functions.",5.0,5.0,5.0,0.999972349815692
495,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2.0,2.0,2.0,0.9999431606000441
496,3.3,"Multiple copies of the function code are inserted into the program, making it bigger.",4.0,5.0,4.5,0.9999544394225445
497,3.3,compiler ignores inline qualifier,2.0,3.0,2.5,0.9997046269169434
498,3.3,"It generates a copy of the function, if it is needed again.",2.0,5.0,3.5,0.9999730956560571
499,3.3,"The complier includes copies of inline functions instead of making function calls, but usually only with very small functions.",5.0,5.0,5.0,0.9999422193012795
500,3.3,Compiler generate a copy of the function's code in place (when appropriate) to avoid a function call,5.0,5.0,5.0,0.9999607952752367
501,3.3,"instead of calling the function every time it is invoked, the compiler will replace the function call with a copy of the function body",5.0,5.0,5.0,0.9999785862707152
502,3.3,Expands the function into the program,4.0,4.0,4.0,0.9999476661797895
503,3.3,it generates a copy of the functions code in place to avoid a function call,5.0,5.0,5.0,0.9999643763611941
504,3.3,the function call will be replaced by the code that was defined in the inline function,5.0,5.0,5.0,0.9999694409145031
505,3.3,"When the compiler inline-expands a function call, the function's code gets inserted into the caller's code stream (conceptually similar to what happens with a #define macro). This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code â€” optimize the called code into the caller. ",4.0,5.0,4.5,0.9999465242757393
506,3.4,Overall the program has better performance (means it is faster) because it does not have to copy large amounts of data.,5.0,5.0,5.0,0.9999659129000914
507,3.4,because you can't change the original and passing by reference limits memory needed for the program.,5.0,4.0,4.5,0.9999486379486382
508,3.4,Passing by reference can eliminate the pass-by-value overhead of copying large amounts of data.,5.0,5.0,5.0,0.9999841578182929
509,3.4,"It is often more efficient to pass references, rather than large objects, to functions. This allows the compiler to pass the address of the object while maintaining the syntax that would have been used to access the object.",5.0,5.0,5.0,0.9999578589868123
510,3.4,"Pass by reference is good for performance reasons, because it can eliminate the pass by value overhead of copying large amounts of data.",5.0,5.0,5.0,0.9999827694758935
511,3.4,You do not alter the original value of the variable that was passed.,3.0,3.0,3.0,0.9999474802768834
512,3.4,Don't have to make copies of stuff.,4.0,5.0,4.5,0.9999780634602302
513,3.4,you do not use unessesary memory space to copy variables between functions,5.0,5.0,5.0,0.9999800967333444
514,3.4,It elimitates the need to copy large amonts of data,5.0,5.0,5.0,0.9999807690973815
515,3.4,The function can change the data stored in a variable passed by reference directly.,3.0,4.0,3.5,0.9999738169802141
516,3.4,Gives called function the ability to access and modify the callerâ€™s argument data.,3.0,4.0,3.5,0.9999675726629325
517,3.4,Gives called function the ability to access and modify the callerâ€™s argument data directly.,3.0,4.0,3.5,0.9999784320689966
518,3.4,It is more efficient and it changes the variable not online inside the function but outside so that the new value can be used elsewhere.,3.0,3.0,3.0,0.9999067027545548
519,3.4,you don't make another copy and waste memory,5.0,5.0,5.0,0.9999674206584794
520,3.4,"Passing by reference eliminates the copying of large amounts of data, typical with pass by value.",5.0,5.0,5.0,0.9999789548350648
521,3.4,"If a function's arguments are large in size, computing time and memory space is not wasted copying down the argument and passing it to the function.  Also pass by reference gives the function called the permission to read edit the argument directly.",5.0,5.0,5.0,0.9999796033894844
522,3.4,"Gives access to the caller data directly, also it allows for modifying the data.",3.0,4.0,3.5,0.9999779945069912
523,3.4,"less overhead overall, and you modify the variable directly.",4.0,3.0,3.5,0.9999922222886178
524,3.4,The original variable being referenced can be modified directly by the called function.  ,3.0,3.0,3.0,0.999974676107612
525,3.4,gives function ability to access and modify the caller's argument data directly,3.0,4.0,3.5,0.9999768525042069
526,3.4,Gives the called function the ability to access and modify the caller's argument data directly.,3.0,3.0,3.0,0.9999575843410736
527,3.4,"Less overhead than passed by value, especially when using large numbers.",4.0,3.0,3.5,0.9999833853958262
528,3.4,"large data items can be passed without copying the entire data point, reducing execution time and the amout of memory space needed ",5.0,5.0,5.0,0.9999835401283047
529,3.4,The data can be modified directly instead of making a copy of the data. Improves execution time with large amounts of data.,4.0,4.0,4.0,0.999976964058736
530,3.4,Functions can directly modify arguments that are passed by reference.,3.0,4.0,3.5,0.9999779595002863
531,3.4,It gives access and modify the caller's argument data directly. It eliminate the pass by value overhead of copying large amounts ofdata,5.0,5.0,5.0,0.9999889465923747
532,3.4,"it takes less memory, thus it would make the program faster",4.0,4.0,4.0,0.9999558892528329
533,3.4,You are able to modify the variable that is referenced directly.,3.0,4.0,3.5,0.9999876324401183
534,3.4,"if you pass by reference, you can modify the value as opposed to passing by value where you cannot change the value",3.0,4.0,3.5,0.9999477138528566
535,3.4,"only the memory address is sent to the function, so no copy of the object sent needs to be made. It makes the function run faster, and saves memory.",5.0,5.0,5.0,0.999875861578711
536,3.4,"Actual arguments are associated with dummy arguments when a function or subroutine is referenced. In a procedure reference, the actual argument list identifies the correspondence between the actual arguments provided in the list and the dummy arguments of the subprogram",3.0,3.0,3.0,0.9999868995579522
537,3.5,"The compiler selects the proper functions to execute based on number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999833177607265
538,3.5,They differentiated by the compiler by the conditions/inputs used for one of the overloaded functions.,4.0,2.0,3.0,0.9999330896189498
539,3.5,"The compiler distinguishes overloaded functions by their signatures. It encodes each function identifier with the number and types of its parameters to generate type-safe linkage, which ensures the proper overloaded function is called.",5.0,5.0,5.0,0.9999600474728013
540,3.5,"Overloaded functions are distinguished by their signatures, Name mangling or name decoration, and type-safe linkage ensures that proper overloaded functions is called and types of the arguments conform to tpes to the parameters.",5.0,5.0,5.0,0.9999412152317442
541,3.5,"The compiler selects proper function to execute based on number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999568057302243
542,3.5,"By the type they are initilized with (int, char, etc.)",2.0,4.0,3.0,0.9999574471081403
543,3.5,"It selects the proper function to execute based on number, types and order of arguments in the function call.",5.0,5.0,5.0,0.999969668275494
544,3.5,overloaded functions must have the same return type but different input parameters,1.0,5.0,3.0,0.9999630675057642
545,3.5,"It examines the names, types, and order of arguments on each function.",5.0,5.0,5.0,0.9999684413342473
546,3.5,unique function signatures,5.0,5.0,5.0,0.9999415071157711
547,3.5,"Is based on number, types, and order of arguments in the function call.",5.0,5.0,5.0,0.9999587501364731
548,3.5,"Compiler selects proper function to execute based on number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999479320134133
549,3.5,not answered,0.0,0.0,0.0,0.9995603538385917
550,3.5,"they have to have same return type, but different input parameters",1.0,5.0,3.0,0.9999540658852228
551,3.5,Overloaded functions are differentiated by their parameters.,4.0,5.0,4.5,0.9999214002458752
552,3.5,"The compiler selects the right function to execute from the number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999772377010511
553,3.5,it creates a set of candidate functions then a set of viable functions,3.0,3.0,3.0,0.9999088228136207
554,3.5,their function signature.,5.0,5.0,5.0,0.9999661782914933
555,3.5,The number and type of its parameters.,5.0,5.0,5.0,0.999960951543936
556,3.5,by their function signature,5.0,5.0,5.0,0.9999750443933186
557,3.5,"They have the same name, just different parameters.",3.0,4.0,3.5,0.9999606039103506
558,3.5,"They are differntiated by number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999758637646221
559,3.5,"it looks at the number, types, and order of arguments in the function call ",5.0,5.0,5.0,0.9999756197722423
560,3.5,The compiler differentiates overloaded functions by their signature.,5.0,5.0,5.0,0.9998257135442653
561,3.5,"By the number, types, and order of their arguments",5.0,5.0,5.0,0.9999440404603963
562,3.5,"Compiler selects proper function to execute based on number, types and order of arguments in the function call.",5.0,5.0,5.0,0.9999479320134133
563,3.5,paremeters,4.0,5.0,4.5,0.9994984484596063
564,3.5,"By the number, and the types and order of the  parameters.",5.0,5.0,5.0,0.999950347043412
565,3.5,by the number and type of arguments,5.0,5.0,5.0,0.9999311770222197
566,3.5,"by their signature (return type, argument list)",3.0,5.0,4.0,0.9999173766590167
567,3.5,overloaded function simply invovles haing a method with the same name within the class. is used to implement a method for subclass which overrides in other words replaces the implementation of the super class. Overloading the concept of providing different meaning to a object based on the context of its presence. Overloading is one type of polymorphism and this is also a feature in programing. ,1.0,5.0,3.0,0.99996082704137
568,3.6,"A base case that is the simplest case for a problem so that the function will lead to it, if this does not happen then it will end up as an infinite loop. And a condition to know when to terminate.   ",5.0,5.0,5.0,0.9999800513526238
569,3.6,badly designed algorithyms. using recursion for a non recursive problem.,2.0,3.0,2.5,0.999965199567402
570,3.6,Infinite recursion can occur when the base case is omitted or the recursion step is written incorrectly so that it never converges on the base case.,5.0,5.0,5.0,0.9999747457402134
571,3.6,"Infinite recursion is an infinite loop if the condition is not met.  Either omitting the base case, or writing the recursion step incorrectly so that it does not converge on the base case causes ""indefinite"" recursion, eventually exhausting memory.  ",5.0,5.0,5.0,0.9999739029874659
572,3.6,Either omitting the base case or writing the recursion step incorrectly so that it does not converge on the base case can cause an infinite recursion. ,5.0,5.0,5.0,0.9999645687821068
573,3.6,Not having a base case that returns a base value.,3.0,5.0,4.0,0.9999629888322494
574,3.6,Incorrect or missing base case. Must reduce to the base case. The function must get simpler each time it is run (converge to the base case).,5.0,5.0,5.0,0.9999651598895338
575,3.6,no base case no change in values.,4.0,5.0,4.5,0.9999010989921989
576,3.6,"If at each recursive call the problem does not diminish or if it does not diminish to a base case, can cause infinite recursion.",5.0,5.0,5.0,0.99997576282116
577,3.6,Omitting the base case or incorrectly calling the recursive step.,5.0,5.0,5.0,0.9999650433313015
578,3.6,The recursive problem cannot be reduced to reach the base case.,4.0,5.0,4.5,0.9999842003057583
579,3.6,"Lack of defining a base case, or writing the recursion step incorrectly so that it does not converge on the base case",5.0,5.0,5.0,0.999987025275606
580,3.6,Not having the proper case to leave the recursion,3.0,5.0,4.0,0.9999541762401633
581,3.6,"no base case, or the recursive calls do not converge to the base case",5.0,5.0,5.0,0.9999790259973171
582,3.6,"No base case, or an incorrectly written recursion step that does not converge on the base case will lead to infinite recursion.",5.0,5.0,5.0,0.9999831368962063
583,3.6,"If the recursion function never reaches or successfully defines the base case it will recurse forever.  This happens many ways, such as the function doesn't progress towards the base case, or the function is coded poorly and doesn't even contain a base case.",5.0,5.0,5.0,0.9999820652876813
584,3.6," not creating a base case, or in the case where the base case will never be met.",5.0,5.0,5.0,0.999967681700574
585,3.6,improper handling of cases such that not all possible values are able to be handled.,2.0,5.0,3.5,0.9999762860150679
586,3.6,There is no base case. The recursion step doesn't reduce the problem during each recursive call.,4.0,5.0,4.5,0.9999819823477291
587,3.6,"no base case, as in a single return that does not include calling the function again.  a static value to end at.",2.0,5.0,3.5,0.9998787517748638
588,3.6,"Either omitting the base case, or writing the recursion step incorrectly so the it does not reach the base case can cause infinite recursion.",5.0,5.0,5.0,0.9999843202874648
589,3.6,omitting the base case or writing the recursive call so that it does not converge upon the base case.,5.0,5.0,5.0,0.9999475236367725
590,3.6,"Either omitting the base case, or writing the recursion step incorrectly so that it does not converge on the base case",5.0,5.0,5.0,0.9999873497722777
591,3.6,Infinite recursion may occur if no base case is defined or if the call is not varied.,4.0,5.0,4.5,0.9999813057501165
592,3.6,"Not having a base case, or building a recursion process that doesn't converge on the base case.",5.0,5.0,5.0,0.9999831340951244
593,3.6,"Either omitting the base case, or writing the recursion step incorerectly ",5.0,5.0,5.0,0.9999841417445071
594,3.6,no base case or if the programmar does not define the base case as the simplest case and it never gets reached,5.0,5.0,5.0,0.9999712396129481
595,3.6,No easily reached base case and no base case at all,5.0,5.0,5.0,0.9999742420613764
596,3.6,function is never allowed to reach the 'base case',5.0,5.0,5.0,0.9999639065022312
597,3.6,"it has no base case, or the base case is never met",5.0,5.0,5.0,0.9999341673297881
598,3.6,recursion refers to situations in which functions call themselves. These types of functions are known as recursive functions. That being said Infinite recursion occurs when the function is designed in such a way as to call it self forever without stopping possible causes,1.0,5.0,3.0,0.999973902266811
599,3.7,"Both involve a controlled repetition structures, and they both have a termination test.  Also both of them can loop forever. ",5.0,5.0,5.0,0.9999824127990322
600,3.7,"As discussed earlier, recursion may be used to process iterative actions. Recursion is used for calculations where the answer can be described in a function that relates to itself.",1.0,3.0,2.0,0.9999824320464449
601,3.7,Both iteration and recursion are based on control statements and involve repetition. They can both also occur indefinitely.,5.0,5.0,5.0,0.9999836059426853
602,3.7,Both are based on a control statement         - Iteration-repetition structure         - Recursion-selection structure        Both involve repetition         -Iteration-explicitly uses repetition structure         -Recursion-repeated function calls        Both involve a termination test         -Iteration-loop-termination test         -Recursion-base case         Both gradually approach termination         -Iteration-modifies counter until loop-termination test fails         -Recursion-produces progressively simpler versions of problem        Both can occur indefinitely         -Iteration-if loop-continuation condition never fails         -Recursion-if recursion step does not simplify the problem,5.0,5.0,5.0,0.9999288612266116
603,3.7,"Iteration and recursion have many similarities: both are based on a control statement, involve repetition, involve a termination test, gradually approach termination and can occur infinitely.",5.0,5.0,5.0,0.9999799547579248
604,3.7,"Both rely on repetition, both have a base case, both can become an infinite loop. Anything recursive can also be solved with iteration.",5.0,5.0,5.0,0.9999823401495183
605,3.7,"Both will repeat (loop) until a condition is met, and exit the loop. Both are capable of entering an infinite loop.",3.0,5.0,4.0,0.9999446473819272
606,3.7,anything you can do iterativly you can do recursively,2.0,4.0,3.0,0.9999688905769613
607,3.7,Both are repetative and both have a end test.,4.0,5.0,4.5,0.9999386548305192
608,3.7,"Incorrectly writing either can result in infinite loops, both perform the same task over and over.",3.0,4.0,3.5,0.9999806346491948
609,3.7,Both are based on a control statement. Both involve repetition. Both involve a termination test. Both gradually approach termination. Both can occur infinitely.  ,5.0,5.0,5.0,0.9999726764124071
610,3.7,"Both are based on a control statement, Both involve repetition, Both involve a termination test, Both gradually approach termination, Both can occur infinitely",5.0,5.0,5.0,0.9999783101295966
611,3.7,not answered,0.0,0.0,0.0,0.9995603538385917
612,3.7,anything you can do recursively you can do iteratively,2.0,4.0,3.0,0.9999688905769613
613,3.7,"Many problems can be solved by both iteration and recursion, and either may go into a condition of infinite execution if a termination test is omitted.",2.0,5.0,3.5,0.9999833942408113
614,3.7,"Iteration and recursion both use repetition and perform several simple operations and algorithms successively until they reach a certain limit.  So both involve a termination test to find that limit and both slowly approach that termination limit.  Both are based on a control statement as well.    If coded poorly, both can continue on for forever until the compiler or the computer either locks up, shuts down or halts the operation.",5.0,5.0,5.0,0.9999825759271963
615,3.7,"both based on control statement, involve repetition, and involve a termination test within loops",5.0,5.0,5.0,0.9999758923983653
616,3.7,they are methods of repeating the same task.,1.0,3.0,2.0,0.9999708251714066
617,3.7,Both involve a termination test.   They use a control statement and repition to solve the problem.  They can also result in an infinite loop.,5.0,5.0,5.0,0.9999830131954555
618,3.7,"based on a control statement, involve repetition, involve a termination test.",5.0,5.0,5.0,0.9999634254875076
619,3.7,Both are bases on a control statement. Both involve repetition. Both involve a termination test. Both gradually approach termination. Both can occur infinitely.,5.0,5.0,5.0,0.9999741770113494
620,3.7,"both based on a control statement, both involve repitition, both involve a termination test, both gradually approach termination, both can potentially occur infinetly.",5.0,5.0,5.0,0.9999729018677858
621,3.7,"they are both based on a control statement, both involve repetition, both involve a termination case, both graduatlly approach that termination case, and both can occur infinitely",5.0,5.0,5.0,0.9999839451712341
622,3.7,"They both use repetition, a control or test to terminate, and both can infinitely repeat if not defined correctly.",5.0,5.0,5.0,0.9999792024374147
623,3.7,"Both are based on a control statement; both gradually approach termination ending with a termination test; both involve repetition, and can both repeat infinitely if their  termination requirements are not met.",5.0,5.0,5.0,0.9999839576991567
624,3.7,"both are based on a control statement, involve repetition and involve a termination test. both gradually approach termination, both can occur infinitely",5.0,5.0,5.0,0.9999803469202456
625,3.7,they are used to solve the same type of problems. they do a task over and over again until a cirtain conditional statement is reached (its called the base case in recursion).,3.0,4.0,3.5,0.9999819945197089
626,3.7,Based on control statement;  involve repetition; involve a terminal test; both can occur infinitly   ,5.0,5.0,5.0,0.9999645363182048
627,3.7,"repetition, termination test, eventually terminate, occur infinately",5.0,5.0,5.0,0.9999232052475516
628,3.7,both need to have some kind of base case to tell when the loop needs to stop.,3.0,3.0,3.0,0.9999328525446436
629,3.7,"they both are able to do repetiive tasks. however recurisve calls itself with different parameters and defines and exit clause that is guaranteeed to be reached. Iterative includes a loop which iterates a pre-determined number of times, or checks for an exit clause every time through",2.0,5.0,3.5,0.9999821045637782
630,4.1,int n[10]; //array of 10 integers and int n[arraySize] //where arraySize is some positive integer defined by the user,3.0,5.0,4.0,0.9999826245972502
631,4.1,by either inputing the different elements in the array at coding or giving the array specifacations as to the size of the array. it is also possible when giving it specifacations to tell the array to grow as needed.,3.0,5.0,4.0,0.999936537878177
632,4.1,You can initialize and array by using an initializer list in its declaration or by initializing its size with a constant variable.,5.0,5.0,5.0,0.9999670243085559
633,4.1,Pass the length along with the array or use a vector.,2.0,4.0,3.0,0.9999163036067737
634,4.1,"One way is to declare a size of the array using a variable that is equal to an integer. The other way, if the size is omitted in the declaration, the compiler determines the size of the array based on the size of the initializer list.",5.0,5.0,5.0,0.9999346085344374
635,4.1,"In the declaration (int array [x]) or with an initilizer (int array[]={0,1,2,etc.}",5.0,5.0,5.0,0.9999143639269759
636,4.1,"1. Declare the length of the array (int array[10];) 2. Initialize the array (int array[] = {0, 1, 2, 3}; //compiler will assume size of 4)",5.0,5.0,5.0,0.999913721752693
637,4.1,statically and dynamically,2.0,3.0,2.5,0.9999018498030463
638,4.1,Explicitly int array[10]; or by variable const int size = 10; int array[size];,3.0,5.0,4.0,0.9998349488346301
639,4.1,"Array lengths can be explicitly specified by inputing the number of elements between the brackets [ ] during declaration, or implicitly by including an initializer list WITHOUT specifying a number between [ ], the compiler will automatically declare the array with the proper number of elements needed for the list. ",5.0,5.0,5.0,0.9999133445535114
640,4.1,Specify an arrays size with a constant variable. And setting array elements with calculations. ,2.0,5.0,3.5,0.9999485430339814
641,4.1,"statically, using {} and dynamically, using []",4.0,4.0,4.0,0.999942540960145
642,4.1,"define it as array[5] or array[1,2,3,4,5]",4.0,5.0,4.5,0.9999324168314702
643,4.1,Static and dynamic.,2.0,3.0,2.5,0.9999071488844302
644,4.1,manually inside the brackets or automatically via an initializer list,5.0,5.0,5.0,0.9998991625581901
645,4.1,"You can use an initializer list, or simply tell the compiler how many elements you want in the array.  For an Initializer list:  int a[] = {10, 2, 3, -4, 5};  For an elemental declaration: int b[5];  Both arrays have 5 elements in them, but array a is already initialized.",5.0,5.0,5.0,0.9999784595959211
646,4.1,"In a string you can specify with the strlen(arrayname) command. This gets the length of the string. Another way is with integers where you initiate the size from the start, ex array[40] specifying a possible length of up to 40. Then it is passed by an object the actual ammout in the array. Another way is to declare it in an initializing program. ",4.0,5.0,4.5,0.9999672274501012
647,4.1,"Implicit, namely when you give it values, like {1,2,3,4,5,6,7,8,9}, at which the compiler will automatically give this a size. Static, during the declaration. ",5.0,5.0,5.0,0.9999750437881966
648,4.1,"Supply an integer inside the brackets or the compiler counts the number of elements in the initializer list. int n[5]; int n[] = { 1,2,3,4,5 }",5.0,5.0,5.0,0.999945153470325
649,4.1,either initializing the array with a specific length or initializing an array while declaring its contents.,5.0,5.0,5.0,0.9999566812181093
650,4.1,within the brackets or by using an initializer list.,5.0,5.0,5.0,0.9999706684684594
651,4.1,specify the number of elements in the array declaration with a constant or using a constant variable for future scalability,3.0,5.0,4.0,0.9999387154712142
652,4.1,with a number and with a variable,3.0,3.0,3.0,0.9998915171297684
653,4.1,"explicitly, by declaring it in brackets (i.e. int array[50];) and implicitly, by initializing several values (i.e. int array[] = {1, 2, 3};)",5.0,5.0,5.0,0.9999408307832943
654,4.1,"one way of specifying of array is A[10] ; other way of specifying array is a[arraysize] = [1,2,3,4,5,6,7,8,9,10}",4.0,5.0,4.5,0.9999494230045238
655,4.1,1-Initializing an array in a declaration with an initializer list 2-Specifying an arrays size with a constant variable ,5.0,5.0,5.0,0.9999614510178191
656,4.1,"Initializing the size in the brackets: int a[100]; Initializing the length by assigning variables: int a[] = {1,2,3};",5.0,5.0,5.0,0.9998984712619229
657,4.1,user defined value or by the number of elements in initializer list,5.0,5.0,5.0,0.9999319477443018
658,4.1,"you can assign the size of it inside the brackets when you declare the array [3], or you can have it set by how many items you set the array equal to {1,2,3}",5.0,5.0,5.0,0.9999297655570806
659,4.1,"use an arraylist, or have your program ask the array how many elements it has. As an obj it it should have member length that is the number of slots it has. ",3.0,5.0,4.0,0.9999630524995452
660,4.2,"strings that are used in an char array are much easier to manipulate than as a string object, because each character is stored separately rather than as a whole",1.0,4.0,2.5,0.9999515092425073
661,4.2,"the type string uses less storage and you have to change the string all at once. with an array of characters you can make permutations of words using the characters stored in the array, without needing to actually access and change the variables. with an array of characters you can just change how they're accessed.",1.0,5.0,3.0,0.9999274402496195
662,4.2,"Unlike in a string declared using type string, in a string declared using an array of characters the programmer must provide the null terminating character and must ensure the array is large enough to hold the string and null terminating character.",5.0,5.0,5.0,0.9999684546905443
663,4.2,"All strings represented by character arrays end with the null character. You declare an object of type string just like any other type, for example:  string s; ",5.0,5.0,5.0,0.9999706803990115
664,4.2,"By using an array of characters, one can store and manipulate the strings rather than just having a type string variable.",1.0,4.0,2.5,0.9999834141598258
665,4.2,type string is an array of chars that will make an array of single letter characters while an array of strings will be an actual array of words (or an array of char arrays),0.0,4.0,2.0,0.9998906346497428
666,4.2,"They're basically the same, however, a string ends w/ a null character, denoting the end of the string (and the size). A char array has potential to be any size, so it must be declared or limited.",2.0,5.0,3.5,0.9999774258309829
667,4.2,string is a class in the standard library and has method that modify it. Whereas the char array is on able to be modifie by the user.,4.0,4.0,4.0,0.9999567964372132
668,4.2,"By using an array of characters, you are limited to the size of the array of characters.  By declaring by type the end of the string is acknowledged by white space.",3.0,4.0,3.5,0.9999595923068516
669,4.2,"The data class type string are designed to handle character data, and has many functions built into the class library to deal with them. An array of characters however is subject to all the same rules of any other array with no real additional functionality. Another difference is that the string class deals with the null character implicitly, unlike an array of characters, which must handle the null character explicitly. ",5.0,5.0,5.0,0.9999481855981729
670,4.2,string declared used in an array of characters contains each character in the array and a special string-termination character called the null character versus the type string.,5.0,5.0,5.0,0.9999544300353533
671,4.2,A char array reads a string as each individual character. A string literal array reads the entire string.,2.0,4.0,3.0,0.9999546568641918
672,4.2,array of characters can only hold as many characters as the array size and strings are not that limited.,4.0,4.0,4.0,0.9999182110204801
673,4.2,"Stings can only be modified by functions of the String class, an array of characters can be modified by the user",3.0,4.0,3.5,0.9999200977515782
674,4.2,"if by type string, the array contains an additional terminating null character",3.0,5.0,4.0,0.9999694459871462
675,4.2,The array of characters has a null character \0 at the end of the array to signify the array's end.  The string does not have this.,5.0,5.0,5.0,0.9999570235813172
676,4.2,strings with type string are just that. Strings. They are not part of an array list at all where as one declared by an array is actually an array of characters able to be pointed and detected.,2.0,4.0,3.0,0.9999523370314937
677,4.2,"the array of characters has a set length, while the type string has virtually unlimited length.",4.0,4.0,4.0,0.9999781131702669
678,4.2,Char array - Individual letters can be accessed directly with array subscript notation.  String array - array subscript will return the entire string.,1.0,3.0,2.0,0.9999486304684483
679,4.2,array of characters need a termination character as well as size specification whether its explicit or implicit.,5.0,5.0,5.0,0.9999550566506024
680,4.2,when using an array individual characters can be accessed and manipulated.,1.0,4.0,2.5,0.9999458520528473
681,4.2,strings declared using an array of characters could result in data loss if character array not initialized large enough.,4.0,4.0,4.0,0.9999807723845084
682,4.2,"an array is passed by reference therefore if an array of characters is changed, the memory is changed not just the variable",3.0,4.0,3.5,0.9999695053473677
683,4.2,"the type string has several built-in functions not available when using a char array, but the individual characters in an array or more directly accessible than the characters in a string type string.",3.0,4.0,3.5,0.9999725015957006
684,4.2,"declaring a string, it includes white spaces but declaring a array of character does not include white spaces",0.0,3.0,1.5,0.9999508119013537
685,4.2,"an array of characters has one element a string doesnt have. it is the termination element, or ""null""",5.0,5.0,5.0,0.9999748499170477
686,4.2,Strings declared using the type string can vary in length. Strings declared using an array of characters can not extend past the array length.,4.0,4.0,4.0,0.9999196558061295
687,4.2,"cant modify individual characters of a type string array, character type array can modify individual characters",1.0,4.0,2.5,0.9999488203868134
688,4.2,"the type string is a class and is safer, while the other is just an array of characters.",3.0,4.0,3.5,0.9999563007889675
689,4.2,"array  it is the collection of similar data types ex:int a[10]  ten indicates the size of array. [ ] is index of array, we can give only integer values to array of a.  where as string mean collection of group of characters.  string declarations have a datatype usually causes storage to be allocated in memory that is capable of holding some predetermined number of symbols.    However  Arrays can be declared to contain values of any non reference data type. Multiple arrarys of the same type ",1.0,4.0,2.5,0.9999500427449827
690,4.3,by reference only,5.0,5.0,5.0,0.9999548069705263
691,4.3,a reference pointer to an element in the array.,4.0,5.0,4.5,0.9998928440298284
692,4.3,Arrays are passed to functions by reference.,5.0,5.0,5.0,0.9998867677521607
693,4.3,-Arrays are passed by reference         -Individual array elements passed by value        -Functions that take arrays as arguments         -Function prototypes may include parameter names        -const array parameters,5.0,5.0,5.0,0.9997533600229839
694,4.3,Arrays are passed by reference.,5.0,5.0,5.0,0.9999161853842473
695,4.3,"you must pass the array and its size to the function. Ex. function(array, size);",4.0,4.0,4.0,0.9998457258781586
696,4.3,"Usually the same way you pass anything else... you do not have to specify the length of a char array, just pass it to the function by sending the name of the array.  Example: char str[20]; isPalindrome(str); // this sends the char array to the function isPalindrome.  Otherwise, would need to send the length of the array as well.",3.0,4.0,3.5,0.9998758616515765
697,4.3,you pass a pointer to the first item and also pass the size.,4.0,3.0,3.5,0.9998412053619915
698,4.3,By reference.,5.0,5.0,5.0,0.9998770085835483
699,4.3,"In two parts, the array itself, and it's size, so that the function it's being passed to can avoid out of bounds errors.",4.0,4.0,4.0,0.9999053758829854
700,4.3,Specify array name without brackets. Array size is normally passed as another argument so the function can process the specific number of elements in the array. Arrays are passed by reference. Individual array elements passed by value. Functions that take arrays as arguments.   ,5.0,5.0,5.0,0.999838733044557
701,4.3,Arrays are passed by reference.,5.0,5.0,5.0,0.9999161853842473
702,4.3,the same way but with [] at the declaration and the actual function.,3.0,3.0,3.0,0.9998646014795537
703,4.3,specify the array name without brackets.,3.0,3.0,3.0,0.9998728000449797
704,4.3,by reference,5.0,5.0,5.0,0.9999555201852726
705,4.3,"You pass the name of the array to the function. So for: int bin [10]; you pass it to an array like so: jingle(bin); but jingle must be declared correctly in order to receive an array, either with prototype void jingle (int []); or with the definition in its initialization: void jingle (int array[]);  It's also worth noting that arrays are passed to function by reference, so as to not copy large arrays over and over and burn memory.  This gives the function complete control over the array however.",5.0,5.0,5.0,0.999890200909944
706,4.3,They are called by the function then the function must loop through the array to get the set of characters. ,1.0,3.0,2.0,0.9998139204122137
707,4.3,"by reference by default, unless you specify const, at which the later will make the array unmodifiable.",5.0,5.0,5.0,0.9999061291441168
708,4.3,"The function recieves both the array and the array size as parameters. function(arrayName, arraySize)",4.0,4.0,4.0,0.9998745415759337
709,4.3,specifying array name and passing as reference in an argument into the function,5.0,5.0,5.0,0.9999076379450194
710,4.3,1st you must specify the array name without brackets and then the array name and size are passed as two arguments in the function call.,4.0,4.0,4.0,0.9998591820012916
711,4.3,"arrays are passed by reference, passing the starting address of array. programmer specifies the array name without brackets and passes the array size as another argument so the function can process the specific number of elements in the array",5.0,5.0,5.0,0.999853521077743
712,4.3,by reference only,5.0,5.0,5.0,0.9999548069705263
713,4.3,by reference,5.0,5.0,5.0,0.9999555201852726
714,4.3,by reference,5.0,5.0,5.0,0.9999555201852726
715,4.3,by refrence,5.0,5.0,5.0,0.9996201525411096
716,4.3,"function( int [], int length)",4.0,4.0,4.0,0.999858424739079
717,4.3,by reference,5.0,5.0,5.0,0.9999555201852726
718,4.3,by reference,5.0,5.0,5.0,0.9999555201852726
719,4.3,"The function reads the variables, stores them. then returns the what ever the variable reads. The function then prints the content of the array. ",1.0,4.0,2.5,0.9998767392259217
720,4.4,a static array will store the new values that were assigned to each of its elements. meaning if you call a function twice it will use the last values that were returned the first time.  if you don't declare it static then the new values will not be stored and will be reset to their original value,5.0,5.0,5.0,0.9999803881824659
721,4.4,a static array can only be referenced not accessed. Also static arrays can be used without creating an object.,3.0,5.0,4.0,0.9999761459127938
722,4.4,An array declared as static is not created and and initialized each time the function and it is also not destroyed when the function terminates.,5.0,5.0,5.0,0.9999825319916976
723,4.4,"A program intializes static local arrays when their declarations are first encountered.  If a static array is not initialized explicityly by the programmer, earch element of that array is intialized to zero by the compiler when the array is created.  Non-static array members cannot be initialized at all in C++.",3.0,5.0,4.0,0.9999854916826736
724,4.4,Arrays that are static remain the same size throughout the program execution.,3.0,5.0,4.0,0.9999678377413052
725,4.4,"a static array will only be initilized once, a non static array will be re-initilized once the program reaches the initilization line again.",5.0,5.0,5.0,0.9999744106107944
726,4.4,An array declared as static is available from beginning of program to end. One w/o static declaration disappears if it is not accessed within the right scope.,4.0,5.0,4.5,0.9999732833048174
727,4.4,a static array has pre-runtime size and that size cannot be changed. A dynamic array gets its size at runtime.,1.0,5.0,3.0,0.9999688475872387
728,4.4,"If an array is declared as static, it is not created each time the array is called.",5.0,5.0,5.0,0.9999592479704328
729,4.4,"An array that is not declared as static will re-initialize every time the function declaring it is called. A static array will initialize only once, at the declaration, and will store the values in it's elements throughout the duration of the program, even if the same function is called multiple times, a static array will only initialize once.",5.0,5.0,5.0,0.9999929268359402
730,4.4,"All elements are initialized to zero if not explicitly initialized, this does not happen for automatic local arrays  ",4.0,5.0,4.5,0.999974800738253
731,4.4,"All elements are initialized to zero if not explicitly initialized for a static array, while a non-static array is not initialized to zero.",4.0,5.0,4.5,0.9999602896223923
732,4.4,static cannot be changed,1.0,5.0,3.0,0.9999074353265327
733,4.4,"A static array has a set size that cannot change. The data may not need all of the space assigned, or could go beyond the size.",3.0,5.0,4.0,0.9999592635251554
734,4.4,"A static member prevents naming conflicts (not put into global namespace) while allowing for information hiding (private, public).",1.0,5.0,3.0,0.9999483744941723
735,4.4,A static local array exists for the duration of the program and its elements are initialized to 0 if not explicitly initialized. So a static local array's elements will still be the same when called later unless specifically initialized to something else.  This doesn't happen for automatic arrays.,5.0,5.0,5.0,0.999987509499084
736,4.4,"Static arrays are those with a declared size, that is known to the program, whereas non-static arrays leave the size undeclared and open so it can be assigned later. Usually used for input purposes. ",1.0,5.0,3.0,0.9999795056378451
737,4.4,"static arrays keep the values after the end of a function, while non static reinitialize every time.",5.0,5.0,5.0,0.9999712554872597
738,4.4,"Static arrays are created and initialized only once, and the values aren't destroyed  when the function terminates in the program. Automatic arrays reset everytime the function is called.",5.0,5.0,5.0,0.9999847152811052
739,4.4,"its not created and initialized each time program calls the function, and is not destroyed every time the function ends in the program.",5.0,5.0,5.0,0.9999757350938314
740,4.4,"When we declare it static the array is not destroyed after the function is over.  When an array is not declared as static, the array is created and initialized every time a function calls it.",5.0,5.0,5.0,0.9999834756836645
741,4.4,the static array exists for the duration of the program ,4.0,5.0,4.5,0.9999725977131185
742,4.4,an array declared as static can only be declared once,2.0,5.0,3.5,0.9999762777453014
743,4.4,"A static array exists in memory until the program terminates, whereas an automatic (or normal) array is removed when the function that created it terminates",5.0,5.0,5.0,0.9999854445991664
744,4.4,not answered,0.0,0.0,0.0,0.9995603538385917
745,4.4,Only constants can be used to declare the size of automatic and static arrays Exists for the duration of the program Is initialized when its declaration is first encountered All elements are initialized to zero if not explicitly initialized ,5.0,5.0,5.0,0.9999722613648591
746,4.4,A static array cannot be changed in the program.,1.0,5.0,3.0,0.999930050117794
747,4.4,static arrays are available throughout the program,5.0,5.0,5.0,0.9999682723682912
748,4.4,"a static array is allocated when the program starts and is freed when the program exits but has limited scope, while an array that is not declared static is allocated and freed when it comes into and out of scope.",5.0,5.0,5.0,0.9999850187551093
749,4.4,"if they are declared fixed or static that means they can't change size once their storage has been allocated, however one that is not or dynamic arrarys can be resized.   ",1.0,5.0,3.0,0.999976833948105
750,4.5,"at least 2, depending on how many arrays are being used.",1.0,4.0,2.5,0.999961942526963
751,4.5,all of them.,2.0,5.0,3.5,0.9999259125609073
752,4.5,"When passing a multi-dimensional array, all dimensions must be specified except for the first dimension.",5.0,5.0,5.0,0.9999624379499572
753,4.5,It depends what parameters you are passing in a multidimensional.  A multideminsional can have more than two dimensions.,2.0,5.0,3.5,0.9999575323439006
754,4.5,The first dimension is not required however the subsequent dimension(s) are needed for the compiler.,5.0,5.0,5.0,0.9999504536996623
755,4.5,all but the first,5.0,5.0,5.0,0.9999322899147741
756,4.5,All of the dimensions must be specified.,2.0,5.0,3.5,0.999968475808656
757,4.5,just the first one at least.,1.0,3.0,2.0,0.9999477766775342
758,4.5,"Two paramaters, the array and how many columns.  array(a[],[3])",4.0,4.0,4.0,0.999946789582456
759,4.5,"The size of the first dimension can be omitted, same as a regular array. However, for every dimension outside the first, the size of those dimensions must be specified when passed, for example, a multi-dimensional array of [2][4][6] with the name MultiArray would be passed as: ""MultiArray[][4][6], 2""",4.0,5.0,4.5,0.9999423168898386
760,4.5,Size of subsequent dimensions are required. Compiler must know how many elements to skip to move to the second element in the first dimension  ,4.0,5.0,4.5,0.9999633907329487
761,4.5,Every dimension after the first.,5.0,5.0,5.0,0.9999321103933799
762,4.5,both,2.0,3.0,2.5,0.9995015009940228
763,4.5,"the size of the first dimension does not need to be specified, but all other dimensions do.",5.0,5.0,5.0,0.9998497878443054
764,4.5,"when passing (in main) a multidimensional array to a function, no dimensions need be specified",1.0,3.0,2.0,0.9999590354738429
765,4.5,"All dimensions except for the first one need to be specified when passing an array to a function, the compiler needs to know how many memory addresses to skip to make it back to the 2nd element in the first dimension.  The size of the first dimension does not need to be specified.",5.0,5.0,5.0,0.9999319980258286
766,4.5,as many as there are dimensions. Most commonly just rows and columns,2.0,5.0,3.5,0.9999643133772725
767,4.5,"at least 2, but it should always equal the number of dimensions that the argument is expecting... like...  blah[][][][] will require 4 dimensional array input. blah[][][] will require a 3 dimensional array. blah[][] will require a 2 dimensional array.",1.0,5.0,3.0,0.9996548851383694
768,4.5,"None, just pass the array name.",1.0,3.0,2.0,0.9999332548742035
769,4.5,all subsequent dimensions after the first dimension.  first is not needed to be specified.,5.0,5.0,5.0,0.9999596373136721
770,4.5,"all dimensions, excluding the first one.",5.0,5.0,5.0,0.9999843544021965
771,4.5,all dimensions but the first ,5.0,5.0,5.0,0.9999775812171172
772,4.5,the first needs to be specified by size and the rest need only be stated( first like this [3] then [][][]),1.0,5.0,3.0,0.9998585785005121
773,4.5,one less than the number of dimensions the array contains,4.0,5.0,4.5,0.9999576824072395
774,4.5,not answered,0.0,0.0,0.0,0.9995603538385917
775,4.5,one,1.0,3.0,2.0,0.9996891446729929
776,4.5,All subsequent dimensions after the first one.,5.0,5.0,5.0,0.9999659685047095
777,4.5,two or more,1.0,4.0,2.5,0.9998305093371616
778,4.5,1 less than the total number of dimensions,4.0,5.0,4.5,0.9999081962916254
779,4.5,"Multi dimensional arrays are accessed using more than 1  index, one for each dimension at least. ",2.0,5.0,3.5,0.9999642528666403
840,5.1,"Takes an element of an array and compares it with the next element, depending on the values of the two elements they will switch and then the program will compare the new switched element with the next one in the array.",1.0,5.0,3.0,0.9999559349787966
841,5.1,"Insertion sort divides the list into sorted and unsorted regions, then takes each item from the unsorted region and inserts it into its correct order in the sorted region.",5.0,5.0,5.0,0.9999734432334567
842,5.1,The sorted array or list is built one entry at a time.,3.0,4.0,3.5,0.999957529114224
843,5.1,It starts with the second element and checks it to see if it is less than the element(s) to the left of it and if it is it inserts it into its corrected position.,5.0,5.0,5.0,0.9999664487073227
844,5.1,Compare two numbers at a time and swap until the entire list is sorted.,1.0,3.0,2.0,0.9999702486995369
845,5.1,"Assume the first number is sorted, then move down the list and 'insert' the numbers you come across into the corresponding place on the sorted side of the list.",5.0,5.0,5.0,0.9999691645931682
846,5.1,insertion sort is were after k iterations the first k items in the array are sorted it take the k+1 item and inserts it into the correct position in the already sorted k elements.,5.0,4.0,4.5,0.9999671624768242
847,5.1,Looking at the 2nd element move forward and place the element in the correct spot.,4.0,5.0,4.5,0.9999620168775787
848,5.1,"Starting at the beginning of an array, take each element in order and place it in it's correct position relative to all previously sorted elements. ",5.0,5.0,5.0,0.9999717083982395
849,5.1,To sort the elements in an array by removing an element from the input data and inserting it at the correct position. ,5.0,5.0,5.0,0.9999868124735756
850,5.1,"Insertion sort removes an element from the data, and inserts it at the correct position in the already sorted list.",5.0,5.0,5.0,0.9999776968773104
851,5.1,Take a number and choose a pivot point and insert the number in the correct position from the pivot point.,2.0,4.0,3.0,0.9999767796518774
852,5.1,have a marker and sort everything to the left of the value for every new value when moving to the right.,3.0,3.0,3.0,0.9999749732221637
853,5.1,The main idea behind insertion sort is to take a random variable from the right and insert it in order to the left.,4.0,5.0,4.5,0.9999753488737695
854,5.1,Insertion sort progresses through a list of elements and determines where the next element should be inserted into an already sorted array starting with sorting and using the first two elements.,5.0,4.0,4.5,0.9999737296440135
855,5.1,"it goes through the list only once, picking each integer and putting it in its desired position, then continuing. ",4.0,4.0,4.0,0.9999803173461612
856,5.1,Inserting array items in to their appropriate positions from smallest to largest at a pivot which starts on the second element of the array.,3.0,4.0,3.5,0.999985222159888
857,5.1,Insert the item into its proper position by shifting larger sorted array values to the right. ,1.0,5.0,3.0,0.999962293060846
858,5.1,a comparison sort in which the sorted array is built one entry at a time,4.0,4.0,4.0,0.9999669428737541
859,5.1,"Insertion sort is an algorithm where the first element of the array is in the sorted list, all the other pick one by one and taken from the unsorted array, to the sorted array.",5.0,4.0,4.5,0.999977074415602
860,5.1,"Every iteration of an insertion sort takes away an element from the input data, inserting it at the right position in the sorted list.",5.0,5.0,5.0,0.9999791579610032
861,5.1,the insertion sort creates a new array and inserts each item in its place with respect to the new array.,4.0,4.0,4.0,0.999971168972331
862,5.1,"Insertion sort takes each entitity of an unsorted array in order, and sorts it into the correct position between the entities it has sorted.",5.0,5.0,5.0,0.9999785814214449
863,5.1,"it takes the second element and swaps it with the 1st if it is less and keeps it there if its larger, then it goes to the third element and inserts it in the right places with respect to the first 2 elements and so on... ",5.0,5.0,5.0,0.9999646170900639
864,5.1,"Starting with the first element in the array, each following element is put in place by determining if it is smaller or larger than the starting element.",3.0,5.0,4.0,0.9999883935197003
865,5.1,"one by one, each item is taken and placed into the correct place in the sorted portion of the array until there are no more items",5.0,4.0,4.5,0.9999762698788226
866,5.1,you take each element and insert it in the correct position with respect to all the elements before it,5.0,5.0,5.0,0.9999572134836073
867,5.1,"Insertion sort is a simple sorting algorithm, a comparison sort in which the sorted array (or list) is built one entry at a time.",4.0,4.0,4.0,0.9999648663080305
868,5.2,Searches an array for the largest or the smallest element and is moved out to the front of the array then it will search for the next largest or the smallest element to move out to the front,5.0,5.0,5.0,0.9999300541953741
869,5.2,"Selection sort searches the whole array for the largest item and puts it at the end of the array, then searches for the second largest item and puts it at the second to last spot and so on.",5.0,4.0,4.5,0.9999394795981317
870,5.2,Finds the minimum value and swap it with the value in the first position.,5.0,5.0,5.0,0.9999716999630418
871,5.2,It finds the minimum element in the array and swaps it with the first element then repeats this step swapping the minimum element with nth positions in the array.,5.0,5.0,5.0,0.9999685676787001
872,5.2,"Find the lowest value and place it at the front, then find the next lowest and place it in front of the last value, etc.",4.0,5.0,4.5,0.9999668772373146
873,5.2,"Cycle through the unsorted list, place the minimum in the next slot in the sorted list, and repeat.",5.0,4.0,4.5,0.9999605869046272
874,5.2,find the minimum value in the list swap it with the first element in the list the find the second largest and swap it with the second element in the array continue like this until  the array is sorted.,5.0,5.0,5.0,0.9998716983507366
875,5.2,Find the smallest and put it in the current position till you get to the end.,5.0,5.0,5.0,0.9999722458452762
876,5.2,"Find the lowest unsorted value in the array and place it at the current position (starting at the first element in the array) and advance the ""current"" position by one. ",5.0,5.0,5.0,0.9999686190069059
877,5.2,To sort the elements by comparing two elements and swapping the smaller one to sort the elements in the array.,2.0,5.0,3.5,0.9999617547658746
878,5.2,"Selection sort finds the minimum value in the list, swaps it with the first value in the list, and repeats throughout the list.",5.0,4.0,4.5,0.9999703356332706
879,5.2,"Select the minimum number from the array and put it in the current position, then move on",5.0,5.0,5.0,0.9999174419281751
880,5.2,Find the lowest value and place it in the front of the list and swap it with that value. Continue moving right.,5.0,5.0,5.0,0.9999722847206378
881,5.2,The main idea behind selection sort is to take the least variable from the right and put it directly to the left.,5.0,4.0,4.5,0.9999813116127427
882,5.2,"Find the smallest value in the list and make it the first element, then find the smallest value of the leftover list and make it the first element of the leftover list and continue until the list is sorted.",5.0,5.0,5.0,0.9998929769667523
883,5.2,It runs through and finds the lowest (or highest) value and puts it in its desired position.,5.0,4.0,4.5,0.9999602602071981
884,5.2,"Places the smallest item in the list at position 1, and then proceeds to each value until the last position of the ray is reached.",5.0,5.0,5.0,0.9999868559356878
885,5.2,Search for the largest item in an array and swap it with the last unsorted item. ,5.0,4.0,4.5,0.999948192854987
886,5.2,finds the smallest element and places in 1st position. then the process is repeated on the rest of the array.,5.0,5.0,5.0,0.9999813016405651
887,5.2,Selection sort is an algorithm that selects the larges item the array and puts it in its place; then select the next largest until the array is sorted,5.0,4.0,4.5,0.9999838187056559
888,5.2,Select the smallest number in the list and move it to the front of the list and then advance to the next number.,5.0,5.0,5.0,0.9999552576357896
889,5.2,the selection sort chooses the largest or smallest value in an unsorted list and creates a new list using the selection depending on how it is sorted.,5.0,4.0,4.5,0.9999773461918015
890,5.2,"Selection sort finds the smallest number left unsorted in an array, and puts it at the end of what it has sorted",4.0,5.0,4.5,0.9999781230744325
891,5.2,"selects the minimum from the remaining elements of the array, and palces the miminum in the current position and moves to the next position",5.0,5.0,5.0,0.9999724442695497
892,5.2,"To put the biggest element at the end of the list and place the next highest element behind it, and so on.",3.0,4.0,3.5,0.999965113824056
893,5.2,"the sort finds the largest item and places it at the end, then then next largest is found and placed next to last, continue until there is only one number left, this is the beginning of the sorted array",5.0,4.0,4.5,0.9999461655383715
894,5.2,"you loop through the entire list, and for each iteration you find the smallest element and move it to the current position.",5.0,5.0,5.0,0.9999754485818128
895,5.2,Find the minimum value in the list swap it with the value in the first position; repeat the steps above for remainder of the list(starting in the second position. ,5.0,5.0,5.0,0.9999686492547512
896,5.3,"The run time for this sorting program is n^2.  Best case is the list is already sorted, worst case is the list is sorted but in reverse. ",4.0,3.0,3.5,0.9999636113297903
897,5.3,"Insertion sort is O(n) and performs n-1 operations in the best-case scenario, which is when the list or array is already sorted.",5.0,4.0,4.5,0.999979724149309
898,5.3,"The number of operations for insertions sort, under best-case, is  n(n-1)/2. The best case for insertion sort is on a sorted list where it runs is O(n). ",3.0,3.0,3.0,0.9999713242402046
899,5.3,"Best case would be O(n) or n-1, because that's what it takes to scan the array and make one swap. The array would then be sorted and would take only 1 operation.",4.0,4.0,4.0,0.9999574509085727
900,5.3,Best case-1 Worst Case-N,0.0,4.0,2.0,0.9997072821942584
901,5.3,It will do (n) operations where (n) is the number of elements in the array. Best case is when all the elements are already sorted.,5.0,5.0,5.0,0.9999781575726587
902,5.3,O(n),3.0,4.0,3.5,0.9998827540852533
903,5.3,Best case is all elements sorted. n-1.,5.0,3.0,4.0,0.9999284084611886
904,5.3,"The best case scenario for an insertion sort, where all the elements of the array have been already sorted, will cause the for loop to iterate ""x"" times (""x"" being the number of elements in the array) and the while loop to never have to iterate, resulting in the insertion sort to require ""x"" operations. ",5.0,5.0,5.0,0.9999689929180864
905,5.3,1 operation. the best case scenario s where it is already sorted and does one comparision.,3.0,3.0,3.0,0.9999645786682358
906,5.3,"n operations, where n is the number of items.",3.0,5.0,4.0,0.9999442651375019
907,5.3,n-1,3.0,4.0,3.5,0.9995353932474931
908,5.3,"O(n), the list is already sorted.",5.0,4.0,4.5,0.9999803812114054
909,5.3,Insertion sort will take n-1 operations if the array is in reverse order.,4.0,4.0,4.0,0.99997667299432
910,5.3,"In the best case scenario of an already sorted list, insertion sort will progress once through the list.  So the number of operations is directly proportional to the number of elements in the list.  Also noted as O(n) in big o notation. ",5.0,5.0,5.0,0.9999707060523932
911,5.3,1 where there is a list of two ints and only one must be moved.,2.0,3.0,2.5,0.9999162355107781
912,5.3,"Best case is N, while the worst case is N factorial.",2.0,4.0,3.0,0.9999541199656089
913,5.3,n-1 The best case is when the array is already sorted.,5.0,4.0,4.5,0.9999597416088654
914,5.3,worst case its = O(n) time best case its = O(n^2) time,2.0,4.0,3.0,0.9999548082359146
915,5.3,O(n),3.0,4.0,3.5,0.9998827540852533
916,5.3,N number of times.  Where N equals the number of elements in the list.  Best-case scenario is that the elements in the list are already sorted.,5.0,5.0,5.0,0.9999370347299152
917,5.3,the best case scenario for insertion sort is a list that is already sorted. the number of operations would be the same as the number of elements,5.0,5.0,5.0,0.9999532930223937
918,5.3,"insertion sort will make zero operations (and length - 1 comparisons) in the best case scenario, that is, when the array its given is already in order.",3.0,4.0,3.5,0.9999646358710729
919,5.3,theta(n) the best case senario is that everything is already sorted,5.0,4.0,4.5,0.9999501285098321
920,5.3,n operations  The best case scenario is when all the numbers are in increasing order.,5.0,5.0,5.0,0.9999424326031935
921,5.3,"it could be considered that having only one item would be the easiest to sort, but this could also be a trivial result as nothing is moved  having two items allows the algorithm to sort the items into the correct order",2.0,3.0,2.5,0.9999323437054971
922,5.3,the best case is if it only has to look through the list once. The best case scenario is when it goes through the list and doesn't have to make any changes (the list is already sorted),5.0,3.0,4.0,0.999926769413075
923,5.3,very simplistic it moves one element from the list by one and inserting them in their correct position into a new slot then starting over. best case is (0)1 ,2.0,3.0,2.5,0.9999519068683761
924,5.4,"The base case for a recursive merge sort is one number.  One number by itself is a sorted list, regardless of what number it is.",5.0,5.0,5.0,0.9999709693983995
925,5.4,The base case for a recursive implementation of merge sort is when the sequence being passed to merge sort has less than 2 elements.,5.0,5.0,5.0,0.9999658294719462
926,5.4,The base case for a recursive implementation of merge sort is one.,5.0,5.0,5.0,0.9999624597638161
927,5.4,The best case is the same as the worst case O(n log n) for a recursive merge sort.,1.0,3.0,2.0,0.9999609431867562
928,5.4,there is one object in the split array to sort.,5.0,5.0,5.0,0.9999138164397943
929,5.4,The base case is when the length of the current array is 1.,5.0,5.0,5.0,0.9999696206434718
930,5.4,O(nlog(n)),1.0,4.0,2.5,0.9998032311265834
931,5.4,Best case is one element.  One element is sorted.,5.0,5.0,5.0,0.9999506403669018
932,5.4,If the array being sorted has 0 or 1 elements,5.0,4.0,4.5,0.9999718421036734
933,5.4,"T(n) = 0, if n&lt;2.",4.0,4.0,4.0,0.9999254063906522
934,5.4,"A list size of 1, where it is already sorted.",5.0,5.0,5.0,0.9999682510816184
935,5.4,Single element in the array,5.0,5.0,5.0,0.999924681032462
936,5.4,O(nlog(n)),1.0,3.0,2.0,0.9998032311265834
937,5.4,n * log( n ),1.0,3.0,2.0,0.9999239434508406
938,5.4,A list or array of only 1 element.,5.0,5.0,5.0,0.9999333384487261
939,5.4,where you only must merge sort once,3.0,4.0,3.5,0.9999466617090982
940,5.4,A single Element on the Array.,5.0,5.0,5.0,0.999920902638143
941,5.4,There is only one element in the subarray.,5.0,5.0,5.0,0.999968343715621
942,5.4,"if the array length is less than or equal to 1, then that array is returned to the other array and merged together",5.0,4.0,4.5,0.9999620446926151
943,5.4,"if (right &gt; left)   {     mid = (right + left) / 2;     m_sort(numbers, temp, left, mid);     m_sort(numbers, temp, mid+1, right);      merge(numbers, temp, left, mid+1, right);   } ",2.0,2.0,2.0,0.9997932062677635
944,5.4,The sequence of numbers has zero or one elements.,5.0,5.0,5.0,0.9999672388259894
945,5.4,one element in an array,5.0,5.0,5.0,0.9998416184711305
946,5.4,array of length 1,5.0,5.0,5.0,0.9998724628236922
947,5.4,the array has one element,5.0,5.0,5.0,0.9999015182721344
948,5.4,"When there is only one element in the array, or when the starting element in the array is the same as the ending element.",4.0,5.0,4.5,0.9998320181060861
949,5.4,"when each half or the original array has nothing else to sort, and puts the halfs back together",2.0,3.0,2.5,0.9999610509791089
950,5.4,the size of the list being sent is &lt;= 1,5.0,4.0,4.5,0.9999464889959323
951,5.4,O(n log n),1.0,3.0,2.0,0.9999065454046927
952,6.1,Its a location in memory that contains the memory address of another location in memory that contains information.,5.0,5.0,5.0,0.9999839670838061
953,6.1,A pointer is a variable that contains a memory address as its value.,5.0,5.0,5.0,0.999978113283412
954,6.1,A pointer is a variable which stores the address of another variable.,5.0,5.0,5.0,0.9999542599211264
955,6.1,Pointers are variables that contain as their values memory addresses of other variables.,5.0,5.0,5.0,0.9999479112395604
956,6.1,A data type whose value refers to another value stored elsewhere in the computer memory using its address.,4.0,5.0,4.5,0.9999825851626439
957,6.1,a pointer holds a memory location,5.0,4.0,4.5,0.9999573749450217
958,6.1,a name that represents actual location or value of a data type. int *bPtr points to an integer value.,5.0,4.0,4.5,0.9999841893844217
959,6.1,A variable that stores the address of another variable,5.0,5.0,5.0,0.9999784068667762
960,6.1,a pointer is a programming language data type whose value refers directly to (or points to) another value stored elsewhere in the computer memory using its address,5.0,5.0,5.0,0.9999804643080916
961,6.1,A data type whose value refers to another value stored somewhere else in the computer memory using its address.,5.0,5.0,5.0,0.9999813625345308
962,6.1,"It is like a variable however instead of holding data, it holds a location in memory.",4.0,5.0,4.5,0.9999678280477384
963,6.1,A pointer is a reference to a location in memory,5.0,5.0,5.0,0.9999469689136173
964,6.1,A pointer is a reference to the memory location of an object.,4.0,5.0,4.5,0.999951139131092
965,6.1,A pointer is a variable that contains the memory address of a variable that has a value.,5.0,5.0,5.0,0.9999861056876128
966,6.1,"It is a variable that contains not only a *value but has a memory address associated with it, and can be moved along a string or an array by jumping up one memory address.",2.0,5.0,3.5,0.99997685225606
967,6.1,Contains a variable's memory address as a value.,5.0,5.0,5.0,0.9999403480891983
968,6.1,variable that points to the memory address of another variable and it is type specific.,5.0,5.0,5.0,0.9999493181004631
969,6.1,An element that references a memory cell,5.0,5.0,5.0,0.9999637075350568
970,6.1,Is a reference call to the place in memory where the object is stored.,4.0,4.0,4.0,0.9999645249006504
971,6.1,a variable that contains the address of another variable,5.0,5.0,5.0,0.9999916895831439
972,6.1,"A pointer variable contains the number of a memory address as its value, which may be null or 0, or the address of some value stored in memory.",5.0,5.0,5.0,0.9999609578534777
973,6.1,A pointer is a variable that contains a memory address of anther variable,5.0,5.0,5.0,0.999977449002757
974,6.1,A variable that contains the memory address of another variable that contains a specific value.,5.0,5.0,5.0,0.9999945506637812
975,6.1,a variable with a memory address as the value,5.0,4.0,4.5,0.9999457783849957
976,6.1,it is a type that points to something else. It is the memory address of something else,5.0,4.0,4.5,0.9999612167285311
977,6.1,A pointer is a way to get at another object. Essentially it is a way to grab an instance of an object and then either pass that instance a message or retreive some data from that object. A pointer is actually just an address of where an instance is held in memory. ,4.0,5.0,4.5,0.9999542455021406
978,6.2,This operator returns the memory address of its operand.,5.0,5.0,5.0,0.9999831257443238
979,6.2,The address operator returns the memory address of its operand.,5.0,5.0,5.0,0.9999885271187146
980,6.2,Returns memory address of its operand.,5.0,5.0,5.0,0.9999911697096245
981,6.2,The address (&) operator returns the memory address of its operand.,5.0,5.0,5.0,0.9999884946896935
982,6.2,Returns the memory address of its operand.,5.0,5.0,5.0,0.9999815464262171
983,6.2,returns the place in memory of that element,5.0,3.0,4.0,0.9999269595278136
984,6.2,The address of the where the data is stored: &b will return the address of b.,4.0,5.0,4.5,0.9999538862595345
985,6.2,The & operator returns the address of a variable,5.0,5.0,5.0,0.9999576743153951
986,6.2,"the ampersand (&) means ""pass by reference"". When the function is called, a pointer to the variable, instead of the variable itself, will be passed into the function.",3.0,3.0,3.0,0.999949829883316
987,6.2,& returns the memory address of its operand.,5.0,5.0,5.0,0.9999806477986368
988,6.2,the address of the variable in memory,5.0,5.0,5.0,0.9999395433244367
989,6.2,Returns the address location in memory of the item.,5.0,4.0,4.5,0.9999392360085829
990,6.2,The address operator returns the memory address of its operand.,5.0,5.0,5.0,0.9999885271187146
991,6.2,The & operator returns the memory address of the variable it precedes.,5.0,5.0,5.0,0.9999854384645931
992,6.2,"The memory address of operand, 0x000000 or something along those lines. ",4.0,5.0,4.5,0.9999626957954991
993,6.2,The object's memory address.,4.0,5.0,4.5,0.9998341955118198
994,6.2,the reference to a variable,5.0,4.0,4.5,0.9999113078656715
995,6.2,returns the memory address of its operand,5.0,5.0,5.0,0.9999771033233085
996,6.2,memory address of its operand,5.0,5.0,5.0,0.9999830129551274
997,6.2,returns the address number of the specified variable,5.0,4.0,4.5,0.999948898579376
998,6.2,"It returns the memory address of it's operand. That is, if applied to a normal variable, it gives the variable's memory address, just as a pointer variable might.",4.0,5.0,4.5,0.9999569368267922
999,6.2,The & is a unary operator that returns the memory address of its operand,5.0,5.0,5.0,0.9999727121018742
1000,6.2,the address of the variable it is attached to,5.0,3.0,4.0,0.9999544383201847
1001,6.2,the memory address of its operand,5.0,5.0,5.0,0.9999806236676136
1002,6.2,returns the address of what it is put in front of,5.0,4.0,4.5,0.9999044555618768
1003,6.2,returns a pointer,4.0,3.0,3.5,0.9999011466723403
1004,6.3,returns a synonym for the object to which its pointer operand points.,5.0,5.0,5.0,0.9999885249552736
1005,6.3,The star operator returns a synonym for the object to which its pointer operand points.,5.0,5.0,5.0,0.9999881991265642
1006,6.3,Returns synonym for the object its operand points to.,5.0,5.0,5.0,0.9999875428603998
1007,6.3,"It returns a synonym, alias or nickname of the name of the object that its operand points to in memory (dereferencing the pointer).",5.0,5.0,5.0,0.9999943094991787
1008,6.3,Returns an alias/nickname for the object to which the pointer operand points.,5.0,5.0,5.0,0.9999888476453586
1009,6.3,the * operator returns the value in the memory address the element points to.,4.0,4.0,4.0,0.9999578941195657
1010,6.3,The * returns the value,4.0,4.0,4.0,0.9999477447021659
1011,6.3,The * operator returns the dereferenced pointer variable (ie: it returns the value of whatever variable the pointer is pointing to),5.0,5.0,5.0,0.9999680562280899
1012,6.3,The dereferencing operator returns the dereferenced object.,4.0,5.0,4.5,0.9999472554076241
1013,6.3,* returns the synonym for the object its operand points to.,5.0,5.0,5.0,0.99998081837822
1014,6.3,it returns the information in the address the pointer points to.,4.0,4.0,4.0,0.9999600113256591
1015,6.3,the star operator returns the value at the memory address the pointer is pointing at.,5.0,4.0,4.5,0.9999568258746293
1016,6.3,The star operator returns the object at that memory location.,4.0,4.0,4.0,0.9999681832364176
1017,6.3,The * operator returns the value of the object's memory address it precedes.,4.0,3.0,3.5,0.9999748986563526
1018,6.3,The value of the object that the operand points to,4.0,5.0,4.5,0.999957415528426
1019,6.3,The value stored in the object being pointed to.,4.0,4.0,4.0,0.999979868403225
1020,6.3,the value of the variable the pointer points to.,4.0,4.0,4.0,0.9998810496511248
1021,6.3,returns synonym for the object its operand points to,5.0,5.0,5.0,0.9999780322751011
1022,6.3,synonym for the object its operand points to,5.0,5.0,5.0,0.9999793062077127
1023,6.3,Returns synonym for the object its operand points to,5.0,5.0,5.0,0.9999853861169633
1024,6.3,"It dereferences a pointer, meaning it returns the value stored in the memory address a pointer refers to.",4.0,5.0,4.5,0.9999813250948895
1025,6.3,It is unary operator that returns the value of the variable located at the address,4.0,4.0,4.0,0.9999806522377023
1026,6.3,a reference to a = variable,1.0,3.0,2.0,0.9999354921186203
1027,6.3,a synonym for the object to which its pointer operand points,5.0,5.0,5.0,0.9999877703523126
1028,6.3,it returns the actual data at the address pointed to,4.0,3.0,3.5,0.9999745209194528
1029,6.3,will return zero or many characters placed before the operator ,1.0,3.0,2.0,0.9999605547400783
1030,6.4,The array itself can be signed to a pointer or each element of the array can be assigned to a pointer.,2.0,4.0,3.0,0.9999745937178132
1031,6.4,An array can be addressed in pointer/offset notation by setting a pointer variable equal to the variable name of the array. Elements of the array can then be accessed by adding an offset value to the pointer variable.,5.0,4.0,4.5,0.999977318670245
1032,6.4,Element b[ n ] can be accessed by  *( bPtr + n ).,5.0,3.0,4.0,0.9998846080170589
1033,6.4,Using either the name of the array as a pointer or using a separate pointer that points to the array.,3.0,3.0,3.0,0.9999762371060197
1034,6.4,An element b[3] can be referenced by using *( bPtr + 3) instead.,5.0,3.0,4.0,0.9999104348790343
1035,6.4,you get the memory location of the first element and the you add an offset to it to get other elements.,5.0,5.0,5.0,0.9999090355096594
1036,6.4,yes *(array +offset),5.0,3.0,4.0,0.9999122832312871
1037,6.4,"The name of an array is considered to be a pointer in C++, and can be passed as such in functions parameters. Declaring int a[10]; creates a pointer ""a"" which stores the address of a[0].",3.0,4.0,3.5,0.9999470569292417
1038,6.4,Element b[ n ] can be accessed by  *( bPtr + n ) is an example of how an array can be addressed as pointer/offset notation. ,5.0,4.0,4.5,0.9999305455341966
1039,6.4,*(array + element),5.0,3.0,4.0,0.9998950247546372
1040,6.4,*f[3],2.0,3.0,2.5,0.9997152428406777
1041,6.4,you can have a pointer to the front of the array and add to the memory location (or offset from the initial value).,5.0,5.0,5.0,0.9999366333711076
1042,6.4,"The pointer to the array will initially point to the first element of that array.  When the pointer is incremented, it will point to the next element, and so on.",2.0,5.0,3.5,0.9999799122716081
1043,6.4,With int x[10]; int *xPtr; xPtr = x; Address &x[1] is the same as xPtr + 1.,5.0,3.0,4.0,0.9999060740349219
1044,6.4,Takes the number of array elements and points to each at a time,1.0,3.0,2.0,0.9999651552372216
1045,6.4,The array can act as a pointer or be referenced by a pointer.  *(arrayPtr + 3) or *(array + 3),5.0,3.0,4.0,0.9999470486476311
1046,6.4,by using the *(pointer + element-index),5.0,3.0,4.0,0.9999539357113917
1047,6.4,using the star operator.   array: b[n] can be accessed by *(bpointer +n),5.0,4.0,4.5,0.99993919549144
1048,6.4,Element A[n] can be accessed by *(APtr + n),5.0,3.0,4.0,0.9998876534046144
1049,6.4,"by referencing a pointer and referring to other pointers relative to the first pointer(pointer+1, pointer +2, etc)",2.0,4.0,3.0,0.9999671711434148
1050,6.4,"First, some pointer variable must reference the first entity in the array. Any variable in the array can then be accessed by referring to that first entity's address plus some offset. i.e. ptrToArray = array;  nthEntity = *(ptrToArray + n);",5.0,5.0,5.0,0.9999720078202716
1051,6.4,&[b3] is as bptr + 3. Array can be treated as pointer,4.0,3.0,3.5,0.9998951925597468
1052,6.4,a[i] = *(a+i),5.0,3.0,4.0,0.9999189443968357
1053,6.4,&b[3]  bPtr + 3,5.0,3.0,4.0,0.9998807254634164
1054,6.4,*(arrayName + index),5.0,3.0,4.0,0.9998866404164829
1055,6.4,multi-dimensional array,0.0,2.0,1.0,0.9997349111145892
1056,6.5,the number of bytes of an array during program compilation.,4.0,5.0,4.5,0.9999457943331451
1057,6.5,The sizeof operator returns the size of the operand.,5.0,3.0,4.0,0.9999138702096063
1058,6.5,Returns size of operand in bytes.,5.0,5.0,5.0,0.9999822074855006
1059,6.5,It returns the size of an array in bytes.,4.0,5.0,4.5,0.9999643228028489
1060,6.5,Returns the size of the array in bytes during the program compilation.,4.0,5.0,4.5,0.9999348202938335
1061,6.5,it returns the size of the argument passed in,5.0,3.0,4.0,0.9999137595518487
1062,6.5,The byte size of the date stored ina variable.,4.0,5.0,4.5,0.9999818017259791
1063,6.5,sizeof returns the size of the operand in bytes,5.0,5.0,5.0,0.9999008143340617
1064,6.5,"The amount of memory required for a specific parameter such as ints, doubles.",4.0,3.0,3.5,0.9999743443191639
1065,6.5,sizeof returns the size of the operand in bytes.,5.0,5.0,5.0,0.999909064328203
1066,6.5,the size of the information in bits.,1.0,4.0,2.5,0.9999189851533807
1067,6.5,the size of the string.,3.0,3.0,3.0,0.9999403034751091
1068,6.5,sizeof returns the size in bytes of the respective object.,4.0,5.0,4.5,0.9999658185517637
1069,6.5,The sizeof operator returns the total number of bytes of its operand.,5.0,5.0,5.0,0.9999631100579969
1070,6.5,"The size of an operand in bytes. Used with variable names, type names, and constant values",5.0,5.0,5.0,0.9999758370986059
1071,6.5,the size in bytes needed to store the object in memory,4.0,5.0,4.5,0.9999057259480765
1072,6.5,the size of the list object.,4.0,2.0,3.0,0.9999309449535171
1073,6.5,the sizeof operator returns the size in bytes of an array parameter,3.0,5.0,4.0,0.999970613483527
1074,6.5,the size of operand in bytes,5.0,5.0,5.0,0.9999829088576943
1075,6.5,returns the size in bytes of the specified data,4.0,5.0,4.5,0.9999496486504709
1076,6.5,"It returns the size of an operand in memory, which is checked at compiler-time.",5.0,3.0,4.0,0.9999538927882566
1077,6.5,Return size of operand in bytes,5.0,5.0,5.0,0.999977944601278
1078,6.5,the total number of bytes of an object.,4.0,5.0,4.5,0.9998815683849358
1079,6.5,total number of bytes in the array,4.0,5.0,4.5,0.9999258548422785
1080,6.5,it returns the size in bytes of a certain variable type,4.0,5.0,4.5,0.9999725400893396
1081,6.5,"it yields the size in bytes of the operand, which can be an expression or the parenthesized name of a type",3.0,5.0,4.0,0.9999614965170621
1082,6.6,They can be passed by value or by reference,2.0,3.0,2.5,0.9998937634667058
1083,6.6,"Nonconstant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to nonconstant data, constant pointer to constant data.",5.0,5.0,5.0,0.9999834872957457
1084,6.6,-Nonconstant pointer to nonconstant data       -Nonconstant pointer to constant data        -Constant pointer to nonconstant data         -Constant pointer to constant data,5.0,5.0,5.0,0.9999216733503996
1085,6.6,"Four different ways: Nonconstant pointer to nonconstant data, a nonconstant pointer to constant data, a constant pointer to nonconstant data and a constant pointer to constant data.",5.0,5.0,5.0,0.9999910666024024
1086,6.6,Pass-by-value or pass-by-reference.,2.0,3.0,2.5,0.9999459498388489
1087,6.6,you can pass a pointer to a pointer or pass a reference to pointer.,2.0,3.0,2.5,0.9998614845021614
1088,6.6,by address &bPtr or directly bPtr.,2.0,3.0,2.5,0.9999591555548225
1089,6.6,"Nonconstant pointer to nonconstant data, constant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to constant data. ",5.0,5.0,5.0,0.9999834872957457
1090,6.6,By argument and reference.,1.0,3.0,2.0,0.9998149240553988
1091,6.6,"Nonconstant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to nonconstant data, and constant pointer to constant data.",5.0,5.0,5.0,0.9999863571501858
1092,6.6,pass by value and pass by reference with reference or pointer arguments.,2.0,3.0,2.5,0.9999075943570358
1093,6.6,you can pass them with the pointer (*) or the memory address (&),2.0,3.0,2.5,0.9998928079709698
1094,6.6,nonconst -&gt; nonconst const -&gt; nonconst nonconst -&gt; const const -&gt; const,5.0,5.0,5.0,0.9996762557599235
1095,6.6,Nonconstant pointer to nonconstant data Constant pointer to nonconstant data Nonconstant pointer to constant data Constant point to constant data,5.0,5.0,5.0,0.9999682525421918
1096,6.6,"Non-constant pointer to non-constant data, non-constant pointer to constant data, constant pointer to constant data, constant pointer to non-constant data.",5.0,5.0,5.0,0.9999834872957457
1097,6.6,Pass by reference with reference arguments. function(int &)  Pass by reference with pointer arguments. function(int *),2.0,3.0,2.5,0.9998482204745557
1098,6.6,you can pass the reference or the dereference in a function,2.0,2.0,2.0,0.9999165257695588
1099,6.6,1. nonconstant pointer to nonconstant data. Its delcaration does no include  const qualifier. 2. nonconstant pointer to constant data. Provides the performance of pass-by-reference and the protection of pass-by-value 3. Constant pointer to nonconstant data.  4. Constant pointer to constant date.,5.0,5.0,5.0,0.9999613186363058
1100,6.6,"constant pointer to constant data, constant pointer to nonconstant data, nonconstant pointer to constant data, nonconstant pointer to nonconstant data",5.0,5.0,5.0,0.9999796882660427
1101,6.6,Nonconstant pointer to nonconstant data Nonconstant pointer to constant data Constant pointer to nonconstant data Constant pointer to constant data,5.0,5.0,5.0,0.9999216733503996
1102,6.6,"Pointers may be passed to functions by value, by reference with reference arguments, or by reference with pointer arguments.",2.0,3.0,2.5,0.9999685110558145
1103,6.6,There are four way to pass pointer to a function 1. non constant pointer to non constant data 2.non constant pointer to  constant data. 3. constant pointer to non constant data. 4. constant pointer to  constant data.,5.0,5.0,5.0,0.9999132737753179
1104,6.6,nonconstant pointer to nonconstant data nonconstant pointer to constant data constant pointer to nonconstant data constant pointer to constant data,5.0,5.0,5.0,0.9999216733503996
1105,6.6,"pass by value, pass by reference with reference arguments, pass by reference with pointer arguments",2.0,3.0,2.5,0.9999130321818683
1106,6.6,"you can pass it where either the pointer cant be moved, the data pointed to cant be changed, or both or neither",5.0,3.0,4.0,0.9999386149724727
1107,6.6,"there are only two ways to pass something, by value and by reference. Use of dot or pointer operators within the receiving function and use of '&' operator inside the passing function",2.0,3.0,2.5,0.9999510130022
1108,6.7,A pointer that points to the memory address of the beginning part of a functions.  pretty much the pointer points to the function so it can be called to execute.,5.0,5.0,5.0,0.9999486777233916
1109,6.7,A function pointer is a pointer that contains the address of the  function in memory.,5.0,5.0,5.0,0.9999576115701474
1110,6.7,"Function Pointers are pointers, i.e. variables, which point to the address of a function.",5.0,5.0,5.0,0.9999181869879004
1111,6.7,"A pointer to a function is the address where the code for the function resides. They can be passed to functions, returned from functions, stored in arrays and assigned to other pointers.",5.0,5.0,5.0,0.9999457505721455
1112,6.7,It contains the address of the function in memory.,5.0,5.0,5.0,0.9999695766038427
1113,6.7,when it is dereferenced a function pointer calls its function with zero or more arguments.,4.0,3.0,3.5,0.9999285736670094
1114,6.7,a pointer to a function,5.0,2.0,3.5,0.999782029016707
1115,6.7,"A pointer to a function itself, contains the address of the function and can be used to call that function",5.0,5.0,5.0,0.9999414132179882
1116,6.7,"Function Pointers are pointers, i.e. variables, which point to the address of a function.",5.0,5.0,5.0,0.9999181869879004
1117,6.7,A pointer to a function that contains the addresses of the function.,5.0,5.0,5.0,0.9999097403440931
1118,6.7,a pointer that contains the address of a function,5.0,5.0,5.0,0.999920890689659
1119,6.7,a function pointer is a pointer to a function. It can be used in substitution for calling a function.,5.0,5.0,5.0,0.9999115948241964
1120,6.7,Points to the memory address of a function.  Kind of like breaking a branch off of a tree object and hitting other objects with it.,5.0,5.0,5.0,0.9999629728631958
1121,6.7,"They are pointers that contain the addresses to functions, they can be passed and returned from functions, as well as stored in arrays and assigned to other function pointers.",5.0,5.0,5.0,0.9998984573781007
1122,6.7,Pointer variables that point to function addresses.,5.0,5.0,5.0,0.9999389744428389
1123,6.7,Contains the address of the function in memory.,5.0,5.0,5.0,0.9999711721179595
1124,6.7,"a pointer that points to a function itself, which allows passing a function as a parameter to another function.",5.0,3.0,4.0,0.9999090021731122
1125,6.7,pointers that contain the addresses of functions.,5.0,5.0,5.0,0.9999198289376581
1126,6.7,is a pointer that contains the address of a function,5.0,5.0,5.0,0.999910951562999
1127,6.7,a pointer that contains the address of the function definition,4.0,5.0,4.5,0.9999383231033651
1128,6.7,"A function pointer contains the memory address of a function. Using a function pointer, a function can be passed to or returned by another function. Function pointers can also be stored in arrays.",5.0,5.0,5.0,0.9999420179380585
1129,6.7,Function pointer is a pointer to a function. function pointer contains address of functions,5.0,5.0,5.0,0.99992391794303
1130,6.7,a pointer that contains the address of a function in memory.,5.0,5.0,5.0,0.9999409685227392
1131,6.7,it contains the address of the function in memory,5.0,5.0,5.0,0.9999669223573942
1132,6.7,it is a pointer that points to the address of a function. ,5.0,5.0,5.0,0.999925505286669
1133,6.7,"When dereferenced, a function pointer invokes a function, passing it zero or more arguments just like a normal function. In programming languages like C, function pointers can be used to simplify code, such as replacing large switch statements.",4.0,4.0,4.0,0.9999241787790265
1134,7.1,"Consists of sequence of nodes, each containing a number of data fields and one or two links called pointers that point to the next or previous nodes. ",4.0,5.0,4.5,0.9998912580732572
1135,7.1,A linked list is a list in which each item in the list points to the next item in the list.,4.0,5.0,4.5,0.9998363004982567
1136,7.1,"A linked list is a chain of structs or records called nodes and you have the ability to add, delete, or retrieve items. ",4.0,5.0,4.5,0.9999495568782749
1137,7.1,"A list of elements, or nodes, that are linked to one another such that each element points to the next element.",4.0,5.0,4.5,0.9998887892890426
1138,7.1,"A sequence of nodes, each containing data fields (specified by programmer) and pointer(s) which can point to the next or previous nodes.",4.0,5.0,4.5,0.9999144680466286
1139,7.1,a list of nodes where each node contains a data member and also a pointer to the next node.,4.0,5.0,4.5,0.999902662235434
1140,7.1,A list of items linked together.  Each item is linked to its successor.,4.0,5.0,4.5,0.9999238997138558
1141,7.1,A linked list is a chain of nodes that each store a single piece of data and pointer variables that point to other nodes in the list.,4.0,5.0,4.5,0.9999461312324376
1142,7.1,"one of the fundamental data structures, and can be used to implement other data structures. It consists of a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes. ",4.0,5.0,4.5,0.9999686453491233
1143,7.1,"A data structure in a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes.",4.0,5.0,4.5,0.9999723908672279
1144,7.1,Information in memory linked to the next piece of information and can only be linked forwards and not backwards.,2.0,5.0,3.5,0.999945735468472
1145,7.1,"A linked list is a data structure that is not necessarily in the same contiguous memory space (such as arrays). It holds the data type and points to the next data item in the list, or in a doubly linked list also to the previous item.",5.0,5.0,5.0,0.9999425704128375
1146,7.1,A linked list is a data structure containing one or more data elements with a pointer to the next node.,4.0,5.0,4.5,0.9999237188268644
1147,7.1,"A series of ""Nodes"" structures with a value and a pointer that point to a similar ""Node"". Not quite an array, but still can carry a list of values. ",4.0,5.0,4.5,0.9998862927629499
1148,7.1,A data type that contains a pointer to at least the next  element in a list.,4.0,5.0,4.5,0.9999178987126986
1149,7.1,Each component contains a Node - a data item and a pointer to the next item in the list,4.0,5.0,4.5,0.999862050017184
1150,7.1,"A linked list is a chain of structs or records called nodes.  Each node has at least two members, one of which points to the next item or node in the list.",4.0,5.0,4.5,0.9999220084108655
1151,7.1,"An array based list that uses an implicit ordering scheme, often using pointers.",1.0,4.0,2.5,0.9999069967436687
1152,7.1,a series of structures containing data items and a pointer that links the structure to the next structure.,4.0,5.0,4.5,0.9999592785846155
1153,7.1,"A linked list is a collection of Objects each containing at least one data member, and a pointer to the next object in the list (and the previous object in the case of a doubly linked list)",4.0,5.0,4.5,0.9999235220879146
1154,7.1,A link list is a data structure which is built from structures and pointers. It forms a chain of nodes with pointers representing the links of the chain and holding the entire thing together,4.0,4.0,4.0,0.9999460985222387
1155,7.1,its a list of pointers that are linked 2 each other. every pointer points to the next pointer which has the next element,4.0,5.0,4.5,0.9998611058822184
1156,7.1,linear collection of self-referential nodes connected by pointers.,4.0,4.0,4.0,0.9999660116021666
1157,7.1,the items of a data structure are linked to each other using pointers,4.0,5.0,4.5,0.9999001592765985
1158,7.1,A list of objects where each object contains a link to the next item in the list,4.0,5.0,4.5,0.9998968886079941
1159,7.1,"A linked list is one of the fundamental data structures, and can be used to implement other data structures. It consists of a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes.  ",4.0,5.0,4.5,0.9999682401695215
1160,7.2,Elements can be inserted into a link list at any point and does not need to be resized unlike an array needs to be. ,5.0,5.0,5.0,0.9999194450065864
1161,7.2,"Unlike arrays, linked lists can insert and delete without shifting data and change in size easily.",5.0,5.0,5.0,0.999953645829335
1162,7.2,"Array size is fixed,but Linked is not fixed.",5.0,5.0,5.0,0.999943043839794
1163,7.2,You can insert into and delete items from a pointer-based linked list without shifting data.,5.0,4.0,4.5,0.9999426865410538
1164,7.2,Arrays must be of a defined size... elements can be added to a linked list w/o defining any size.,5.0,5.0,5.0,0.9999313557331805
1165,7.2,"The principal benefit of a linked list over a conventional array is that the order of the linked items may be different from the order that the data items are stored in memory or on disk, allowing the list of items to be traversed in a different order. A linked list is a self-referential datatype because it contains a pointer or link to another datum of the same type. Linked lists permit insertion and removal of nodes at any point in the list in constant time",3.0,5.0,4.0,0.9998982374726364
1166,7.2,You can expand when you need it.  You do not have to predetermine the size.,5.0,5.0,5.0,0.9999105365687961
1167,7.2,Linked lists are able to grow and shrink in size as needed,5.0,5.0,5.0,0.9999518327977531
1168,7.2,Linked list is able to grow in size as needed. Does not require the shifting of items during insertions and deletions ,5.0,5.0,5.0,0.9999155090685633
1169,7.2,"A linked list is not fixed in size, and does not require the shifting of items during insertions and deletions.",5.0,5.0,5.0,0.9999433590613743
1170,7.2,There is no limit as to how many you create where an array can only hold a given amount of information.,3.0,3.0,3.0,0.999951270595396
1171,7.2,Linked lists have constant time insertion and deletion,4.0,3.0,3.5,0.9998345515158428
1172,7.2,"Linked lists can be grown dynamically, items don't require shifting, and they have a greater awesome factor than that of arrays.",5.0,5.0,5.0,0.9999200245379468
1173,7.2,Linked lists have an indefinite size. They can be added to and taken away from very easily with little difficulty in the shifting of data.,5.0,5.0,5.0,0.9999108235704703
1174,7.2,"Nearly infinite size, limited only by system memory and also the ability to expand the size dynamically.",5.0,5.0,5.0,0.999912903854802
1175,7.2,"They grow as needed, while arrays are of fixed size.",5.0,5.0,5.0,0.9999508549007567
1176,7.2,Does not have a fixed size. Linked list is able to grow as needed. The time to access an array bases list takes a contant amount of time where as an linked-base like depends on 'i',5.0,5.0,5.0,0.9999337441197397
1177,7.2,Linked lists can grow and shrink as you need them to.  Arrays have a fixed size.,5.0,5.0,5.0,0.9999371317849726
1178,7.2,more memory can be allocated on the fly for more items,4.0,5.0,4.5,0.9999531957642991
1179,7.2,"A linked list may be increased in size as needed, while an array's size is set when it is created",5.0,5.0,5.0,0.9999713989847969
1180,7.2,"Array has a fixed size, but linked list is able to grow in size as needed",5.0,5.0,5.0,0.9999291680688658
1181,7.2,its resizeable,5.0,5.0,5.0,0.9996398228825337
1182,7.2,Linked lists do not have a set size and can grow or shrink as needed.,5.0,5.0,5.0,0.9999493120328633
1183,7.2,linked lists are abe to grow as needed to a new size ,5.0,5.0,5.0,0.9999112241889211
1184,7.2,"The size is not fixed, easier sorting because of no shifting, easier to insert items into the list",5.0,5.0,5.0,0.9999323929638579
1185,7.2,The size of array is restricted to declaration. Insertion/Deletion of values in middle of array is not possible.,5.0,5.0,5.0,0.9999090428225889
1186,7.3,Array can retrieve memory from any place in the list while in a link list you have to traverse through each individual node. ,5.0,5.0,5.0,0.9999458369346246
1187,7.3,"Arrays require less memory than linked lists and allow direct access to a specified item. Also, insertion and deletion in arrays does not require a list traversal.",4.0,5.0,4.5,0.9999611205109196
1188,7.3,"Access to a particular element is very fast, because its location in memory can be determined mathematically and accessed directly.",5.0,5.0,5.0,0.9999833926672856
1189,7.3,Arrays are good for random access and good for sequential access which are both in constant time. Where linked lists are linear for random access. Arrays are faster in this case.,5.0,5.0,5.0,0.9999543479233772
1190,7.3,"An array is capable of accessing any part of that array based on the index. The link list must be traversed from the beginning or the end, that is, data can only be accessed if it is adjacent to the previous or next nodes.",5.0,5.0,5.0,0.9999814314608354
1191,7.3,"On the other hand, arrays allow random access, while linked lists allow only sequential access to elements. Singly-linked lists, in fact, can only be traversed in one direction.",5.0,5.0,5.0,0.99997206776145
1192,7.3,You have to keep up with the head of the list.,1.0,3.0,2.0,0.9998972744860686
1193,7.3,Arrays are easier to implement and require less memory,3.0,4.0,3.5,0.999978994601135
1194,7.3,Linked list has an increase complexity of the implementation. The linked list has an array that keeps growing which leads to a increase in memory.,2.0,3.0,2.5,0.999988404635062
1195,7.3,You don't have to iterate through the entire list to access elements.,5.0,4.0,4.5,0.9999874518982175
1196,7.3,you can go forwards and backwards and point to any piece of data at any given time where linked lists have to point to the next piece of data.,2.0,4.0,3.0,0.999933302187936
1197,7.3,Take up less memory and are contiguously stored,4.0,4.0,4.0,0.9999516196489238
1198,7.3,"Arrays, being fixed, are less error prone.",1.0,3.0,2.0,0.9999095894752322
1199,7.3,"Arrays have a set list of values. Meaning you can pick a spot in the array such as a[7] picks the 8th spot in the array. With linked lists you have to keep track with pointers if you want to take specific nodes out, otherwise you must traverse the entire list. ",5.0,5.0,5.0,0.9999662021562465
1200,7.3,"direct access to elements, and speed, linked lists have increased search times to access elements even if the list is sorted. ( like getting the last element without a pointer directly to the end of the list. )",5.0,4.0,4.5,0.9999761549147779
1201,7.3,Array items are accessed directly with equal access time,5.0,5.0,5.0,0.9999818575185841
1202,7.3,Array-bases implementations require less memory than a pointer-bases one. ,3.0,4.0,3.5,0.9999639007824888
1203,7.3,You can access specific elements quickly in an array.  In a linked list you must traverse the list to get access the same element.,5.0,5.0,5.0,0.9999838681607022
1204,7.3,link lists only allow sequential access where arrays allow random access,5.0,4.0,4.5,0.9999554546836792
1205,7.3,"Any entitiy in an array may accessed immediately, whereas a linked list must be traversed one item at a time because each object only points adjacent objects",5.0,5.0,5.0,0.9999852175862628
1206,7.3,Array based implementation requires less memory than lined lists based implementation,3.0,4.0,3.5,0.9999604653197189
1207,7.3,Array-based implementations require less memory than a pointer-based ones ,3.0,4.0,3.5,0.9999681327468449
1208,7.3,"You can go up and down an array , but you can only go one direction while traversing a linked list.",1.0,5.0,3.0,0.9999559669881631
1209,7.3,"arrays allow for the random access of any item cotained a any time, linked lists must be gone through toget to the desired item",5.0,5.0,5.0,0.999962317324741
1210,7.3,"In arrays you have direct access to each element, but in linked lists you have to traverse the list up to the element that you need.",5.0,5.0,5.0,0.9999534287425309
1211,7.3,"Array size is fixed. But Linked is not fixed, data is also accessed quicker in array list, also memory requirement is less and no pointers required. Arrays have random access and less overheads compared to Linked list have sequential access only with too much overheads and no cache memory support. On the other hand, arrays allow random access, while linked lists allow only sequential access to elements. Singly-linked lists, in fact, can only be traversed in one direction.",5.0,5.0,5.0,0.9999728167168963
1212,7.4,They are passed by reference because you want the function to change the pointer ,4.0,5.0,4.5,0.9999650179802042
1213,7.4,Linked lists are passed as arguments to a function by passing the head pointer of the list by reference.,5.0,5.0,5.0,0.9996999480506708
1214,7.4,- A function with access to a linked list's head pointer has access to the entire list.        - Pass the head ponter to a function as a reference argument.,5.0,5.0,5.0,0.9997617537616723
1215,7.4,By using a node.,2.0,3.0,2.5,0.9998877638265524
1216,7.4,Pass-by-reference,5.0,5.0,5.0,0.9991519043515791
1217,7.4,you send a pointer to an object of the LinkedList class,2.0,3.0,2.5,0.9996810609656669
1218,7.4,Passed as a pointer to the head.,5.0,3.0,4.0,0.9997055869361295
1219,7.4,Passing the head pointer of a linked list to a function gives that function access to all nodes of that linked list,5.0,4.0,4.5,0.999634570458694
1220,7.4,You have to pass the head pointer to a function since it has access to the entire list.,5.0,3.0,4.0,0.9996926182851036
1221,7.4,You pass the head pointer to a function as a reference argument.,5.0,5.0,5.0,0.9997771743459275
1222,7.4,not answered,0.0,0.0,0.0,0.9995603538385917
1223,7.4,passes a pointer to a linked list object,2.0,3.0,2.5,0.9997662392901019
1224,7.4,"The linked list object contains the head, through which the other elements are accessible.",4.0,3.0,3.5,0.9997682342831106
1225,7.4,By the head of the list. It takes the head address and traverses from there on in. ,5.0,3.0,4.0,0.9996914767022859
1226,7.4,as a pointer node.,3.0,3.0,3.0,0.9998202200765882
1227,7.4,A method with access to a linked list's head pointer as access to the entire list,5.0,3.0,4.0,0.9997442773370158
1228,7.4,A function with access to a linked list's head pointer has access to the entire list. Pass the head pointer to a function as a reference argument,5.0,5.0,5.0,0.9997525421804715
1229,7.4,the head pointer is passed to a function as a reference argument.,5.0,5.0,5.0,0.9997951960491241
1230,7.4,the pointer to the first element is passed to a function,5.0,3.0,4.0,0.9997273846968961
1231,7.4,"linked lists are passed by reference, specificly the Head pointer",5.0,5.0,5.0,0.9998088742913497
1232,7.4,Pass the head pointer to a function as a reference argument,5.0,5.0,5.0,0.9997846984550766
1233,7.4,by refrenece,5.0,5.0,5.0,0.9994828489026171
1234,7.4,By passing the head pointer and going through the list as needed inside the function.,5.0,3.0,4.0,0.9996069356079003
1235,7.4,linked lists are passed by using pointers ,3.0,3.0,3.0,0.9997764094962668
1236,7.4,the head object is passed to the function,4.0,3.0,3.5,0.9997523995318738
1237,7.4,"Linked lists permit insertion and removal of nodes at any point in the list in constant time,[1] but do not allow random access. ",0.0,3.0,1.5,0.9996994307747729
1238,7.5,They are passed by reference because you want the function to change the pointer ,0.0,1.0,0.5,0.9999650179802042
1239,7.5,"In a circular linked list, every node has a successor which means that the last node's successor is the head or first node.",5.0,5.0,5.0,0.9999774757581185
1240,7.5,A circular linked list is a linked list that links items in a continuous circle. This allows the full list to be traversed by starting at any item in the list; a fixed head or tail is not required. ,5.0,4.0,4.5,0.9999779686401891
1241,7.5,"In a circular linked list, the last node points to the first node.",5.0,5.0,5.0,0.9999797027028811
1242,7.5,"On a circular linked list, the end element points to the head, thus making the circle. A basic link list has nothing pointing to the head, and the last element points to null.",5.0,5.0,5.0,0.9999687951028035
1243,7.5,the circular linked list's last node points to the begining of the list while a standard linked list points to NULL,5.0,5.0,5.0,0.9999799224679983
1244,7.5,The last item in the list points to the head,5.0,5.0,5.0,0.9999758030688537
1245,7.5,"In a circular linked list, the last node points back to the first node, there is no NULL",5.0,5.0,5.0,0.9999696690937012
1246,7.5,"Circular linked lists are most useful for describing naturally circular structures, and have the advantage of regular structure and being able to traverse the list starting at any point.",2.0,3.0,2.5,0.999947557376981
1247,7.5,A circular linked list has the last node point back to the head of the linked list.,5.0,5.0,5.0,0.9999759270333185
1248,7.5,Basic linked list points to a NULL at the end and circular points to the head at the end.,5.0,5.0,5.0,0.9999742311327846
1249,7.5,in a circular linked list the the last item points to the first item.,5.0,5.0,5.0,0.9999868584920792
1250,7.5,"The circular linked list's tail points to the head, whereas the basic linked list's tail points to a NULL.",5.0,5.0,5.0,0.9999552245221728
1251,7.5,a basic linked list has an end with a null value where a circular linked list has a pointer from the end to the beginning,5.0,5.0,5.0,0.9999263667984252
1252,7.5,"how to determine the end of the list, in basic linked lists the last element links to a null pointer, while circular linked lists link to the head element at the end.",5.0,5.0,5.0,0.999963171006529
1253,7.5,"No Node in a circular linked list contains NULL, the last Node points pack to a Node within the list.",5.0,5.0,5.0,0.9999507738198052
1254,7.5,"The difference between a circular linked list and a basic linked list is that a circular linked list, the last node references the first node. Every node in a circular linked list has a successor and no node in a circular linked list contains NULL.",5.0,5.0,5.0,0.9999684440764274
1255,7.5,No node in a circular linked list contains NULL.,3.0,4.0,3.5,0.9999615511042278
1256,7.5,in a circular linked list the last element points to the head of the list,5.0,5.0,5.0,0.9999941398126281
1257,7.5,"In a regular linked list the last object points to NULL. In a circular linked list, the last object points back to the beginning of the list",5.0,5.0,5.0,0.9999806116465598
1258,7.5,"In circular linked list each node has successor, no node contains NULL, while in basic linked list last node contain NULL.",3.0,3.0,3.0,0.9999609435231087
1259,7.5,"in a circular linked lists, the last element points to the first",5.0,5.0,5.0,0.9999783359123847
1260,7.5,"A circular linked list does not have a last element. Instead, it's last item points to the head of the list.",5.0,5.0,5.0,0.9999593405947512
1261,7.5,"in a circular linked list, the last node contains a pointer that goes back to the first node; in a basic linked list, the last node contains a null pointer ",5.0,5.0,5.0,0.9999768976250951
1262,7.5,"in a circular linked list, the last object is linked back to the first object.",5.0,5.0,5.0,0.9999744778967821
1263,7.5,"In the case of a non circular link list, if you are at the last node of the list and u want to move to first u need to go to one, step back till u reach to first. But in circular link list from last to first you need to make only one move.  In a single link list u can move only in one direction but in double link list u can move in any direction back or forward or forward.  ",2.0,5.0,3.5,0.9999159529032863
1264,7.6,they can traverse in both directions,3.0,4.0,3.5,0.9999764680442921
1265,7.6,In a doubly linked list you can delete a node without having to traverse the list.,5.0,4.0,4.5,0.9999671467204374
1266,7.6,A doubly-linked list allows you to delete a node without traversing the list to establish a trailing pointer.,5.0,4.0,4.5,0.9999577020428558
1267,7.6,A doubly linked list allows you to traverse the list in either direction. Each node points to its successor as well as to its predecessor. ,3.0,4.0,3.5,0.9999775216511126
1268,7.6,"Doubly-linked lists can traverse backwards, though they still cannot access data at any point in the list, it can be shorter to traverse backwards.",3.0,4.0,3.5,0.9999815269865615
1269,7.6,you can traverse the list from front to back and back to front,3.0,4.0,3.5,0.9999550255839489
1270,7.6,You can traverse the list in reverse.,3.0,4.0,3.5,0.99996992592981
1271,7.6,Doubly linked lists can be traversed in both directions,3.0,4.0,3.5,0.9999717202497002
1272,7.6,"Double-linked lists require more space per node, and their elementary operations are more expensive; but they are often easier to manipulate because they allow sequential access to the list in both directions.",4.0,3.0,3.5,0.9999796577052903
1273,7.6,You can traverse forwards and backwards through nodes. ,3.0,4.0,3.5,0.9999474992202476
1274,7.6,You can point both forwards and backwards,3.0,4.0,3.5,0.9999639574260284
1275,7.6,You can go backwards in the linked list and access previous data easier without having to keep track of the previous item,4.0,4.0,4.0,0.9999860587692561
1276,7.6,Doubly linked lists allow backward movement through the nodes.,3.0,4.0,3.5,0.9999504756337297
1277,7.6,"they have double pointers, so each node can point forwards or backwards. Making it a little easer to get to where you need. ",3.0,4.0,3.5,0.9999767241094691
1278,7.6, ability to backtrack through a list.,3.0,3.0,3.0,0.9999721794653722
1279,7.6,You can move forwards and backwards in the double-linked list. Basic only moves forwards.,3.0,4.0,3.5,0.9999742861266422
1280,7.6,The advantage is that each node points to bothe its predecessor and its successor. There are no special cases for insertion and deletion.,4.0,5.0,4.5,0.9999860807371954
1281,7.6,each node points to both its predecessor and its successor.,4.0,3.0,3.5,0.9999718143263044
1282,7.6,a doubly linked list has pointers in both directions. this allows for access from back to front as well as front to back,3.0,5.0,4.0,0.999960035119571
1283,7.6,"A doubly linked list can be traversed either direction, while a normal linked list can only be traversed from start to finish",3.0,4.0,3.5,0.9999685182719623
1284,7.6,"Double Linked list are often easier to manipulate, because they allow sequential access to the list in both direction",4.0,4.0,4.0,0.9999900830808006
1285,7.6,"given a node in the list, one can navigate easily in either direction",4.0,4.0,4.0,0.9999641891988165
1286,7.6,You can traverse the list both forward and backwards.,3.0,4.0,3.5,0.9999834475837837
1287,7.6,a doubly linked list allows you to back up from a node rather than having to go through the entire list again ,4.0,4.0,4.0,0.9999402981041529
1288,7.6,Gives faster times for some operations such as insertion and deletion,5.0,5.0,5.0,0.9999503506007799
1289,7.6,"The primary disadvantage of doubly linked lists are that (1) each node requires an extra pointer, requiring more space, and (2) the insertion or deletion of a node takes a bit longer (more pointer operations).",0.0,4.0,2.0,0.9999812761043213
1290,7.7,they take up twice as much memory for each node,5.0,5.0,5.0,0.9999410735801386
1291,7.7,"In a doubly linked list, there are more pointers to set and the mechanics of inserting and deleting are more difficult. Also, the special cases at the beginning or end of the list are more complicated.",4.0,3.0,3.5,0.9999211856673104
1292,7.7,"There are more pointers to set, the mechanics of inserting into and deleting from a doubly linked list are a bit more involved than for a singly linked list.",4.0,4.0,4.0,0.9999298089847052
1293,7.7,Insertion and deletion with a doubly linked list are more involved than with a singly linked list leaving more room for error and complex algorithms.,3.0,3.0,3.0,0.9998887071608847
1294,7.7,"Need more memory to store ""previous"" pointers.",5.0,5.0,5.0,0.9999578247011952
1295,7.7,a node in a doubly linked list takes up more memory than a node in a singly linked list.,5.0,5.0,5.0,0.9999341345722529
1296,7.7,You have to keep up with where you are and you have to consider the predecessor and successor connections when inserting/deleting.,3.0,3.0,3.0,0.9998882141065824
1297,7.7,"Each node requires an extra node, requires more memory, and is more difficult to insert and remove individual nodes",5.0,5.0,5.0,0.9999376286922743
1298,7.7,"Double-linked lists require more space per node, and their elementary operations are more expensive",5.0,5.0,5.0,0.9999451888167967
1299,7.7,More difficult to delete and create nodes.,3.0,3.0,3.0,0.999929621917677
1300,7.7,They use more memory and you have to make 2 pointers and update 2 pointers each time you change the list.,5.0,5.0,5.0,0.9999212072101076
1301,7.7,nodes take up more memory,5.0,5.0,5.0,0.9999123854909125
1302,7.7,"Each node requires an extra pointer (space requirements increased), Insertion or deletion of a node takes a longer (more pointer operations).",5.0,5.0,5.0,0.9999314300084454
1303,7.7,its a little more confusing. The special cases at the end and beginning become more difficult to do. ,3.0,3.0,3.0,0.999917633886844
1304,7.7,increased actions to add and remove elements to the linked list.,3.0,3.0,3.0,0.9999411884923269
1305,7.7,"Inserting and deleting in a double-linked list is more involved, and has special cases at the beginning and end.",3.0,3.0,3.0,0.99991494045746
1306,7.7,The main disadvanate is that if hard to remove all items in the list.,1.0,3.0,2.0,0.999951538993988
1307,7.7,"each node requires an extra pointer, taking up more storage.  insertions and deletions require more pointer operations.",5.0,5.0,5.0,0.9999546946743166
1308,7.7,"in a doubly linked list there are twice as many pointers for each element , therefore more memory is used",5.0,5.0,5.0,0.9999326049198083
1309,7.7,The process of adding and removing Nodes in a Doubly linked list is more complex than in a basic linked list,3.0,4.0,3.5,0.9999243279104041
1310,7.7,"Double linked lists require more space per node, and their elementary operation are more expensive",5.0,5.0,5.0,0.9999639135468176
1311,7.7,"1- each node requires an extra pointer, requiring more space 2- the insertion or deletion of a node takes a bit longer, more pointer operations",5.0,5.0,5.0,0.9999300730571117
1312,7.7,It takes up twice the storage needed.,5.0,5.0,5.0,0.99990602646195
1313,7.7,"using more pointers to enable the backward movement takes up more memory, having more pointers make it slightly more work to add or remove a node from the list",5.0,5.0,5.0,0.9999331384159441
1314,7.7,"increased memory requirements, slightly more complicated when modifying elements in the list",5.0,5.0,5.0,0.9998567723632259
1315,7.7,not answered,0.0,0.0,0.0,0.9995603538385917
1316,8.1,A data structure for storing items which are to be accessed in last-in first-out order that can be implemented in three ways.,5.0,5.0,5.0,0.9999821178732875
1317,8.1,A stack is an abstract data type that is based on the principle that the last element inserted into the stack will be the first element removed from the stack.,5.0,5.0,5.0,0.9999800085221157
1318,8.1,Stores a set of elements in a particular order.,0.0,4.0,2.0,0.9999655404593238
1319,8.1,"An ADT whose most recently inserted item is the first item removed or retrieved. This property is called last in, first out (LIFO). Items enter and leave a stack at its top.",5.0,5.0,5.0,0.9999877415547809
1320,8.1,A list in which only the top (or last item added) can be modified.,4.0,5.0,4.5,0.999962208387799
1321,8.1,a stack is a data structure that uses push to insert an item and pop to remove ad item. The stack use a last in first out structure for inserting and removing items.,5.0,5.0,5.0,0.9999764963435344
1322,8.1,A data structure that stores data using LIFO.,5.0,5.0,5.0,0.999974851271038
1323,8.1,"A stack is similar to an array, but does not allow for random access. Stacks only allow a user to retrieve the last item put into the stack. Last in, fist out.",5.0,5.0,5.0,0.9999779384021412
1324,8.1,Stores a set of elements in a particular order. Stack principle: LAST  IN  FIRST  OUT. It means: the last element inserted is the first one to be removed.,5.0,5.0,5.0,0.9999600002604123
1325,8.1,A stack is an ADT that stores a set of elements in a particular order.,1.0,4.0,2.5,0.9999733095043238
1326,8.1,"a data type that stores a set of elements in a certain order, last in, first out.",5.0,5.0,5.0,0.999959844197344
1327,8.1,a data structure that moves elements in last in first out,5.0,5.0,5.0,0.9999728677863078
1328,8.1,Stores a set of elements in a last in first out order.,5.0,5.0,5.0,0.9999450091227635
1329,8.1,A list that can be added to or removed from only from the top.,5.0,5.0,5.0,0.9999714213833332
1330,8.1,"a stack is an Abstract data type which operates on a last in first out basis for storing a list of objects, and does not support ( at least in the pure stack) peeking at a element without removing the rest of the stack first.",5.0,5.0,5.0,0.9999749541004441
1331,8.1,Stores a set of elements in a particular order based on the principle of Last In First Out (LIFO). ,5.0,5.0,5.0,0.9999670933585528
1332,8.1,"an object list that stores elements in a particular order, the first object inserted is at the bottom with the last object at the top so the first object in is the last object out.",5.0,5.0,5.0,0.9999580402904704
1333,8.1,An ADT that stores a set of elements in a particular order. The stack principles are LIFO. The last item inserted in the list is the first out.,5.0,5.0,5.0,0.9999800355292977
1334,8.1,An abstract data type that stores a set of elements in a particular order.,1.0,4.0,2.5,0.9999655180518162
1335,8.1,a collection of data to be executed in the order of last in first out,5.0,5.0,5.0,0.9999695587592822
1336,8.1,"A stack is a data structure that allows data members to be added or removed one at a time, and in order. They are a ""Last in First Out"" structure.",5.0,5.0,5.0,0.9999676284084795
1337,8.1,Stores a set of element in a particular order,0.0,4.0,2.0,0.9999596668618751
1338,8.1,is a list of element where the first one to be removed is the last one inserted,5.0,5.0,5.0,0.9999757088360337
1339,8.1,A data structure that puts elements in a list and only allows the user  access to the last element.,4.0,5.0,4.5,0.9999796823052115
1340,8.1,a finite ordered list with zero or more elements,0.0,4.0,2.0,0.9999745010978639
1341,8.1,"A storage container that holds objects in a certain order, which has a LIFO priority",5.0,5.0,5.0,0.999966448230716
1342,8.1,"Stacks are a type of container adaptors, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from the end of the container.",5.0,5.0,5.0,0.9999731282054336
1343,8.2,Push and pop are two main functions defined in a stack,5.0,5.0,5.0,0.9999458318371576
1344,8.2,Push which inserts an element on the top of the stack and pop which removes the last inserted element from the stack.,5.0,5.0,5.0,0.9998756320553558
1345,8.2,Push and pop.,5.0,5.0,5.0,0.9999297962221582
1346,8.2,Pop function and Push function,5.0,5.0,5.0,0.9999023686664956
1347,8.2,push and pop.,5.0,5.0,5.0,0.9999811224801012
1348,8.2,push (insert an item) pop (remove an item),5.0,5.0,5.0,0.9998757336635682
1349,8.2,Adding a new item and removing the item,5.0,5.0,5.0,0.9999169212014951
1350,8.2,Push (insert) and pop (retrieve).,5.0,5.0,5.0,0.9998847743577272
1351,8.2,push and pop.,5.0,5.0,5.0,0.9999811224801012
1352,8.2,Push and Pop.,5.0,5.0,5.0,0.9999202711458063
1353,8.2,pop and push,5.0,5.0,5.0,0.9999638571713609
1354,8.2,push (add an element) pop (remove an element),5.0,5.0,5.0,0.9998740113122612
1355,8.2,Push and pop.,5.0,5.0,5.0,0.9999297962221582
1356,8.2,pop and push,5.0,5.0,5.0,0.9999638571713609
1357,8.2,push ( to add to a item the Stack) Pop  ( to pull the last item added from an array. ),5.0,5.0,5.0,0.9998146441896013
1358,8.2,pop and push,5.0,5.0,5.0,0.9999638571713609
1359,8.2,"push and pop, push puts an object into the list, and pop takes the last object off.",5.0,5.0,5.0,0.9999437438522536
1360,8.2,Push and Pop are the two main functions of a stack,5.0,5.0,5.0,0.9999272920744207
1361,8.2,Push and Pop,5.0,5.0,5.0,0.9999181391853679
1362,8.2,"push, which adds an element to the stack... and pop which takes an element off the stack",5.0,5.0,5.0,0.99993454126433
1363,8.2,"Push and Pop, which add and remove data from the stack, respectively.",5.0,5.0,5.0,0.9999317485294267
1364,8.2,push and pop,5.0,5.0,5.0,1.0
1365,8.2,pop - to remove item push - to insert an element ,5.0,5.0,5.0,0.9999113596592801
1366,8.2,Pop and push,5.0,5.0,5.0,0.9999355953975695
1367,8.2,pop and push,5.0,5.0,5.0,0.9999638571713609
1368,8.2,push - adds an item to the top of the stack pop - removes the top item from the stack,5.0,5.0,5.0,0.9998473526838279
1369,8.2,push and pop. Push adds a given node to the top of the stack leaving previous nodes below. Pop removes and returns the current top node of the stack,5.0,5.0,5.0,0.9998876071055368
1370,8.3,An array has a fixed size.  You can add and delete elements to the end of the array and you use a pointer to keep track of the last element added.  Each time you add or delete an element you update the pointer and check if it is equal to the max size of the array.,5.0,5.0,5.0,0.9999142235946864
1371,8.3,By implementing an array of a pre-defined size with the bottom stack element stored at element 0 and the last element stored in the array is the top. You increment top when an element is pushed and you decrement it when an item is popped.,5.0,5.0,5.0,0.9999792771618752
1372,8.3,"If you use a dynamically allocated array, you must provide a destructor and copy constructor.",2.0,4.0,3.0,0.999952520158551
1373,8.3,"Create a int value that stores the ""head"" of the stack. Increment the top when one element is pushed and decrement after it is popped.",5.0,5.0,5.0,0.999961999124814
1374,8.3,Use a pointer that always points to the end of the array list for push/pop modifications.,5.0,4.0,4.5,0.9999451778116878
1375,8.3,if you used an array to implement a stack when you add an element just add it to the end of an array and remove items from end of array also.,5.0,4.0,4.5,0.9999498818827328
1376,8.3,You predetermine the size of the stack as you would an array.  This type can not grow. ,1.0,4.0,2.5,0.9999679172987085
1377,8.3,"Declare a variable that points the last item in the array, which increases (++) when items are pushed onto the stack, and decreases (--) when an item is popped off the top.",5.0,5.0,5.0,0.999976295502517
1378,8.3,"Allocate an array of some size. The bottom stack element is stored at some element. Last index in the array is the top. Increment top when one element is pushed, decrement after pop. ",5.0,4.0,4.5,0.999969206325675
1379,8.3,"You allocate an pre-defined array, the bottom element is stored at element 0, and the last index is the head.",5.0,3.0,4.0,0.9999460150814099
1380,8.3,"Make an array, make the bottom at spot 0, make the last spot in the array the top, and increment top when you ad",5.0,4.0,4.5,0.9999350737238536
1381,8.3,treat the beginning of the array as the beginning of the stack,4.0,4.0,4.0,0.9999589673606915
1382,8.3,Use an index value called top to keep track of the last element in the array.,5.0,4.0,4.5,0.9999167211228897
1383,8.3,create an array and implement pointers that point to the next list item down and stack them up.,1.0,3.0,2.0,0.9999572617475065
1384,8.3,"for efficiency it is easiest to implement the left to right method, with the right most item being the one that is retrieved when a pop is performed, and a push places an object on the furthest element.",3.0,4.0,3.5,0.9999661682573726
1385,8.3,"Create an array based on a pre-defined size N There can't be more elements than N.  Bottom stack element stored at element 0 last index in the array is the top  Increment top when one element is pushed, decrement after pop",5.0,4.0,4.5,0.9999633716752855
1386,8.3,"with the element added to the array, so that the last element added is at the end, and when the element is popped it takes the last element off the array",4.0,4.0,4.0,0.9999004425775515
1387,8.3,Allocate an array of some pre-defined size. Bottom stack element stored at element 0. The last index in the array is the top. Increment top when one element is pushed.,5.0,4.0,4.5,0.9999623357714668
1388,8.3,"Create an array, size N.  N++ when one element is pushed.  N-- when one element is popped.",4.0,4.0,4.0,0.9999550874425076
1389,8.3,define an array and keep track of a pointer to the last element as items are added,5.0,3.0,4.0,0.9998810654922607
1390,8.3,"By allocating an array of predetermined size, and an integer to track the top element of the stack. The bottom member of the stack will go in element 0 of the array, and for each element pushed the ""top"" tracking integer is incremented.",5.0,4.0,4.5,0.9999071508531653
1391,8.3,"Allocate an array of some size, bottom stack element stored at element 0",4.0,4.0,4.0,0.999916732304847
1392,8.3,you store the stack in the array but you have to keep in mind the first element,3.0,3.0,3.0,0.9999344181804803
1393,8.3,You keep track of the last item entered into the array and do not  allow the user access to the other parts of the array.,5.0,3.0,4.0,0.9999679564103294
1394,8.3,"using arrays, you are pushing one int at a time into the stack until you get to the end of your array",4.0,4.0,4.0,0.9999678988755506
1395,8.3,"by having a max number of elements, allocating an array with that number of elements, storing the elements starting at 0, and keeping track of how many elements are currently in the list",5.0,3.0,4.0,0.9999620608403766
1396,8.3,"Stack usually holds a bunch of items with the same type, therefore u can use an array, to hold the content of the stack and an integer top that holds the index of the element at the top of the stack. u Choose an array size. Then the sequence of operations used. u have to decide what data types are needed for this stack data structure. ",2.0,4.0,3.0,0.9999699905922225
1397,8.4,You can add an element to the end of the linked list and update a pointer called top each time you modify the list.,2.0,4.0,3.0,0.9999603621763078
1398,8.4,You implement a list in which the head pointer points to the element most recently pushed onto the list and the pop function changes the head pointer to point to the next to last element in the list and removes the element head pointer previously pointed to.,5.0,5.0,5.0,0.9999626420061821
1399,8.4,This is the implementation of the stack using single linked list.   The operations performed on a stack are    1)push(): This is the function which is for insertion(pushing)of an element into stack                      It is similar to the insertion of an element at the end of a single linked list                   see  the function insert_end() in the program for operations of single linked list    2)pop(): This is the function which is for deletion(popping up) of an element from the stack             It is similar to the deletion of an element at the end of a single linked list       see  the function delete_end() in the program for operations of single linked list    3)stack_display():This is the function which is for displaying the elements of a stack,3.0,5.0,4.0,0.9998781490454588
1400,8.4,Using nodes to keep track of the head of the stack. Then using Push( ) and Pop ( ) to create the stack as needed.,4.0,4.0,4.0,0.9999386618602799
1401,8.4,"Use the head as the top of the stack, only modify the head when you push/pop... push would add a new item to the head, pop would remove the item from the head.",5.0,4.0,4.5,0.9999770437144228
1402,8.4,you implement a stack with a list by changing the pointer to the first element of the list to the new item and move the pointer from the top of the stack to the next item when removing an item.,5.0,4.0,4.5,0.9998796219819858
1403,8.4,You dynamicly create space as the stack grows.  The stack can be as long as you need.,1.0,4.0,2.5,0.9999753977642497
1404,8.4,"Declare a pointer that points to the head of the linked list, only add and remove nodes from the beginning of the list.",5.0,5.0,5.0,0.9999831251628076
1405,8.4,Creating a linked list. Add an element to the top of the stack when pushing and deleting an element when popping.,4.0,4.0,4.0,0.9999401617765098
1406,8.4,"A singly-linked list is already a lot like a stack, it just depends on the way you address moving the head.",4.0,3.0,3.5,0.9999745829685833
1407,8.4,"make a list, make the bottom the head, add on the end and make the end top",3.0,4.0,3.5,0.9998942150479656
1408,8.4,use the add function with a list as the beginning of the stack and remove for pop,5.0,4.0,4.5,0.9999601956711485
1409,8.4,Use head as the top and push and pop nodes from the head.,5.0,4.0,4.5,0.9999787739401426
1410,8.4,create a node based list that points to the next list item down.,0.0,3.0,1.5,0.9998973463867431
1411,8.4,"have the head of the list be the last item added, and a push just adds a new head.",5.0,4.0,4.5,0.9999660216421368
1412,8.4,"Create a new list.  Pop elements in the stack as needed.  Push the stack to remove items, unless the stack is empty.  The top item is at the head of the list. The last item is at the end.",5.0,4.0,4.5,0.9999064319284301
1413,8.4,adding the element to the end of the list so that it links to the element before it. when popping the element it takes the last element in the list and sets the previous one as the end of the list.,3.0,4.0,3.5,0.9999251866428117
1414,8.4,"You can implement a stack using arrays or and linked list. By the use of pointers, that point element(node) to the next element in the stack. By the use of pointers, the stack becomes a linked list.",1.0,4.0,2.5,0.9999173117023942
1415,8.4,Elements are only inserted and removed from the head of the list.  There is no header node or current pointer.,5.0,4.0,4.5,0.9999617310903557
1416,8.4,use a linked list and keep track of a pointer that points to the first item,4.0,4.0,4.0,0.999918749883113
1417,8.4,"A singly linked list can already be easily used for LIFO data storage. Members of a stack can simply be pushed and popped from a list, the first item in will be the last out.",5.0,4.0,4.5,0.9999732117142961
1418,8.4,using pointer ,0.0,3.0,1.5,0.9996139969671034
1419,8.4,the top is the first pointer.,3.0,3.0,3.0,0.9999324834894562
1420,8.4,"Keep a pointer pointing to the last element entered at the front of  the array and move the pointer ""back"" when you delete an element.",2.0,3.0,2.5,0.9999700776528957
1421,8.4,"using linked list, you are pushing the node that contains each int to the stack until you get to the end of your linked list",1.0,4.0,2.5,0.9999712255859412
1422,8.4,"have a linked list, and for each push, add an item onto beginning of the list, and for each pop remove the first element in the list.",5.0,5.0,5.0,0.9999072080820941
1423,8.4,"Using a linked list is one way to implement a stack so that it can handle essentially any number of elements. It is usually convenient to put a data structure in its own module, thus, you'll want to create files stack.h and a stack.c",0.0,4.0,2.0,0.9999614526743476
1451,8.6,They are converted to post fix expressions.  It still follow the order of precedence for the operators.,5.0,5.0,5.0,0.9999822189828529
1452,8.6,They are first converted to postfix expressions and then evaluated.,5.0,5.0,5.0,0.9999771040804296
1453,8.6,"Computers cannot evaulate infix expressions, it must first convert infix to postfix expression then it can evaluate.",5.0,5.0,5.0,0.999960531442475
1454,8.6,By using parentheses to have order in the expression.,2.0,3.0,2.5,0.9999756649387931
1455,8.6,In postfix notation.,3.0,5.0,4.0,0.9996817458934557
1456,8.6,computers usually convert infix expressions to post fix expression and evaluate them using a stack.,5.0,5.0,5.0,0.9999682625583949
1457,8.6,they are converted to postfix,5.0,5.0,5.0,0.9999471699847312
1458,8.6,Infix expressions are interpreted as postfix expressions by implementing stacks.,5.0,5.0,5.0,0.9997902361234402
1459,8.6,They are first converted into an equivalent postfix expression so it can be read by the computer.,5.0,5.0,5.0,0.9999679964810037
1460,8.6,"The computer translates the infix expression to a postfix expression, then solves.",5.0,5.0,5.0,0.9999613572692777
1461,8.6,in postfix format,3.0,5.0,4.0,0.9999184599538847
1462,8.6,they use parenthisis and a stack to determine which evaluations need to be made first,3.0,3.0,3.0,0.9999711349724116
1463,8.6,By throwing variables into a postfix expression and operands onto a parentheses regulated stack until end parentheses and enough variables to operate on are encountered. ,4.0,5.0,4.5,0.9999621189902719
1464,8.6,by being passed to the function by a leading term,0.0,3.0,1.5,0.9999718061614185
1465,8.6,"i have an hard time explaining this so i'll show how infix is evaluated instead. Start with an infix expression, like,  (((5+2)*5)+(400/(2+3))), and  push items until you get a "")"" and once that happens, perform the operations until you reach an ""(""... with that complete, you will now have  ((7*5)+(400/(2+3))) as now the expression that will be evaluated... perform last step again... (35+(400/(2+3))) is now the stack.... repeat agian... (35+(400/5)) is now the stack after that.... repeat... (35+80) is now the stack, repeat again... 115 is now the stack, and is returned.",1.0,4.0,2.5,0.9999674782368986
1466,8.6,The infix expression is converted to postfix form ,5.0,5.0,5.0,0.9999664577616589
1467,8.6,by converting them to postfix expressions and putting the operations in a stack,5.0,5.0,5.0,0.9999602243299864
1468,8.6,The computer converts the infix expression to postfix form. Then evaluates the postfix expression.,5.0,5.0,5.0,0.9999383967423991
1469,8.6,infix expressions are converted to postfix expressions before they can be evaluated by a computer.  Operands stay in the same order.  Operators always follow the operands.,5.0,5.0,5.0,0.9999412879731221
1470,8.6,infix expressions are pointers evaluated by reference to the memory location,0.0,3.0,1.5,0.9999666867454766
1471,8.6,computers convert infix expressions to postfix form before evaluation,5.0,5.0,5.0,0.9998094016090363
1472,8.6,convert infix expressions to postfix expression and evaluate the postfix expression,5.0,5.0,5.0,0.9999334346029928
1473,8.6,"When an operand is entered, the computer Pushes it onto a stack When an operator is entered, the computer Applies it to the top two operands of the stack Pops the operands from the stack Pushes the result of the operation onto the stack",4.0,4.0,4.0,0.9999565449764894
1474,8.6,Computers convert an infix expression into a postfix expression. They then push the numbers onto a stack and pop them out as they are needed.,5.0,5.0,5.0,0.9999622943999869
1475,8.6,"infix expressions are converted to postfix, (i.e. 3+2 is changed to 32+)",5.0,5.0,5.0,0.9999599975685023
1476,8.6,"they are transformed into post-fix expressions, then evaluated with a stack.",5.0,5.0,5.0,0.9999868384074354
1477,8.6,"Writing arithmetic expressions is called infix notation.  This is because a binary operator (like '+') is written in between its two operands (as in ""a + b"").  There are two alternative forms of notation used in certain situations.  One is prefix notation, in which an operator is written before its operands.  In prefix notation, the sum of a and b is written ""+ a b"".  This is the notation used to write function calls in mathematics and computer science.  It is also used in the Lisp and Scheme programming languages.  In postfix notation, an operator is written after its operands.  The sum of a and b is written ""a b +"".  (You may have seen this as ""reverse Polish notation"".)  Postfix notation forms the conceptual basis for the way that arithmetic expressions are evaluated by a computer.  One important characteristic of both postfix and prefix notations is that they are unambiguous; no parentheses are needed to indicate the order of operations. ",5.0,5.0,5.0,0.9999602418047866
1478,8.7,isEmptry()//determines if the stack is full or not pop()//to remove the top element if it is not the on you are looking for search()//you compare each element of the stack to the data you are looking for.,2.0,4.0,3.0,0.9999422448469746
1479,8.7,You would have to keep using peek or getTop to see what the top element is then popping the top element until peek or getTop provides the element you are looking for.,2.0,4.0,3.0,0.9999793659836603
1480,8.7,Push adds a given node to the top of the stack leaving previous nodes below. Pop removes and returns the current top node of the stack.,2.0,4.0,3.0,0.999958305670249
1481,8.7,"Using linked lists and stacks, you would need a temp stack to retain the values. Then you would use the Pop( ) function to pop off each element and then compare it. If its not the element your looking for, Push ( ) it to the temp stack. Repeat until the element is found. When you find it,  Pop ( ) off the temp stack back onto the regular stack to have a complete stack again.",5.0,5.0,5.0,0.9999328731743037
1482,8.7,"Pop each item off the top until you find what you are looking for. If the stack ends up empty and you never found the item, then it does not exist in the stack. It may also be necessary to save the popped values in case you want to recreate the stack.",5.0,5.0,5.0,0.9999527901129566
1483,8.7,"if the stack is implemented using an array you could simply search the array for the item. If the stack is implemented using a linked list you would have to pop the values off of the stack until either the value is found or the stack is empty, you would then have to have the items put back into the list.",4.0,5.0,4.5,0.9999481792762724
1484,8.7,"You need to pop each item on the stack and compare the item.  Once the item is found, no more items need to be removed.",3.0,4.0,3.5,0.999948900985453
1485,8.7,"Pop an element from one stack, check to see if it is the desired element, if not push it onto another stack. When finished, pop the items from the second stack and push them back onto the first stack (this will ensure the order of the elements is maintained).",5.0,5.0,5.0,0.9999531444962539
1486,8.7,Basically pop the stack until you find the given element.,3.0,4.0,3.5,0.9999756619829377
1487,8.7,"Iterate through the stack, checking the number against the current element.",0.0,3.0,1.5,0.9999052901059423
1488,8.7,pop and push,2.0,4.0,3.0,0.9999638571713609
1489,8.7,pop all elements off stack until you find that element and then push the popped elements back on the stack,5.0,5.0,5.0,0.9999869623069766
1490,8.7,"Keep popping nodes and storing them in an alternate stack until the given element is found, then pop the given element and push the previously popped nodes back onto the stack.",5.0,5.0,5.0,0.9999734331321157
1491,8.7,either traverse the entire list and pop the given part or create a pointer system that automatically points to it.,2.0,4.0,3.0,0.9999833424106664
1492,8.7,"Depends on the type of stack, on a true stack you will haft to pop all of the elements of the stack until you find the element you want, and then after that you will need to push all the elements that where removed back in to the stack in the order that they where removed.  With a Java style stack, where there is a peek function, it will return the element you wanted instead of requiring you to perform all the excessive actions that are required from a true stack.",5.0,5.0,5.0,0.9999833464313264
1493,8.7,if top item != given element pop the stack. Repeat until item is found or stack is empty,3.0,4.0,3.5,0.999873157343218
1494,8.7,could traverse through the list/array to find the element.,1.0,3.0,2.0,0.9999698225314674
1495,8.7,you need the pop opertation to go throught the stack and find the element.,3.0,4.0,3.5,0.9999781588486777
1496,8.7,"createStack, push, isEmpty, pop, and a boolean return value.",2.0,4.0,3.0,0.9999162127504349
1497,8.7,you would have to traverse the stack popping each element to search it,3.0,4.0,3.5,0.999978093165075
1498,8.7,Pop each element off the stack (and into another stack for storage) until the desired element is found.,4.0,4.0,4.0,0.9999284019720364
1499,8.7,pop operation,1.0,4.0,2.5,0.9997298361048855
1500,8.7,to pop elements then push them back,4.0,5.0,4.5,0.9999758989346167
1501,8.7,A function to keep track of the elements popped and a function to put  the popped elements backinto the function.,4.0,5.0,4.5,0.9999394158324728
1502,8.7,you would pop each element and compare it to what you are looking for and then push it back on the stack so that it is not lost,4.0,5.0,4.5,0.999977273385515
1503,8.7,you would need to perform a search through the list of elements (i dont really understand what this question is asking....its not very clear?),0.0,3.0,1.5,0.999975032912181
1504,8.7,StackPush() StackPop() StackIsEmpty(),2.0,4.0,3.0,0.9996167871840248
1505,9.1,A data structure in c++ which is a collection of data that is kept in order.  First in first out.,5.0,5.0,5.0,0.9999769478530935
1506,9.1,a queue is a list of objects in a particular order that is read one at a time starting at the first followed by the second and so on.,4.0,4.0,4.0,0.9999655768214696
1507,9.1,A queue is an abstract data structure in which operations are performed at both ends giving the queue first in first out behavior.,5.0,5.0,5.0,0.9999656031735101
1508,9.1,"A queue stores a set of elements in a particular order.  Its principle of operation is FIFO(first in first out), which means the first element inserted is the first one to be removed.",5.0,5.0,5.0,0.999975933646395
1509,9.1,An ADT whose first inserted item is the first item removed. This uses the FIFO idea where items enter a queue at its back and leave at its front.,5.0,5.0,5.0,0.9999836749482718
1510,9.1,"Last in, last out architecture. It works the same way a line at the bank would work, the person that's been waiting the longest gets served first.",5.0,5.0,5.0,0.9999778481561564
1511,9.1,a queue is a data structure that stores elements in a First in First out order.,5.0,5.0,5.0,0.9999577064874487
1512,9.1,A waiting list of items that operation in a FIFO (first in first out) order.,5.0,5.0,5.0,0.9999779155409632
1513,9.1,"A queue is similar to an array, except that the data can only be accessed sequentially rather than at random. Unlike a stack, a queue follows FIFO. First in, First out.",5.0,5.0,5.0,0.9999722010658435
1514,9.1,is a particular kind of collection in which the entities in the collection are kept in order and the principal (or only) operations on the collection are the addition of entities to the rear terminal position and removal of entities from the front terminal position. First in First Out (FIFO Method).,5.0,5.0,5.0,0.9999795479417916
1515,9.1,Like a linked list but first in first out,4.0,5.0,4.5,0.9999089400757113
1516,9.1,A queue is a FIFO data structure.,5.0,5.0,5.0,0.9999332682592521
1517,9.1,A queue is a first in first out data structure.,5.0,5.0,5.0,0.9999447312761623
1518,9.1,"Its like a stack, but uses the linked list to stack a little differently. It's FIFO so the first thing enqueued is the first thing dequeued",5.0,5.0,5.0,0.999963699992289
1519,9.1,"A first in, first out Abstract Data type that can be used to store values.",5.0,5.0,5.0,0.9999206183752009
1520,9.1,"Stores a set of elements in a particular order with a First In, First Out principle",5.0,5.0,5.0,0.9999629821357221
1521,9.1,object that stores elements in order that follows first in first out.  the first element added is the first one to come off.,5.0,5.0,5.0,0.9999718947683636
1522,9.1,"A quese is an list that stores a set of elements in a particular order. It has Stack principle, but in this case, its ""First In, First Out"". The first element inserted is the first element to be removed.",5.0,5.0,5.0,0.9999773558264874
1523,9.1,"a finite ordered list with zero or more elements, based upon First In First Out",5.0,5.0,5.0,0.9999579690514067
1524,9.1,a data structure that performs operations in the order of first in first out FIFO,5.0,5.0,5.0,0.9999754748713039
1525,9.1,"A Queue is a ""first in first out"" data structure, such that the first element added is also the first removed.",5.0,5.0,5.0,0.9999538161724879
1526,9.1,"Queue is a buffer, which store element in a particular order",2.0,5.0,3.5,0.9999041963186736
1527,9.1,"stores a set of elements where the first element in, is the first element to be removed",5.0,5.0,5.0,0.9999751851318494
1528,9.1,A data structure that removes nodes from the head and adds nodes at the tail.,5.0,5.0,5.0,0.9999581269199526
1529,9.1,a queue is a list of things that follows the first in first out behavior,5.0,5.0,5.0,0.9999526221314594
1530,9.1,"a queue is a storage container that holds its objects in a first in, first out priority",5.0,5.0,5.0,0.9999420173046745
1531,9.1,"The queue is another data structure. A physical analogy for a queue is a line at a bank. When you go to the bank, customers go to the rear (end) of the line and customers come off of the line (i.e., are serviced) from the front of the line.",5.0,5.0,5.0,0.999971467325113
1532,9.2,enqueue which adds data to the queue and dequeue which deletes data from the queue,5.0,5.0,5.0,0.9999239902743774
1533,9.2,"enqueue , which inserts a specified element at the head of the specified queue, and dequeue , which removes the specified element from the queue.",5.0,5.0,5.0,0.9998763230605825
1534,9.2,The two main functions are enqueue which inserts an item at the back of the queue and dequeue which removes an item from the front of the queue.,5.0,5.0,5.0,0.9999151079095002
1535,9.2,The two main functions are enqueue and dequeue.,5.0,5.0,5.0,0.9999779575226433
1536,9.2,Enqueue and Dequeue,5.0,5.0,5.0,1.0
1537,9.2,Enqueue and Dequeue,5.0,5.0,5.0,1.0
1538,9.2,enqueue - insert into queue dequeue - remove element,5.0,5.0,5.0,0.9998575334411773
1539,9.2,"Remove the item added first, add items to the back.",5.0,5.0,5.0,0.9997311564654309
1540,9.2,The two main functions of a queue are enqueue and dequeue. ,5.0,5.0,5.0,0.9999514627274523
1541,9.2,enqueue and dequeue.,5.0,5.0,5.0,0.9999848755407239
1542,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1543,9.2,Enqueue and Dequeue,5.0,5.0,5.0,1.0
1544,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1545,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1546,9.2,"enque ( Data ),  Deque ( )",5.0,5.0,5.0,0.999868969835592
1547,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1548,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1549,9.2,"The two functions are, Enqueue and Dequeue",5.0,5.0,5.0,0.9999597202433625
1550,9.2,"enqueue, dequeue",5.0,5.0,5.0,0.9999797874465336
1551,9.2,"enqueue, that adds an item to the queue dequeue, that takes the first item out of the queue",5.0,5.0,5.0,0.9999148637514954
1552,9.2,"Enqueue and dequeue, which add and remove elements from the queue",5.0,5.0,5.0,0.9999082673071207
1553,9.2,Enqueue and Dequeue,5.0,5.0,5.0,1.0
1554,9.2,dequeue and enqueue,5.0,5.0,5.0,1.0
1555,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1556,9.2,enqueue and dequeue,5.0,5.0,5.0,1.0
1557,9.2,enqueue dequeue,5.0,5.0,5.0,0.9997731974199952
1558,9.2,rear and front ,2.0,3.0,2.5,0.9998733496452137
1559,9.3,Make use of a front pointer and a tail pointer.  When the tail pointer reaches the end of an array it gets reset to the front of the array.  If the two pointers are equal then the queue is either full or just has one element.,5.0,4.0,4.5,0.9999504284232811
1560,9.3,you create an array with the max size of your queue and adjust the items to make them follow FIFO procedure.,2.0,4.0,3.0,0.9999228133747055
1561,9.3,By implementing an array and only adding items to the end of the array and only removing items from the beginning of the array.,2.0,4.0,3.0,0.9999692531127469
1562,9.3,"For applications in which a fixed-sized queue does not present a problem, you can use an array to represent a queue. ",1.0,4.0,2.5,0.9999325760745803
1563,9.3,Keep track of the front and the back of the array as you increase and decrease the elements inside the array.,4.0,4.0,4.0,0.9999757311737971
1564,9.3,"Declare the size of an array, and have special conditional statements (pointers) to make sure you re-use ALL of the array. Say, you have an array of 20 elements, you load up 18, then dequeue 3, when you enqueue 4 more elements, you want to loop back to index 0 and continue from there... this process saves resources.",5.0,4.0,4.5,0.9999749526161212
1565,9.3,you could use the first element of the list as the remove point and insert at the end f you do this you would have to shift the elements down each time you remove an item unless you make the array circular.,3.0,5.0,4.0,0.9999012228615718
1566,9.3,Utilizing indexes for the front and the back.  Front is 0 and as you add items the back index is incremented.,4.0,4.0,4.0,0.9999583657410789
1567,9.3,"Declare two variables, â€œfrontâ€ and â€œrearâ€, to be used to denote which elements in the array can be accessed. Increment â€œrearâ€ whenever data is enqueued to the end and increment â€œfrontâ€ whenever data is dequeued.",5.0,4.0,4.5,0.9999771152423247
1568,9.3,It is an array of fixed size. A queue of maximum N elements.,1.0,4.0,2.5,0.9999470251310041
1569,9.3,"make an array of a size, and add on to the front and delete from the back, keep track of the two so that you know when it is full and where to add or subtract from",4.0,4.0,4.0,0.9998951171147753
1570,9.3,By using the beginning of the array as the removal point of the queue (or beginning of the queue) and the ith element as the end of the queue.,3.0,4.0,3.5,0.9999689636881889
1571,9.3,"add in data from the first element to the last, take out data from the first element to the last.",2.0,4.0,3.0,0.9998132372594315
1572,9.3,you can take the array and put it in a queue stack or you can just traverse the list and keep track of top and bottom,3.0,4.0,3.5,0.9999207564912261
1573,9.3,"create a fixed array size, with with 2 integers to point to the beginning and the end of the que, and special cases to know when the que is empty or full.",4.0,4.0,4.0,0.9999594686634843
1574,9.3,Keep track of the front and rear indexes. Either: 1)Dequeue items by shifting the array left 2)Use wrapped configuration,4.0,4.0,4.0,0.9999737166340704
1575,9.3,"add items into a fixed size array, pull the items out by calling on them with the starting index, increase starting index so when it calls again its now the next index element in the array.",3.0,4.0,3.5,0.9999346787969702
1576,9.3,"To use and array to implement a Queue, element or item 0, should be the top element in the array. Every time an element is inserted, all the items in the array are pushed back one space. The top element is always removed first.",2.0,4.0,3.0,0.9999711162549623
1577,9.3,fixed size array with max N elements.  Need to keep track of front and rear of array.,4.0,4.0,4.0,0.9999750868393766
1578,9.3,"by keeping track of a front item and a rear item, or with a circular array that uses the modulo function",5.0,5.0,5.0,0.9999669640485442
1579,9.3,"Using an array for a queue, the size of the array allocated limits the size of the queue. An array based queue class must keep track of both the front and back of the queue, which may need to wrap around the array.",5.0,5.0,5.0,0.99988946333746
1580,9.3,"A pointer based implementation of a queue could use a linear linked list with two external pointers, one to the front and one to the back",0.0,4.0,2.0,0.9999440973449973
1581,9.3,remove the element then shift the elements one space back,2.0,4.0,3.0,0.9999410112153949
1582,9.3,By having the head pointer point to the first or least current data entered and having the tail point to the most current data entered. A method must be created so that the tail pointer doesn't leave the array.,5.0,5.0,5.0,0.9999760081730148
1583,9.3,an array is a type of queue with a fixed length,0.0,3.0,1.5,0.9998700581352225
1584,9.3,"your storage class has an array, and you keep track of the index of the first and last item in the array, and wrap around when end of the array is full",5.0,5.0,5.0,0.9998445205166888
1585,9.3,Boolean isFullQ(queue) ::= rear == MAX_QUEUE_SIZE-1,5.0,5.0,5.0,0.999900606064425
1586,9.4,A list can have unlimited elements in it.  You can push a node onto the end of the list and pop the one in the front.,5.0,5.0,5.0,0.999807235456483
1587,9.4,theoretically you could do it two ways one of which uses more processing power and memory no larger than the queue is ever at when full and the other which uses almost infinite memory. The more practical method would be two place the items in an array and remove the item in position one of the array after which you can shift the array and add another element if required. The other option which can use infinite memory when used for long term queues such as job scheduling that goes nonstop for extended periods. that is to implement an array and add the items read item one raise your counter value to two ecetera and continue adding more elements to the array. the downside to this method is after you use element one it is still in memory. or im crazy who knows,0.0,4.0,2.0,0.99985842519512
1588,9.4,"By implementing a list in which a tail pointer points to the item most recently inserted onto the back of the list and a head pointer which points to the item least recently inserted onto the list. Also, items can only be removed from the front of the list and can only be added to the back of the list.",5.0,5.0,5.0,0.9999360617396689
1589,9.4,You can use list to represent the items in a queue.,0.0,3.0,1.5,0.9997806622101661
1590,9.4,Have a pointer to the last element in the list and then use enqueue to insert items there. Link the first and last elements together to dequeue the list.,3.0,4.0,3.5,0.9998243139215592
1591,9.4,Enqueue to the end of the linked list... dequeue items from the beginning (head) of the list.,5.0,5.0,5.0,0.9998406414637061
1592,9.4,you use the first element in the list as the remove point for the queue and insert items at the end of the list.,5.0,5.0,5.0,0.9998727582001391
1593,9.4,"Utilizing a front pointer and a back pointer.  The front poiner and back pointer points to the first item into the queue.  As you add items, the front remains the same but the back poiner 'next' points to the new item and the new item is assigned to become the 'new' back pointer.",5.0,4.0,4.5,0.9999085096498238
1594,9.4,Implement a linked list that only allows nodes to be added to the tail and can only be retrieved from the head.,5.0,4.0,4.5,0.999819829321522
1595,9.4,Check if list is empty and add elements to the list.,1.0,4.0,2.5,0.9997380805169214
1596,9.4,"make a linked list and add on to the front and delete from the back, keep track of both to do so.",5.0,4.0,4.5,0.9998419272737645
1597,9.4,by making the head of the list the beginning of the queue and the last listed item the insertion point of the queue,5.0,4.0,4.5,0.9998998895782091
1598,9.4,throw in data at the head and take it out at the tail,4.0,5.0,4.5,0.9998147976693211
1599,9.4,"You create a list of nodes that had a head and a top pointer, and the functions are basically the same substituting pop and push with enqueue and dequeue",2.0,4.0,3.0,0.999798366791208
1600,9.4,"fairly easy... singly linked list with a pointer to the head and tail of hte list.  deque first item in que, create temp pointer to next element, delete head, and then make head the temporary pointer.  enque new item, use pointer to end of list, add a new item to the next item of the tail, and make the tail the next item of the current tail.",5.0,4.0,4.5,0.9998982751747639
1601,9.4,"Use a linked list with 2 pointers, one to the front and one to the back. As long as back != front, the queue is not empty.",5.0,4.0,4.5,0.999817230521992
1602,9.4,"create a node with the input data, continue to add to the list.  when dequeueing - get the first elements data and set the next element in the list as the new first element",4.0,4.0,4.0,0.9998298012821989
1603,9.4,"A linked list with Stack principles. The Queue's top element is the element that is always being removed first. Must use nodes to contain each element, with a pointer to the top element, which also could  be called the head pointer.",2.0,4.0,3.0,0.9997498017104675
1604,9.4,linked list checking for front and rear.  Keep enqueueing elements until front equal to rear -1.,3.0,4.0,3.5,0.9998298882069491
1605,9.4,"a queue can be implemented in a list by keeping track of two pointers, a head and a tail",5.0,4.0,4.5,0.9997821927209597
1606,9.4,"each element of a queue can be allocated in the nodes of an linked list. New elements should be added to the head of the list, with each dequeued element coming off the tail.",5.0,5.0,5.0,0.9998244608646089
1607,9.4,"Implement the operation dequeue() as the list operation remove(1) and the operation getFront(queueFront) as the list operation retrieve(1, queueFront)",3.0,5.0,4.0,0.999873061407336
1608,9.4,remove the first element and reference the second element as the new head of the list. ,3.0,4.0,3.5,0.9997689752387915
1609,9.4,By creating and adding nodes at the end of the list and removing the nodes from the beginning of the list.,5.0,5.0,5.0,0.9998551033432619
1610,9.4,you would have your list and add a back pointer so that your program knows where the end is,4.0,4.0,4.0,0.9997680267629873
1611,9.4,"your queue storage class has a list, and for enqueue, you add the item to the end of the list, and for dequeue you return the first item in the list",4.0,5.0,4.5,0.9998292933850961
1612,9.4,      temp-&gt;next= NULL;       if (front)  { (rear) -&gt; next= temp;}       else front = temp;       rear = temp;   } ,3.0,4.0,3.5,0.9997292698685132
1640,9.6,Push.,5.0,5.0,5.0,0.9997346331569389
1641,9.6,"push, which inserts something at the top of the stack.",5.0,5.0,5.0,0.9997471467081954
1642,9.6,The stack operation corresponding to enqueue in queues is the push operation.,5.0,5.0,5.0,0.99974937482009
1643,9.6,"Push in a stack operation corresponds to the enqueue operation in queues.  These operations insert a new item into one end(the top and back, respectively) of the ADT.",5.0,5.0,5.0,0.9997621393309742
1644,9.6,The stack operation is almost the opposite of the enqueue operation.,0.0,5.0,2.5,0.999708500073414
1645,9.6,push = enqueue pop = dequeue,5.0,4.0,4.5,0.9995130020361345
1646,9.6,push,5.0,5.0,5.0,1.0
1647,9.6,Not sure what this question means.  You can use the stack 'push' operation and the enqueue operation to detect palindromes.  ,5.0,5.0,5.0,0.9996967598899064
1648,9.6,"Enqueue is the queue equivalent of push, and dequeue is the queue equivalent to pop.",5.0,5.0,5.0,0.9997533815331443
1649,9.6,Push operation.,5.0,5.0,5.0,0.9997457886243014
1650,9.6,push,5.0,5.0,5.0,1.0
1651,9.6,push,5.0,5.0,5.0,1.0
1652,9.6,push,5.0,5.0,5.0,1.0
1653,9.6,push,5.0,5.0,5.0,1.0
1654,9.6,"that would be the push operation, if it put the item at the end of the list.",5.0,5.0,5.0,0.9997319036360958
1655,9.6,push,5.0,5.0,5.0,1.0
1656,9.6,push,5.0,5.0,5.0,1.0
1657,9.6,the Push method in the stack operations.,5.0,5.0,5.0,0.9996715884718028
1658,9.6,push,5.0,5.0,5.0,1.0
1659,9.6,enqueue corresponds with push dequeue corresponds with pop,5.0,4.0,4.5,0.9995596655012908
1660,9.6,"Push corresponds with enqueue, both very similarly place new elements into their stack or queue",5.0,5.0,5.0,0.9997494618356196
1661,9.6,FIFO: First in First out,0.0,3.0,1.5,0.9995817640727089
1662,9.6,push,5.0,5.0,5.0,1.0
1663,9.6,Push,5.0,5.0,5.0,0.9999488293999733
1664,9.6,push,5.0,5.0,5.0,1.0
1665,9.6,push,5.0,5.0,5.0,1.0
1666,9.6,push ,5.0,5.0,5.0,1.0
1694,10.1,A hierarchy of nodes that are sorted in a particular order.  Each node has a ancestor (except for the root) and children (except for the leaves).   ,3.0,5.0,4.0,0.9999842509191981
1695,10.1,A tree is a finite set of one or more nodes with a specially designated node called the root and the remaining nodes are partitioned into disjoint sets where each of these sets is a tree.,5.0,5.0,5.0,0.9999792067189306
1696,10.1,A tree is a finite set of one or more nodes such that: there is a specially designated node called the root.,4.0,5.0,4.5,0.99998532337997
1697,10.1,"A connected, undirected graph without cycles.",4.0,5.0,4.5,0.99995822327492
1698,10.1,"A data structure that contains a root, internal nodes and external nodes. Each node references another node by means of pointers (pass-by-reference). The root is the ""base"" of the tree, it has no parents. A ""leaf"" is a node at the end of the tree which points to NULL.",5.0,5.0,5.0,0.9999739146856399
1699,10.1,a tree is a series of nodes where each node has links to other nodes.,1.0,5.0,3.0,0.9999831677734333
1700,10.1,"an infinite set of nodes that have a root and descendants, and each addition is a leaf.",2.0,5.0,3.5,0.9999852037335594
1701,10.1,"A set of one or more nodes that are hierarchically organized, with one special â€œrootâ€ node.",3.0,5.0,4.0,0.9999873660111397
1702,10.1,A tree is a finite set of one or more nodes such that there is a specially designated node called the root. ,2.0,5.0,3.5,0.9999812883276488
1703,10.1,one or more nodes in a hierarchy starting with the root and branching off like a tree to subtrees ,5.0,5.0,5.0,0.9999707207364656
1704,10.1,A tree is a data structure where nodes are linked to each other in a hierarchical manner. ,2.0,5.0,3.5,0.9999750031442246
1705,10.1,a grouping of data in a parent to child structure,2.0,4.0,3.0,0.9999763015582005
1706,10.1,It is a list of numbers in a list made by comparing values of nodes already in the tree and adding to the appropriate spot. Its a list made up of nodes with left and right pointers.,1.0,5.0,3.0,0.9999536920090598
1707,10.1,"A tree is a branched data structure with nodes, and leaves... a special node called root has no parent node, but however like all other nodes can and does have 2 nodes that it links to, namely one on the right, and one on the left.",4.0,5.0,4.5,0.999986854878785
1708,10.1,"It organizes data in a nonlinear, hierarchical form, where items can have more than one successor.  Partitioned into a root node and subsets are general subtrees of the root. ",5.0,5.0,5.0,0.9999853347364185
1709,10.1,"A tree is a finite set of one or more nodes such that there is a specially designated node called the root. The remaining nodes are partitioned into n&gt;=0 disjoint sets T the n plus 1, where each element set is a tree.",5.0,5.0,5.0,0.9999798241524224
1710,10.1,A finite set of nodes that starts with the root and terminates with leaves.,3.0,5.0,4.0,0.9999150107328454
1711,10.1,"a set of data arranged with pointers. each element can have many pointers, but no two pointers point to the same element",1.0,4.0,2.5,0.9999609790513347
1712,10.1,"A Tree is a data structure with one or more data nodes, each of which contains some data. Each node itself can have a number of attached child nodes, creating the branched structure Trees are named for.",4.0,5.0,4.5,0.9999781731165552
1713,10.1,"a finite collection of nodes, where it starts with an element called the root, which has children, and its children have children until you get to the leaves which are the last elements and have to children",4.0,5.0,4.5,0.9999872865012648
1714,10.1,"A nonlinear, two-dimensional data structure.",0.0,4.0,2.0,0.999885596031782
1715,10.1,a finite set of one or more nodes such that there is a root node and all other nodes are split into trees of lesser value than the root,3.0,5.0,4.0,0.9999809128842576
1716,10.1,"A finite number of nodes such that there is one root node, each node has a certain number of children nodes, and each child is also a tree",5.0,5.0,5.0,0.999956478074945
1717,10.1,A type of data structure in which each element is attached to one or more elements directly beneath it. ,3.0,5.0,4.0,0.9999794449210607
1718,10.2,"Each level of a generation in the tree, some people do not count the root as a generation",4.0,4.0,4.0,0.9999432809554667
1719,10.2,"The height of a tree is in terms of the levels of its nodes such that, if  the tree is empty its height is 0 otherwise its height is equal to the maximum level of its nodes.",4.0,5.0,4.5,0.9999606482216407
1720,10.2,The height of a tree is the number of nodes on the longest path from the root to a leaf.,5.0,5.0,5.0,0.9999878645245336
1721,10.2,The number of nodes on the longest path from the root of the tree to a leaf.,5.0,5.0,5.0,0.9999896849164991
1722,10.2,Height = the number of times you must progress down the levels of a tree to reach a leaf of the greatest distance from the root.,5.0,5.0,5.0,0.9999601038159224
1723,10.2,the height of a tree is the length from the root to the furthest leaf,5.0,5.0,5.0,0.9999194517115068
1724,10.2,The height is the number of generations (levels) from the root.,4.0,5.0,4.5,0.999953861741972
1725,10.2,The height of a tree is the number of levels between the root and the leaf farthest away from it.,5.0,5.0,5.0,0.9999604893048454
1726,10.2,is the depth of its furthest leaf,4.0,5.0,4.5,0.9999708368603879
1727,10.2,the number of nodes from root to leaf,3.0,4.0,3.5,0.999939572634661
1728,10.2,the distance from the deepest leaf to the root,5.0,5.0,5.0,0.9999709275085134
1729,10.2,the number of generations or levels of a tree,4.0,5.0,4.5,0.9999601960360954
1730,10.2,"The intensity of the children. Say you begin with one node, Thats one height. Then you add two children to that node and then two children to each of those nodes and two children to each of THOSE nodes. Youre current height would be 4.",2.0,4.0,3.0,0.9999641920161659
1731,10.2,"the number of levels of a tree, like a tree can have at minimum a depth of 3 and at most a height of 8 for 8 nodes.",3.0,4.0,3.5,0.9998875367445675
1732,10.2,The number of nodes on the longest path from the root to the leaf.,5.0,5.0,5.0,0.9999900407229101
1733,10.2,The height of a tree is the number of nodes on the longes path from the root to a leaf.,5.0,5.0,5.0,0.9999878645245336
1734,10.2,is equal to the number of levels.  levels between the root node and the terminal nodes.,4.0,5.0,4.5,0.9999281364781377
1735,10.2,the number of generations or levels the tree has,4.0,5.0,4.5,0.9999613417029227
1736,10.2,"The height of a tree is the depth of its subtrees, that is, how many layers deep it is.",4.0,5.0,4.5,0.9999710493103248
1737,10.2,is the number of generations in the tree,4.0,5.0,4.5,0.9999689225798895
1738,10.2,The number of nodes on the longest path from the root to a leaf.,5.0,5.0,5.0,0.9999876851321459
1739,10.2,the number of distinct levels of separation,3.0,5.0,4.0,0.9999552067316375
1740,10.2,the height of a tree is how many levels of nodes that it has,4.0,5.0,4.5,0.9999512563490656
1741,10.2,The connections between elements are called branches. Trees are often called inverted trees because they are normally drawn with the root at the top.,0.0,3.0,1.5,0.9999488203223867
1742,10.3,A leaf is a child of a parent node that has no children nodes of its own.,5.0,5.0,5.0,0.9999530184736266
1743,10.3,A leaf is a node with no children.,5.0,5.0,5.0,0.9999466524658613
1744,10.3,A node with no children.,5.0,5.0,5.0,0.9999827862621168
1745,10.3,A tree node with no children.,5.0,5.0,5.0,0.999982934933588
1746,10.3,And end point of the tree... a node that does not have any children.,5.0,5.0,5.0,0.9999604515217229
1747,10.3,a node with no children.,5.0,5.0,5.0,0.9999754290292074
1748,10.3,A new item to the tree--a child,2.0,4.0,3.0,0.9999527730407757
1749,10.3,"A leaf is a node with children, it is a terminating node.",0.0,4.0,2.0,0.9999705955292686
1750,10.3,The node with degree 0.,3.0,5.0,4.0,0.999965857508548
1751,10.3,the node with degree 0,3.0,5.0,4.0,0.9999437198591348
1752,10.3,a leaf is a node with no children,5.0,5.0,5.0,0.9999140589565119
1753,10.3,the last child on any branch,4.0,5.0,4.5,0.9999332223097772
1754,10.3,The last value in the tree. A value with no children attatched. ,5.0,5.0,5.0,0.9999505472129541
1755,10.3,a node with no children.,5.0,5.0,5.0,0.9999754290292074
1756,10.3,A node with no children.,5.0,5.0,5.0,0.9999827862621168
1757,10.3,A leaf is a node with no children,5.0,5.0,5.0,0.9999328595287231
1758,10.3,a node with degree 0.  last node in the tree and furtherest away from the root.,3.0,5.0,4.0,0.9999401219656149
1759,10.3,an endpoint on a tree that contains no pointers or pointers that are set to null,4.0,5.0,4.5,0.9999376151437109
1760,10.3,A leaf is a node with no children.,5.0,5.0,5.0,0.9999466524658613
1761,10.3,an element in a tree that has no children ,5.0,5.0,5.0,0.9999326073009861
1762,10.3,A node with no children.,5.0,5.0,5.0,0.9999827862621168
1763,10.3,a leaf is a node that has no children nodes,5.0,5.0,5.0,0.9999510987642126
1764,10.3,a leaf is a node with no children,5.0,5.0,5.0,0.9999140589565119
1765,10.3,"The elements at the very bottom of an inverted tree (that is, those that have no elements below them) are called leaves.",5.0,5.0,5.0,0.9999155053775621
1766,10.4,"A tree data structure in which each done has at most two children, typical called left and right nodes.  The right node is usually greater than the left node and the parent node.",4.0,5.0,4.5,0.9999571966038565
1767,10.4,"A binary tree is a set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root. Each node can have no more than two children, a right and a left child.",5.0,5.0,5.0,0.9999646209140046
1768,10.4,"A set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root.  Each node has at most two children, the left child and the right child.",5.0,5.0,5.0,0.9999651341742462
1769,10.4,"A set of zero or more nodes, partitioned into a root node and two possibly empty sets that are binary trees. Thus, each node in a binary tree has at most two children, the left child and the right child.",5.0,5.0,5.0,0.999954390987157
1770,10.4,A tree in which each parent has a maximum of 2 children.,5.0,5.0,5.0,0.9999491458590114
1771,10.4,a tree where each node has at most 2 children.,5.0,5.0,5.0,0.9999374841739643
1772,10.4,a tree with up to two children or a right subtree and/or a left subtree,5.0,5.0,5.0,0.9999584115725201
1773,10.4,"A binary tree is a tree in which all nodes have a maximum of two degrees, or can only have two children each.",5.0,5.0,5.0,0.9999669114300185
1774,10.4,a binary tree is a tree data structure in which each node has at most two children.,5.0,5.0,5.0,0.9999488487985272
1775,10.4,"a tree with only 2 joints, left and right",4.0,5.0,4.5,0.9999487392498163
1776,10.4,A binary search tree is a tree that also has the condition that each node may have at maximum 2 children,4.0,5.0,4.5,0.9999507221626912
1777,10.4,a tree where each parent can have at max two children.,5.0,5.0,5.0,0.9999433603870439
1778,10.4,a list of numbers that are ordered compared to how they compare to the other numbers already added in the tree,1.0,3.0,2.0,0.9999409320900733
1779,10.4,a tree where each node can have at most 2 children.,5.0,5.0,5.0,0.9999458898872589
1780,10.4,"Starting at the root node, it branches off into one or two subsets that are binary subtrees of the root.  Each node has at most two children, the left child and the right child.",5.0,5.0,5.0,0.9999699874377868
1781,10.4,"A binary tree is a set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root. Each node has at most two children, the left child and the right child.",5.0,5.0,5.0,0.9999664771013379
1782,10.4,a tree that has a maximum of 2 children per node,5.0,5.0,5.0,0.9999734426569409
1783,10.4,a tree with elements that can contain at most two pointers,5.0,5.0,5.0,0.9999513249881076
1784,10.4,A binary tree can have only two children for each node.,5.0,5.0,5.0,0.9999647635621112
1785,10.4,a tree where every parent has only two children,4.0,5.0,4.5,0.9999581354770928
1786,10.4,A tree where every node has no more than two children,5.0,5.0,5.0,0.9999755600021569
1787,10.4,"a binary tree is a special search tree where each node has either 2, 1, or 0 children",4.0,5.0,4.5,0.9999153923815313
1788,10.4,a binary tree is a special type of tree where each node can only have at maximum 2 children,5.0,5.0,5.0,0.9999311901762383
1789,10.4,A binary tree is a special type of inverted tree in which each element has only two branches below it.,4.0,5.0,4.5,0.9999686389551777
1790,10.5,"A tree data structure where each node has a value, where the total order is defined on these values.  the left subtree contains only values less than the parent node, and vice versa for the right subtree.",5.0,5.0,5.0,0.9999627916151717
1791,10.5,A binary search tree is a binary tree where the value in any node 'n' is greater than the value in every node in n's left subtree but less than every node in n's right subtree.,5.0,5.0,5.0,0.9999811414212291
1792,10.5,"A binary tree where the value in any node n is greater than the value in every node in n's left subtree, but less than the value of every node in n's right subtree.",5.0,5.0,5.0,0.9999822860754491
1793,10.5,"A binary tree where the search key in any node n is greater than the search key in any node in n's left subtree, but less than the search key in any node in n's right subtree.",5.0,5.0,5.0,0.9999688959038394
1794,10.5,"A tree which is split based on values. This makes it very easy to search. One can compare the desired value to the root, and if the root is greater than, we search the left side of the tree, if it is less than, we search the right side... and do the same thing recursively. ",5.0,5.0,5.0,0.9999794541688574
1795,10.5,a tree where each node has at most two nodes and the node on the left is less than the root and the node on the right is greater than the root.,4.0,5.0,4.5,0.9999809206855214
1796,10.5,a special binary tree that has a rule that all the subtrees on the right are smaller than the node value and all the subtrees on the left are larger than the node value,5.0,3.0,4.0,0.9999848104841854
1797,10.5,"Binary search trees are similar to binary trees, but have been implemented to organize data in a specific way for later searching.",3.0,4.0,3.5,0.999925843830747
1798,10.5,"it is a binary tree where each node has a value, a total order is defined on these values, the left subtree of a node contains only values less than the node's value, and the right subtree of a node contains only values greater than or equal to the node's value.",5.0,5.0,5.0,0.9999691178775273
1799,10.5,A binary tree with the data organized in a specific arangment,2.0,3.0,2.5,0.9999487291801427
1800,10.5,"A binary search tree is a tree that also has the condition that each node may have at maximum 2 children and where the input data is compared to the data in the tree starting with the root. If the value is smaller than the root it traverses left, if it is larger it traverses right until it becomes a leaf.",4.0,5.0,4.5,0.9999899428943134
1801,10.5,a binary tree in which the data is in order from left to right.,4.0,4.0,4.0,0.9999481028609575
1802,10.5,a tree that is set up so that it can be easily searched for numbers based on the location compared to the previous nodes. ,3.0,4.0,3.5,0.9999677436434321
1803,10.5,"a binary tree where the children are ordered such that the right side is greater than the current node, and the left is less than or equal the current node.",5.0,5.0,5.0,0.9999754964696091
1804,10.5,"A binary tree where the value in any node n is greater than the value in every node n's left subtree, but less than every value in n's right subtree.",5.0,5.0,5.0,0.9999835397121328
1805,10.5,A binary search tree is a finite set of nodes that is either empty or consits of a root and two disjoint binary trees call the left and right subtrees.,1.0,4.0,2.5,0.9999619316967576
1806,10.5,it is similar to a binary tree.  The keys in a nonempty left subtree (right subtree) are smaller (larger) than the key in the root of subtree.  the values in all nodes in the left subtree of a node are less than             the node value  the values in all nodes in the right subtree of a node are greater    than the node values  ,5.0,5.0,5.0,0.999972857372337
1807,10.5,"a set of numbers arranged by links. each node can contain two pointers to other elements. each node to the left of the parent is smaller and each node to the right is larger. recursive implementation implies that if traversed in order, the output would be sorted",5.0,4.0,4.5,0.9999630420166588
1808,10.5,"A binary search tree is a special binary tree arranged such that every left child node contains a value less than its parent, and every right child node contains a value greater its parent.",5.0,5.0,5.0,0.999977101370282
1809,10.5,"a binary tree with a special organization of data. where the left child of the element is less than it, and the right child is larger than it.",5.0,5.0,5.0,0.9999868368884998
1810,10.5,A tree in which the smaller values are located on the left of a parent node and the larger values are located on the right of the parent node.,5.0,5.0,5.0,0.9999545575293967
1811,10.5,"a binary search tree is a special tree in which each node has at most two children, labeled left child and right child",1.0,4.0,2.5,0.9999626572171939
1812,10.5,"it is a binary tree where each node has a unique key, the left child of a node has only values less than that node, and the right child of each node has higher values than that node.",5.0,5.0,5.0,0.999906707114206
1813,10.5,"Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays.",2.0,3.0,2.5,0.99992751499001
1814,10.6,"For every node in the binary tree we first visit its left sub-tree (if its there) and then visit the parent node itself, and then the right sub-tree (if its there).",5.0,5.0,5.0,0.9999799610691155
1815,10.6,The inorder traversal of a binary tree visits the node of a binary tree in order according to their data values.,2.0,3.0,2.5,0.9999476342799771
1816,10.6,Traverses the binary tree in inorder.  It lets you visit the nodes in order according to their data values.,2.0,4.0,3.0,0.9999679562117235
1817,10.6,Its used to visit nodes of a binary search tree in a search key order.,3.0,4.0,3.5,0.9999188829640386
1818,10.6,(Left side of tree) (Root) (Right side of tree),5.0,5.0,5.0,0.9997437340994194
1819,10.6,printing a tree in order from least to greatest. This done by going as far left down the tree as possible and printing the parent and then right tree. Then move up the tree.,5.0,5.0,5.0,0.9999682354069005
1820,10.6,"The in order is to go from left,root,right",5.0,5.0,5.0,0.9998946849576558
1821,10.6,"Inorder traversal of a binary tree will retrieve start at the furthest left hand leaf and checks it, itâ€™s parent, and itâ€™s right side sibling, then it goes up a level and repeats until it gets to the root.",4.0,5.0,4.5,0.9999716245961345
1822,10.6,traverse the left subtree. visit the root. traverse the right subtree.,5.0,5.0,5.0,0.9999441350112905
1823,10.6,postorder,0.0,3.0,1.5,0.999621981919726
1824,10.6,in order starts with the root then does right child then left child recursively,0.0,3.0,1.5,0.9999600697326302
1825,10.6,Left Child -&gt; Parent -&gt; Right Child,5.0,5.0,5.0,0.9997293801926236
1826,10.6,it goes from lowest to highest inside of the tree,1.0,3.0,2.0,0.9999684246941616
1827,10.6,"starting by displaying the node furthest to the right, then  the node, then the node on the right, in recursive order.",3.0,5.0,4.0,0.999980627591575
1828,10.6,It travels left to right,3.0,4.0,3.5,0.9999336934282042
1829,10.6,void inorder(ptNode ptr) { if (ptr) { inorder (ptr-&gt;left); cout&lt;&lt;ptr-&gt;data; inorder(ptr-&gt;right); } },5.0,5.0,5.0,0.9998959453217885
1830,10.6,"the root is in the middle.  The left subtree is traversed first, then the root, and finally the right subtree.",5.0,5.0,5.0,0.9999754466955934
1831,10.6,"a traversal that visits the left branch first, then the parent node, then the right branch, recursively.",5.0,5.0,5.0,0.9999811700941478
1832,10.6,"Inorder traversal visits the left branch of a node (all the way to it's deepest left-most leaf) before visiting the node itself. After visiting the entire left branch and the node, it visits the node's right branch following the same pattern of left child, node, right child.",5.0,5.0,5.0,0.9999807185494779
1833,10.6,left middle right,5.0,5.0,5.0,0.9997819974171606
1834,10.6,"You traverse all the nodes to the left, then visit the root, then traverse all the nodes on the right.",5.0,5.0,5.0,0.9999794894432054
1835,10.6,"you would go to the furthest down left most node, then to the root then to the right (if left and right exist) then you would return one node previous and do the same until you reached the root, then go to the furthest down left most node on the right side of the root and continue this process",5.0,5.0,5.0,0.9999446265029229
1836,10.6,"it means that you traverse one subtree of a node, then look at the node itself before traversing the other subtree of the node",4.0,4.0,4.0,0.9999667780614626
1837,10.6,"Level order traversal is a traversal method by which levels are visited successively starting with level 0 (the root node), and nodes are visited from left to right on each level, with Push and Pop methods. ",0.0,4.0,2.0,0.9999587318988284
1838,10.7,This is on the runtime order of log(n) where n is the number of nodes in the binary tree.,5.0,5.0,5.0,0.9999514943932177
1839,10.7,In a binary search tree of size 'n' it takes log(n) comparisons to find a specified element.,5.0,5.0,5.0,0.9999395082824104
1840,10.7,n-1/2 is the algorithm to compare and find an element. ,0.0,4.0,2.0,0.9999383862047078
1841,10.7,At most its equivalent to the height of the tree.,5.0,5.0,5.0,0.9999597573222988
1842,10.7,Log(n),5.0,5.0,5.0,0.9998124324677146
1843,10.7,O(log n),5.0,5.0,5.0,0.9998689648017788
1844,10.7,Depends on what half of the tree and the levels you have.,3.0,4.0,3.5,0.9999279575646614
1845,10.7,O(log n) in balanced trees,5.0,5.0,5.0,0.9999196813379073
1846,10.7,n-1,2.0,3.0,2.5,0.9995353932474931
1847,10.7,log(n),5.0,5.0,5.0,0.9998137991477475
1848,10.7,O(nlog(n)),0.0,5.0,2.5,0.9998032311265834
1849,10.7,nLog(n),0.0,4.0,2.0,0.9997677759038106
1850,10.7,logn,5.0,5.0,5.0,0.9995353932474931
1851,10.7,"at the minimum log(n)/log(2), at the maximum N searches, where N is the number of nodes.",4.0,5.0,4.5,0.999953314168098
1852,10.7,O(n),2.0,4.0,3.0,0.9998827540852533
1853,10.7,It takes at most 3 comparisons to find and element in a binary search tree,0.0,3.0,1.5,0.999927445324503
1854,10.7,log (n)   where n equals the number of nodes.,5.0,5.0,5.0,0.9999548449122989
1855,10.7,it takes as many comparisons as the number of levels of the binary search tree. it only compares one number at each level,5.0,5.0,5.0,0.9999626000894831
1856,10.7,At most it takes one less comparisons than the tree's height. In big-O notation it takes O(log n) comparisons if the tree is balanced.,5.0,5.0,5.0,0.9999524243086914
1857,10.7,O(log n),5.0,5.0,5.0,0.9998689648017788
1858,10.7,log n comparisons,5.0,5.0,5.0,0.9998882137554133
1859,10.7,(n^k)-1   where k is the height of the tree,0.0,3.0,1.5,0.9999571148937939
1860,10.7,"it takes h comparisons, where h is the height of the tree",5.0,5.0,5.0,0.9999542977017948
1861,10.7,2 way key comparison ,0.0,2.0,1.0,0.9999178297624894
1862,11.1,"The name of the class file, the parameters it must take to perform its function.  Also a brief description of what the class does.",1.5,3.75,2.625,0.999857983981865
1863,11.1,"access specifiers and functions, oftentimes a constructor.",3.0,3.0,3.0,0.9997756568451154
1864,11.1,"The elements typically included in a class definition are the function prototypes, usually declared public, and the data members used in the class, which are usually declared private.",5.0,5.0,5.0,0.9999135984839688
1865,11.1,"Class is user defined.  It contains members, data and functions.  The keyword class is used and includes brackets ({})",2.5,5.0,3.75,0.999894859263621
1866,11.1,Member functions and data members.,5.0,5.0,5.0,0.9999129336348552
1867,11.1,the functions and variables used when the object is defined for the class.,5.0,3.0,4.0,0.9998964676528554
1868,11.1,"Data members, functions and function definitions, variables.",5.0,5.0,5.0,0.9998822400022368
1869,11.1,return type and input parameters,1.5,2.5,2.0,0.9999228327758808
1870,11.1,Constructor Data members Methods,5.0,4.0,4.5,0.9998984037893884
1871,11.1,"Function members and member attributes, or in other words, the class variables and functions.",5.0,5.0,5.0,0.9999233926334571
1872,11.1,"The elements that are included in a class definition is the access-modifier, data types, variables, and function signatures.",4.0,4.0,4.0,0.9998766271960642
1873,11.1,The variables and function prototypes.,5.0,3.0,4.0,0.9998465108269328
1874,11.1,public and private variables and initiations of functions included in the class.,4.5,2.5,3.5,0.99981961247005
1875,11.1,The return value and the accepted value.,1.5,1.25,1.375,0.9999184727065462
1876,11.1,"A class definition typically includes the class name, the classes constructor(s), and any extra functions and class variables.",5.0,2.5,3.75,0.999908580486065
1877,11.1,"Parameters and their type, Class name, and return type, and the code to be executed in the class.",2.0,3.75,2.875,0.9999364766267282
1878,11.1,"data members, class variables, and functions",5.0,5.0,5.0,0.9999205561022965
1879,11.1,"Constructor, functions, and variables native to the class.",5.0,3.0,4.0,0.9998623446232743
1880,11.1,functions and data members,5.0,5.0,5.0,0.9999205600694575
1881,11.1,data members and function definitions,5.0,5.0,5.0,0.9999147679662678
1882,11.1,member functions and data members,5.0,5.0,5.0,0.9999076513068854
1883,11.1,"constructor, and function definitions.",3.5,2.5,3.0,0.9998899070480132
1884,11.1,class name data of class definition of functions and methods,5.0,3.75,4.375,0.9999142348112576
1885,11.1,"A class definition includes the definitions of the class' constructor(s) and any public or private functions. Of course, it also #includes the class header and any necessary C libraries",3.0,2.5,2.75,0.9998916470608419
1886,11.1,"Class name, {}, semicoln at the end of the defination, private and bublic followed by "": """,2.5,2.5,2.5,0.9998462712884899
1887,11.1,"a constructor, private and public variables, and function prototypes",5.0,2.5,3.75,0.9998586181443382
1888,11.1,"Data variables and Functions, Data members",5.0,5.0,5.0,0.9998725516429718
1889,11.1,class definitions include the name of the class and type of parameters,1.5,3.75,2.625,0.99985821565151
1890,11.1,"class variables, class function prototypes",5.0,3.75,4.375,0.9998746493972563
1891,11.1,input  & return type elements,1.5,3.0,2.25,0.9998603551687129
1892,11.2,Public and private specifiers.,5.0,5.0,5.0,0.9999370157968192
1893,11.2,"Public, Private, Restricted",4.5,4.75,4.625,0.999900855371244
1894,11.2,The access specifiers are public and private.,5.0,5.0,5.0,0.9999312757459204
1895,11.2,public private protected,5.0,4.75,4.875,0.9998106175548616
1896,11.2,Public or Private.,5.0,5.0,5.0,0.999918440984228
1897,11.2,public: the function or variable can be used outside the class private: the function or variable can only be used with the class,5.0,5.0,5.0,0.9996314227199155
1898,11.2,Public and Private,5.0,5.0,5.0,0.9999412088990989
1899,11.2,public private and protected,5.0,4.75,4.875,0.9998819212917354
1900,11.2,Public Private,5.0,5.0,5.0,0.9998272091506349
1901,11.2,"Private, public, protected",5.0,4.75,4.875,0.9998479898721913
1902,11.2,The access-specifiers that can be used in a C++ class definition is private and public.,5.0,5.0,5.0,0.9998992609358044
1903,11.2,public and private.,5.0,5.0,5.0,0.9999542242990332
1904,11.2,"static, long, unsigned",0.0,1.25,0.625,0.9997277536390125
1905,11.2,"Private, Public, Protected, or Friend.",5.0,4.75,4.875,0.999919808481394
1906,11.2,"A C++ class definition may include access-specifiers public, private, and static.",4.0,5.0,4.5,0.999871755886562
1907,11.2,"local, global, local-variable, function specific",1.5,2.5,2.0,0.9998772792713057
1908,11.2,"public, private",5.0,5.0,5.0,0.9998035409217072
1909,11.2,"Public, protected, and private.",5.0,4.75,4.875,0.99989155580925
1910,11.2,"private, public",5.0,5.0,5.0,0.9997333061290837
1911,11.2,public - can be accessed by any of the program  private - can only be accessed by the class functions themselves and no outside functions or calls,5.0,5.0,5.0,0.9998271840594428
1912,11.2,"public , private, protected",5.0,5.0,5.0,0.9998200033198643
1913,11.2,public and private,5.0,5.0,5.0,0.999921495598176
1914,11.2,"public, private, protected",5.0,4.75,4.875,0.9998200033198643
1915,11.2,"functions and data members can be given access-specifications of public, private, and friend. public access is given to any functions or members not given specific access rights.",5.0,4.75,4.875,0.9999262838646616
1916,11.2,data member or data functions are access specifiers,0.0,1.25,0.625,0.9998928800847664
1917,11.2,public or private,5.0,5.0,5.0,0.9998936741690536
1918,11.2,public and private,5.0,5.0,5.0,0.999921495598176
1919,11.2,public and private,5.0,5.0,5.0,0.999921495598176
1920,11.2,"public - can be accessed from outside the class private - accessible only from inside the class, not inherited protected - accessible only from inside the class, inherited",5.0,4.75,4.875,0.9998563999167015
1921,11.2,public private protected,5.0,5.0,5.0,0.9998106175548616
1922,11.3,ie. GradeBook myGradeBook();  call upon the class and then give it a name like shown,0.0,2.5,1.25,0.9999148248266408
1923,11.3,They are initialized as a named instance of the template formed by the class. This named instance can then be modified to be different from the class that it was created from.,3.0,3.75,3.375,0.9997671225094223
1924,11.3,not answered,0.0,0.0,0.0,0.9995603538385917
1925,11.3,Objects are initialized by a value given.  When an object is defined for a certain task.  ,2.0,2.5,2.25,0.9998660873444998
1926,11.3,"They are initialized with a "" . "" (dot) between the constructor and the object being created.",0.0,4.5,2.25,0.9999039869954203
1927,11.3,objectname classname();  to call a function from the class:  objectname.funciton();,0.0,2.5,1.25,0.9999519295247649
1928,11.3,"If the object refers to a class, the constructor(s) will initialize the objects based on return type and parameters passed. Compiler will auto-create one if one is not provided.",5.0,5.0,5.0,0.9999342022710976
1929,11.3,classname objectname(input parameters);,3.0,2.5,2.75,0.999932459109902
1930,11.3,When the class is called by the Constructor,2.0,5.0,3.5,0.9998995580132833
1931,11.3,"Constructors; default when not provided by user, or programmer specified constructors.",5.0,5.0,5.0,0.9999108297104928
1932,11.3,Objects are usually initialized at the beginning of the program and are initialized usually in the main function. They are initialized after the class's name.,1.0,3.75,2.375,0.9998764397020964
1933,11.3,"&lt;variable type&gt; &lt;variable name&gt;; or, if you want to initialize a variable to a certain value, &lt;variable type&gt; &lt;variable name&gt; = &lt;value&gt;;",1.0,3.75,2.375,0.9997702896811824
1934,11.3,"variables are set to a given value, or 0 if none is given.",1.0,1.25,1.125,0.9998671204170777
1935,11.3,"When the object is initialized, its constructor is called (whether one is provided or c++ assigns a default constructor).",5.0,5.0,5.0,0.999941077079182
1936,11.3,"Objects are initialized essentially as copies of the corresponding classes, complete with their own separate variables.",2.0,3.0,2.5,0.9999442756026234
1937,11.3,"If you had a class Gradebook, you would initialize it in your main function by use of a constructor in the Gradebook class.  If no constructor is specified or found, c++ will use a default one with no parameters.  Gradebook myGradebook;  In this bit of code, the class Gradebook has been initialized as object myGradebook.",5.0,5.0,5.0,0.9999356608720325
1938,11.3,objects are initialized by stating the classname first then assigning a name to the object. Within the object's ( ) is a place where it can be initialized.,3.0,3.75,3.375,0.9999193561903414
1939,11.3,They are initialized with a constructor.,5.0,5.0,5.0,0.9999277330574472
1940,11.3,"The value is specified after declaration,  It can initialized anywhere between the declaration and the corresponding }.",1.0,3.75,2.375,0.9999565164698277
1941,11.3,"with the default constructor for that object in its class.  if no constructor is specified, it uses the default system constructor.",4.0,5.0,4.5,0.9999135087157865
1942,11.3,initialized using the same name as the class,1.0,4.0,2.5,0.999786472444505
1943,11.3,they are initialized to a value dependent on the compiler,1.0,1.25,1.125,0.9998752518045556
1944,11.3,memory is allocated in accordance with their type and initialization input.,1.0,2.5,1.75,0.9999409412079967
1945,11.3,Objects are assigned a space in memory when they are created. the name given to the object points to the memory address where the objects data resides.,1.0,1.25,1.125,0.999875482725323
1946,11.3,using constructor,5.0,5.0,5.0,0.9998757094921032
1947,11.3,by giving them a value,2.0,1.25,1.625,0.9998141994562888
1948,11.3,"By declaring the class first, the name of the variable, and then any variables that need to be put in the constructor.  Ex. Class myClass(x, y)",5.0,5.0,5.0,0.9999188786339963
1949,11.3,"objects are initialized by giving the object a type, name, and initial value",1.0,3.75,2.375,0.9998026597684122
1950,11.3,they are initialized to 0,1.0,1.25,1.125,0.9998222094969204
1951,11.3,"obj. are initialized by the variables that call them, when they are created within a class.   e.i. classname objectname etc. ",1.0,3.75,2.375,0.9999290535569811
1952,11.4,"Name of the function, parameters it must receive in order to perform and a return type.",5.0,5.0,5.0,0.9999748379326583
1953,11.4,a function signature is the elements that make it unique such as the variables it calls for and also I suppose this includes the program it is in.,3.5,4.0,3.75,0.9999604330221666
1954,11.4,"A function signature is the return type of a function, its name, and the number and type of its parameters.",5.0,5.0,5.0,0.99995264920782
1955,11.4,function prototype that contains functions and data members.,1.0,5.0,3.0,0.9999710997008601
1956,11.4,A function signature is a declaration of the function that includes the parameter types and the number of parameters.,5.0,5.0,5.0,0.9999756650868274
1957,11.4,the declaration of the function.,2.0,3.0,2.5,0.9999744095581375
1958,11.4,"Includes the name, accepted parameters, and return type.",5.0,5.0,5.0,0.9999734940885645
1959,11.4,its return type and its input parameters,5.0,5.0,5.0,0.9999399226010603
1960,11.4,Contains the function name and its paramaters.  The return type is not included,5.0,5.0,5.0,0.9999709425436544
1961,11.4,"Return type, function name, and the parameter types",5.0,5.0,5.0,0.9999311718470593
1962,11.4,The function signature tells what the function parameters and includes all the function calls,2.5,5.0,3.75,0.9999645468213443
1963,11.4,"The function's name, as well as what it returns and what it accepts.",5.0,5.0,5.0,0.9999733201185054
1964,11.4,the body of the function that holds all the actual code,1.0,2.5,1.75,0.9999650445249021
1965,11.4,A function signature is the return type and accepted pass value type it takes,3.0,4.0,3.5,0.9999713971033225
1966,11.4,A function signature specifies the name and input variables of a function.,5.0,5.0,5.0,0.9999674949348244
1967,11.4,A function signature is the function's parameters and their type and the name of the function.  The return type is not a part of the function signature.,5.0,5.0,5.0,0.9999734781954742
1968,11.4,the name of the function and what it accepts/ returns,5.0,5.0,5.0,0.9999486966380637
1969,11.4,"the unique identifier of a function, which includes input variables along with the function name, but excludes the output type.",5.0,4.0,4.5,0.9999717156119325
1970,11.4,"The order, number, and type of data items included inside the function parameters.",4.5,5.0,4.75,0.9999747562446871
1971,11.4,"its the scope, type, and parameters of that function that give it it's properties and defines it against other functions.",5.0,5.0,5.0,0.999974957433653
1972,11.4,"is the name of the fuction, return type, and parameters that are being used",5.0,5.0,5.0,0.9999773943761174
1973,11.4,"a function signature should include the name of the function, parameters, and a body.",2.5,5.0,3.75,0.9999665796091197
1974,11.4,the name of the function and the arguments passed to that function,5.0,5.0,5.0,0.9999793088633722
1975,11.4,"A function signature, used in a function's prototype, is the set of object types it take in as parameters, with or without names given for the objects.",5.0,5.0,5.0,0.9999554443083247
1976,11.4,function name and parameter are called function signature.,5.0,5.0,5.0,0.9999726185459399
1977,11.4,fuction name and parameters,5.0,5.0,5.0,0.9999075772766675
1978,11.4,"The parameters needed, the return type, and name of the function.",5.0,5.0,5.0,0.9999358824203486
1979,11.4,"the signature of a function includes the name of the function, the number and types of parameters, and the return type",5.0,5.0,5.0,0.9999736177383162
1980,11.4,"It is what uniquely separates overloaded functions. It includes the return type, and the parameter list of the function.",4.5,5.0,4.75,0.9999724167044068
1981,11.4,"function sig is, is what is the class recognizes as the main function, or rather its specification ",0.0,3.75,1.875,0.9999672840094255
1982,11.5,A function that calls upon it self to solve a problem.  Each time it calls upon it self it splits up a problem into a simplier form until it reaches a 'base case' which is the most simplest form of the problem.,5.0,5.0,5.0,0.9999136576242706
1983,11.5,A function that calls itself to perform an opperation such as a factorial recursive function.,5.0,5.0,5.0,0.9999705500966475
1984,11.5,not answered,0.0,0.0,0.0,0.9995603538385917
1985,11.5,A base case that calls upon itself until the problem becomes smaller and terminates.,2.5,5.0,3.75,0.9999684298885114
1986,11.5,It's a function that calls itself. It runs multiple times until the base case is reached.,5.0,5.0,5.0,0.9999004148666473
1987,11.5,a function that calls itself untill it reaches a base case.,5.0,5.0,5.0,0.9999753421319217
1988,11.5,"A function that calls itself. Each time it does, it must get smaller, and eventually MUST converge to a base case, otherwise you can start an infinite loop.",5.0,5.0,5.0,0.9999329274683647
1989,11.5,a function that calls itself until a base case is met,5.0,5.0,5.0,0.9999120519057298
1990,11.5,A function that calls itself. With each function call the problem is diminished.,5.0,5.0,5.0,0.9999566122161951
1991,11.5,A function that calls itself to perform a certain task,5.0,5.0,5.0,0.999956466537563
1992,11.5,A recursive function is a function that calls itself. Usually called the base case. If the base case is not correct it causes a infinite loop.,5.0,5.0,5.0,0.9999559035174994
1993,11.5,"A function that calls itself, in order to solve a problem.",5.0,5.0,5.0,0.9999454170610348
1994,11.5,"a function that calls itself over and over until it finds the simplest form of solution, or the base case.",5.0,5.0,5.0,0.9999271770360509
1995,11.5,"A recursive function is a function that calls itself repeatedly until a base case is achieved. The fundamental idea is to break one large problem into a series of smaller, similar problems.",5.0,5.0,5.0,0.9999685530064436
1996,11.5,"A recursive function typically simplifies a problem by calling itself, until arriving at a base case, at which it recursively returns a solution.",5.0,5.0,5.0,0.9999560880424996
1997,11.5,"A recursive function is a function that breaks down a large problem into two or more smaller problems and calls itself to solve those smaller problems until a base case or terminating point is reached.  At the base case, a definite answer is called and the function no longer recurses, but unwinds itself back through function calls to determine the answer to the original large problem.",5.0,4.0,4.5,0.999949263219238
1998,11.5,a function that calls itself into a loop with a base case for a loop exit.,2.5,5.0,3.75,0.9999153158856676
1999,11.5,a function that calls itself until the base cases are met.,5.0,5.0,5.0,0.9999245273343803
2000,11.5,A recursive function only knows how to solve base cases  A recursive function calls itself directly or indirectly until a base case is reached.,5.0,5.0,5.0,0.9999760127374842
2001,11.5,a function that calls on itself and uses a base case to stop the recursion,5.0,5.0,5.0,0.9999236735469588
2002,11.5,"a function that calls itself, and which eaach calls get closer and close to the base case.",5.0,5.0,5.0,0.999956936005516
2003,11.5,A function that divides and conquers a problem.  There is a base case that will eventually be reached.  The function calls itself over and over until the base case is satisfied.,5.0,5.0,5.0,0.9999285541763162
2004,11.5,a function that calls itself in the definition code,5.0,5.0,5.0,0.9999506334257048
2005,11.5,A recursive function solves a problem by repeatedly calling itself. the initial problem is broken into successively smaller parts until a much simpler base case is reached. the solutions to each piece of the problem are then returned a step at a time.,5.0,5.0,5.0,0.9999386186482606
2006,11.5,"It invoke by itself again ana again, unless it reach bas case",4.0,5.0,4.5,0.9998323340883499
2007,11.5,"a function that solves a problem by dividing the problem into smaller problems, by calling its self again and again, until a base case is reached.",5.0,5.0,5.0,0.9999285446598911
2008,11.5,"A function that calls itself over and over again till a base case is reached, then it returns back to the original function.",5.0,5.0,5.0,0.999924962226265
2009,11.5,"a recursive function is a function that during execution, calls itself over and over until a base case is reached",5.0,5.0,5.0,0.9999507017324832
2010,11.5,A function that calls itself. Usually used to split a problem into several smaller problems of the same type.,5.0,5.0,5.0,0.9999524782434664
2011,11.5,function that calls it self till the base case is met ,5.0,5.0,5.0,0.9998940193824788
2012,11.6,"Iteration, performers  a series of checks and loops.",5.0,5.0,5.0,0.9999373503655671
2013,11.6,The alternative method is to use loops in the program instead of a function which calls itself. ,5.0,2.5,3.75,0.9999198237625097
2014,11.6,An alternative to solving a problem using recursive functions is to solve the problem using iteration.,5.0,5.0,5.0,0.9999468213461398
2015,11.6,"Iteration, this would be more efficient and has repetition structure.",5.0,5.0,5.0,0.9999179992015262
2016,11.6,One can use iteration or by using a simple while/for loop.,5.0,5.0,5.0,0.9998857322772978
2017,11.6,iteration,5.0,5.0,5.0,0.9997649044439751
2018,11.6,"Iteration. A while loop or a for loop will be able to accomplish the same desired outcome... It may be faster than recursion, but could also be harder to understand.",5.0,5.0,5.0,0.999916837747459
2019,11.6,you can also solve the problem iteratively,5.0,5.0,5.0,0.9998987706881606
2020,11.6,iterative,5.0,5.0,5.0,0.9997649044439751
2021,11.6,Using iteration loops.,5.0,5.0,5.0,0.9999790222600012
2022,11.6,Another alternative way to solve a problem instead of using recursive functions is by using iteration.,5.0,5.0,5.0,0.9999454581223907
2023,11.6,"A recursive function can often be solved using an iterative function, which runs faster, but is often more complicated.",5.0,5.0,5.0,0.9999043407943301
2024,11.6,iteration,5.0,5.0,5.0,0.9997649044439751
2025,11.6,Any recursive function can be solved using an iterative method.,5.0,5.0,5.0,0.9999269429612208
2026,11.6,"Many recursive solutions may also be solved with looping control statements, such as while, for, do-while, etc.",5.0,3.0,4.0,0.9999149623866916
2027,11.6,"Using an iterative function, which repeats a specified operation or set of operations until a terminating point or base case is reached.  ",5.0,5.0,5.0,0.9998972360700915
2028,11.6,iteratively,5.0,5.0,5.0,0.9997649044439751
2029,11.6,using an Iterative calls,5.0,5.0,5.0,0.9999677036260526
2030,11.6,Iteration.,5.0,5.0,5.0,0.9999670438488432
2031,11.6,iteration is the alternative way to solve a problem,5.0,5.0,5.0,0.9999100743647389
2032,11.6,using an iterative solution instead,5.0,5.0,5.0,0.9999163791471424
2033,11.6,"Using an iterative solution.  For, while, or do while loop.",5.0,5.0,5.0,0.9998672787185549
2034,11.6,the alternative way to solve a problem that could be solved using recursion is iteration.,5.0,5.0,5.0,0.9999317153268586
2035,11.6,"Any problem solved recursively could be solved with an iterative function. Iterative replacements for recursive functions may be more difficult to program, but often lead to more efficient solutions to a problem. ",5.0,5.0,5.0,0.9999169958779184
2036,11.6,by iteration,5.0,5.0,5.0,0.9999579980631603
2037,11.6,"itteration, like a for loop, a while loop, or a do while loop",5.0,5.0,5.0,0.999797884981787
2038,11.6,Iteration by using loops,5.0,5.0,5.0,0.999961979619359
2039,11.6,iterative functions,5.0,5.0,5.0,0.9997813547192985
2040,11.6,iteration,5.0,5.0,5.0,0.9997649044439751
2041,11.6,"the alt, way is to use a functions parameter in a call ""to"" function. ",2.5,2.5,2.5,0.999850311303107
2042,11.7,The array that is declared static retains its modified elements so once it is called upon again the latest elements are modified again.  An array that is not declared static will keep its original elements.,5.0,4.5,4.75,0.9999805948527338
2043,11.7,A static array only has a specific size and it cannot grow. Also static arrays cannot be accessed outside the program which created it.,2.0,3.75,2.875,0.9999480953181625
2044,11.7,Arrays declared as static are not created and initialized when a function is called and destroyed when the function terminates.,5.0,5.0,5.0,0.9999659168514113
2045,11.7,Static can be initialized and non-static cannot in C++.,1.0,4.0,2.5,0.9999505545422571
2046,11.7,An array declared static remains the same throughout the execution of the program.,0.5,4.0,2.25,0.9999605931111554
2047,11.7,a static array will be called only once. once it has been declared the complier will ignore the static line if it comes to it again.,3.5,5.0,4.25,0.9999604202720157
2048,11.7,"The static array will be available to the whole of the program, whereas an array that is not static is only available within the scope in which it is declared.   //pass-by-reference???",3.5,3.75,3.625,0.9999648117346451
2049,11.7,a static array has a predetermined size and that size cannot be altered,2.0,3.75,2.875,0.9999552049742428
2050,11.7,Arrays declared static can not be changed.  One not declared static can be altered.,0.5,3.75,2.125,0.9999154688338269
2051,11.7,"an array that is declared as static will retain the values stored in it's elements between function calls, and will not reinitialize them to default values.",5.0,4.0,4.5,0.9999870813064031
2052,11.7,An array that is declared static causes anything that is not initialized to be set to 0.,1.0,3.75,2.375,0.999977764104788
2053,11.7,A static array will have a null character at the end of the array.,2.5,2.5,2.5,0.9999157540241138
2054,11.7,static arrays cannot be changed while normal arrays can be changed,0.5,3.75,2.125,0.9998948050865344
2055,11.7,An array they is declared as static can be accessed outside of the method it was declared without passing it as an argument to other functions in the same class.,3.0,3.0,3.0,0.9999696578820687
2056,11.7,"A static array has class scope, allowing it to remain where other arrays might be recycled.",5.0,3.25,4.125,0.999971371371264
2057,11.7,An array that is static does not change or uninitialize if called later unless explicitly acted upon.  It does not terminate or change across objects.  An automatic local array will be cleared and uninitialized if called later outside of it's specific scope.,5.0,4.5,4.75,0.9999666113603193
2058,11.7,"one declared as static is one that is already defined. The program knows the length and the array from the start, whereas non-static arrays are declared or assigned later.",2.0,3.75,2.875,0.9999737564096298
2059,11.7,"a non static array must reinitialize itself every function call, while a static array will only initialize itself once, unless otherwise forced.",5.0,5.0,5.0,0.9999759701095982
2060,11.7,A static array retains any modified values after a function call. Automatic arrays reset to their initial values when the function ends.,5.0,3.75,4.375,0.9999667769915702
2061,11.7,"a static array is one that keeps its values and is not initialized every time a class function is called, it's data is not lost at function end.",5.0,4.0,4.5,0.9999438222879699
2062,11.7,an array that is declared as static can only be used in the function that its being called in. Its a constant array. Static is another way of say const.,0.5,4.0,2.25,0.9999606917629194
2063,11.7,Values in an array that is not delcared as static will remain constant.  When an array is declared const values within the array can be manipulated.,0.5,3.75,2.125,0.9999738445362917
2064,11.7,the data of a static array cannot be changed,0.5,3.75,2.125,0.9999016991722992
2065,11.7,"Standard arrays terminate when the functions that call them finish. A static array is not removed from memory when it's parent function terminates, leaving it available for other functions (or new instances of the original function).",5.0,2.5,3.75,0.9999833569731071
2066,11.7,by defining static array it doese not lose scope in locala function. static array makes programm more scalable. non static array lose scope inside the local function.,4.0,4.5,4.25,0.9999259022721528
2067,11.7,static arrays can be called from anywhere,3.0,1.25,2.125,0.9999384528407244
2068,11.7,A static array cannot be changed. A regular array can be changed when it is passed to a function or manually.,0.5,3.75,2.125,0.999912885232649
2069,11.7,"a static array can be can be edited throughout the program, while a non-static array can only be edited within a given function",3.0,3.75,3.375,0.9999497806661737
2070,11.7,"An array that is declared static is allocated when the program begins to run, and is not freed until the program exits, but has limited scope. A non-static array is allocated and freed every time that it comes in and out of scope.",5.0,3.75,4.375,0.9999909623627932
2071,11.7,static has a predetermined size that cannot be passed while vis versa. ,2.0,3.75,2.875,0.999960453248545
2072,11.8,the type char[] has a  null ('\n' ) element at the very end.,5.0,5.0,5.0,0.9999684953885565
2073,11.8,a variable char is basically any non command key on the keyboard that you can press. A string is a collection of letters or numbers that is stored together to be used later. Comonly strings are used for words. Chars can be used for less but can have opperations performed on them in a useful way.,0.0,3.75,1.875,0.9999733736698077
2074,11.8,The programmer must provide the null terminating character in a string of characters using type char[] and must also ensure that the array is large enough to contain the input string of characters and the null terminating character.,5.0,5.0,5.0,0.9999772590687654
2075,11.8,String of characters are followed by a null statement.  type string is for example   string s;,5.0,5.0,5.0,0.9999583408457065
2076,11.8,String contains a word where as char can contain phrases or a string of characters.,0.0,3.75,1.875,0.9999738415392234
2077,11.8,a string is a variable with a single entinty of letters combined into one while in a char[] each letter is assigned a memory value and each has its own variable assigned i.e. char[0] char[1].,0.0,4.0,2.0,0.9999762497836766
2078,11.8,"A string contains a null character at the end of the string, which makes it easily possible to get the string length. A char array can have a virtually unlimited length, therefore, its size must be declared/limited.",5.0,2.5,3.75,0.9999798547880429
2079,11.8,an array of characters stores a null character at the end,5.0,5.0,5.0,0.9999799930030385
2080,11.8,"When you read a string of characters, you also read in the white space.  When you read characters declared char you only read the characters, no white space.",1.5,4.0,2.75,0.9999727210630579
2081,11.8,"Character arrays will terminate at any whitespace, including spaces. Strings terminate when they encounter the new line character.",1.5,5.0,3.25,0.9999629927208332
2082,11.8,The difference is that a string that is declared a variable of type char[] is each char is included in the array versus the string of characters that is read into a variable.,0.0,3.75,1.875,0.9999709507787063
2083,11.8,"An array of strings reads the string literals, meaning anything within ""quotes"". A char array reads a string as each individual character.",0.0,3.75,1.875,0.9999517512688371
2084,11.8,character arrays can call on individual letters were a string array can only call words.,0.0,3.75,1.875,0.9999712345595704
2085,11.8,The character array has an end of line character at the end of it.,4.5,5.0,4.75,0.9999204318615145
2086,11.8,"Type char[] may contain a null value as the last element, whereas type string will not.",5.0,5.0,5.0,0.9999673990845057
2087,11.8,The variable of type string has a terminating character \0 at the end of it.,2.5,5.0,3.75,0.9999826697720307
2088,11.8,the one that is type string has an extra string member. The /0 at the end. ,2.5,5.0,3.75,0.9999728084587637
2089,11.8,"a string has variable size and function calls available, while an character array usually has a static size.",2.5,4.0,3.25,0.9999319831902714
2090,11.8,a string char[] adds a null value to the end of the string.,5.0,5.0,5.0,0.9999634210823031
2091,11.8,"char array needs an end character signature and is made up of characters each separate from each other, a string is an object in itself, with a value that the user enters.",5.0,5.0,5.0,0.9999725395394803
2092,11.8,"the variable of type char[], each character is stored into a different memory address and can be accessed easly, where as in a string of character, its not easy to be able to access each character in the string.",0.0,4.0,2.0,0.9999657222372003
2093,11.8,"When the string is passed into the array char, individual characters are stored and can be manipulated.  Although when a word is stored into a string variable, it is stored as one word and not as individual characters.",0.0,4.0,2.0,0.9999711264673075
2094,11.8,"a string variable can change in size and is passed to functions by value, whereas a type char[] cannot change in size and is passed to functions by reference only",0.0,3.75,1.875,0.9999748378850177
2095,11.8,"A string type string acts as a single object, with individual char entities accessible only through specific string class functions. A char array is less robust, but allows direct access to specific char entities.",1.5,3.75,2.625,0.9999691849628433
2096,11.8,"In arrays strings are stored as a characters (char[]), each character of string will be stored in each memory location of the array, while string of characters is only one memory location.",0.0,3.75,1.875,0.9999669420611058
2097,11.8,"an array of characters has one more element, its last element,the terminating element, or null, which doesnt exist in a variable of type string",5.0,5.0,5.0,0.9999739944798249
2098,11.8,A string of characters is a specific variable type that has no extra data at the end. A string of type char[] is all the characters and a null ('\0'),5.0,5.0,5.0,0.9999461460833817
2099,11.8,a string of characters will have a null character or value at the end of the string,5.0,5.0,5.0,0.9999790808098703
2100,11.8,"when the characters are put in a char array, there is also a null terminating character added to the end, '\0'",5.0,5.0,5.0,0.9999843391868547
2101,11.8,"string of characters that is read into a variable of type string includes, ",0.0,3.0,1.5,0.999971960015943
2102,11.9,"For example we have an array on n elements, the divide and conquer splits up the array into equal halves and repeats this process until each element is by itself",3.0,4.5,3.75,0.9999828440741172
2103,11.9,Divide and coquer means dividing a problem into 2+ problems which are solved and then merged  back together for a final solution to the whole problem.,5.0,5.0,5.0,0.9999920439704528
2104,11.9,The divide and conquer paradigm divides a problem into smaller and smaller portions that are easier to solve.,4.0,4.5,4.25,0.9999791544523499
2105,11.9,"Divide elements,recur then conquer, which works in merge sort and quicksort.",3.0,4.5,3.75,0.9999890694665139
2106,11.9,"To divide and conquer, you divide the program in half once or multiple times to the extent that the program as a whole is easier to work in groups to solve the problem.",4.0,4.5,4.25,0.9999849997619046
2107,11.9,to divide one larger string/line of values and sepereate them into smallers lines to easily manipulate them and then replace them in the order in which they should be.,2.0,5.0,3.5,0.9999748523528179
2108,11.9,"Split the problem into smaller, more manageable parts, and proceed to address the smaller problems.",4.0,4.5,4.25,0.9999865140000365
2109,11.9,dived and conquer is the breaking up of a large complex program into small easy to solve components.,4.0,4.5,4.25,0.9999732012010076
2110,11.9,Dividing a larger problem into the smallest incident of the problem and solving the smallest incident.,4.0,4.5,4.25,0.9999416187654245
2111,11.9,"Break up very large data structures into smaller sub-units, that are easier to manipulate.",4.0,4.5,4.25,0.9999838189746247
2112,11.9,The divide-and-conquer technique is where it takes the sorting algorithm and breaks up the array into smaller elements of the array to tackle the problem and run the algorithm.,4.0,4.25,4.125,0.9999808929639242
2113,11.9,"The divide-and-conquer paradigm divides the problem into two pieces and works on each piece separately, allowing for a faster approach to 2 separate smaller problems. ",4.0,4.5,4.25,0.9999858202475518
2114,11.9,"Take a problem and divide it into a smaller problem and solve that smaller problem, or divide it into a smaller problem and solve it, thus solving the whole problem in the process.",4.5,4.5,4.5,0.9999830686806368
2115,11.9,The idea is to split the problem into half and solve for the smaller split-problems. ,4.0,4.5,4.25,0.9999886688243678
2116,11.9,"The divide and conquer paradigm, splits a large problem into simpler problems, at which point it solves the simpler problems and merges the simple solutions together to answer the large problem.",5.0,5.0,5.0,0.9999960217829572
2117,11.9,"Divide-and-conquer refers to abstraction, the act of separating large, complex problems into smaller, easier problems that can be solved by a relatively simple algorithm.",4.0,4.5,4.25,0.9999909343860557
2118,11.9,"It takes a large problem and splits it into two or more easier or faster solutions, and  makes for better readability. ",4.0,4.5,4.25,0.9999935152096692
2119,11.9,it is the taking of a larger problem and splitting it into simpler smaller problems.,4.0,4.5,4.25,0.9999641633347088
2120,11.9,It divides the problem into singular units and works on the problem piece by piece until the problem is solved.,4.0,4.5,4.25,0.9999711100934614
2121,11.9,"smaller parts are easier to compare than comparing the whole, so it divides the problem down in halves until it can easily compare, then works backwards putting it back together to give the solution.",5.0,5.0,5.0,0.9999933712566498
2122,11.9,"a divide-and-conquer paradigm. takes some data, divides it into two parts, and works on each part indiviually until the item is found.",4.0,4.5,4.25,0.9999846913451209
2123,11.9,"The idea of divide and conquer is to take a large problem, split it into n smaller problems, making the program easier to read and modify.",4.0,4.5,4.25,0.9999932687167804
2124,11.9,the divide and conquer paradigm is a recursive solution that keeps dividing the problem into halves until a base case is reached.,4.0,4.5,4.25,0.9999948144483884
2125,11.9,"dividing and conquering means breaking a problem into two smaller problems, solving both of those, and putting the two solutions together.",5.0,5.0,5.0,0.9999918118053247
2126,11.9,"Divide the big problem into small problem, solve small problem and join small solved elements of the problem. if there is two ore more elements in the array, divide the array into parts and compare the elements, after comperison, conquer the elements. If array have n element, first half have n/2 elements",5.0,5.0,5.0,0.9999794796499881
2127,11.9,"divide the array in half, sort each half, then sort them back in one array",3.0,3.0,3.0,0.9998191753711183
2128,11.9,You take a class and break down everything it is supposed to do into easily managed functions.,1.0,4.5,2.75,0.9999779663178474
2129,11.9,"this is shown by the use of .cpp and header files.  by splitting the program up into smaller subsections of individual code, it becomes easier to write and keep up with as opposed to having all of your code in one file",1.0,4.5,2.75,0.9999717121573555
2130,11.9,"When a problem is too big, split it into smaller problems of the same type, and solve those, then from the solutions of the smaller problem, give the solution to the larger original problem.",5.0,4.5,4.75,0.9999851976055504
2131,11.9,it is the separating of large program into smaller classes then until target is reached.  ,1.5,5.0,3.25,0.9999793460321522
2132,11.11,"It uses the divide and conqure technique recursively and then when merging back together it compares each element together in a sorted list, this is done by reversing the divide and conquer technique",5.0,5.0,5.0,0.9999904671556202
2133,11.11,A merge sort works by removing all items to sepperate memory locations and merging them back together in order.,2.0,5.0,3.5,0.9999831802818319
2134,11.11,"It divides the array into two halves, sorts each half, then merges the two halves together.",5.0,5.0,5.0,0.9999967800035958
2135,11.11,"Divide into two sublists and then those sublists break into length 1, then merges the sublists sorted. ",5.0,5.0,5.0,0.9999873724780842
2136,11.11,"Merge sort uses the ""divide and conquer"" idea where it divides the array in half multiple times and then joins each element of the array back into one sorted array. This is one of the best sorting algorithms besides Quicksort.",5.0,5.0,5.0,0.9999879426977604
2137,11.11,divides the line in half coninuously until you get to only a single value then recombine the values to form a sorted line.,5.0,5.0,5.0,0.9999751309031913
2138,11.11,"Continually split array in half, sort each side of the halves, then put them back together once organized.",5.0,5.0,5.0,0.9999217503766689
2139,11.11,merge sort splits the array of elements into smaller arrays until the arrays reach size 1 and then the merge sort merges the smaller arrays into arrays of size 2 then it moves to the next step and merges the next arrays.,5.0,5.0,5.0,0.9999780683022796
2140,11.11,By divide and conquer.,1.5,5.0,3.25,0.9999698392516897
2141,11.11,"Break a single array down into many arrays with individual elements, then sort the elements as you reconstruct them back into a single array.",5.0,5.0,5.0,0.9999735365084479
2142,11.11,"Merge sort breaks the array in half, and continues to do so until it has 2 elements to compare and sorts them, after doing so it ""merges"" back as it keeps on sorting the algorithm as it does so.",5.0,5.0,5.0,0.9999728360573087
2143,11.11,"Merge sort divides the problem in half, organizes each half, then brings the two halves together again.",5.0,5.0,5.0,0.9999851587577449
2144,11.11,"Take an array and split it into two, then solve these simpler problems and merge the two answers in correct order.",5.0,5.0,5.0,0.9999858205378185
2145,11.11,"A merge sort recursively divides the array into half until only one element remains, then it sorts the data on its way out of the recursive call by merging the cells.",5.0,5.0,5.0,0.999988815996912
2146,11.11,"Merge sort recursively divides an array into two arrays until all arrays have 1 element, at which point it merges the 1 element arrays into larger sorted arrays, the final returned array being the sorted version of the initial array.",5.0,5.0,5.0,0.9999925514770422
2147,11.11,Merge sort continuously breaks an array in half then sorts the arrays as it concatenates them back together into one sorted array.,5.0,5.0,5.0,0.9999828547567898
2148,11.11,"It takes an array, splits itself in half, sorts the two halves (either by recursion or iteration) and compares them together giving a third array a full sorted list with both halves rejoined. ",5.0,5.0,5.0,0.999989131780087
2149,11.11,"it splits a large array into small arrays and recurs until the array is a size of 1, and then merges all of the arrays back together until the source array is completely sourted.",5.0,5.0,5.0,0.9999862638369749
2150,11.11,Mergesort divides the array into smaller halves and then combines the sorted subarrays into one sorted array.,5.0,5.0,5.0,0.9999713056329327
2151,11.11,"merge sort breaks the array down in halves until it is comparing two values, sorts those two values, then merges that back with the other broken down parts that it sorted, each level merging more sets together till you return back to your whole array in order.",5.0,5.0,5.0,0.9999795387203447
2152,11.11,"Divides the data into twor separate arrays, sorts the two arrays and merges them back to back together recursively. ",5.0,5.0,5.0,0.9999844549643555
2153,11.11,"Take the initial array and split it into two, temporary, smaller arrays, sort the two smaller arrays, and merge them back into a single array.",5.0,5.0,5.0,0.9999878301619542
2154,11.11,merge sort divides the data into halves until data of one element is reached and then merges each element together according to its placement in comparison to the rest of the data,5.0,5.0,5.0,0.9999855035391979
2155,11.11,"merge sort uses the divide and conquer strategy, sorting an array in parts, then merging the sorted parts back together.",5.0,5.0,5.0,0.9999856166914887
2156,11.11,"Divide recursuivly big array into two arrays, sort two array and merge them togather recuruivly.",5.0,5.0,5.0,0.9999828201681958
2157,11.11,"divides an array in half and sorts each half by calling its self, thus dividing each half again and again and sorting it until the array is sorted. then putting the elements back in the original array sorted.",5.0,5.0,5.0,0.9999780491933442
2158,11.11,Merge sort takes an array and splits it in half and sends each half back to itself recursively and merges and sorts the two halves when it starts going back up.,5.0,5.0,5.0,0.9999886442323916
2159,11.11,"merge sort splits an array into two halves and then sorts the two smaller arrays, and then merges them back together to form a sorted array",5.0,5.0,5.0,0.9999918738313386
2160,11.11,"the merge sort continually divides the array (or set of containers) into halves, until it reaches the point where there is just one element left, then merges each of the sets of two sorted arrays (containers).",5.0,5.0,5.0,0.9999933625581925
2161,11.11,merge sort splits an array of elements into smaller and smaller array's till the value of 1 is reached.,2.5,5.0,3.75,0.9999844648855492
2162,12.1,A variable in memory that hold the address of another memory location to which it points too,5.0,5.0,5.0,0.9999377264970919
2163,12.1,A pointer is a variable that contains the memory address of a given value.,4.5,5.0,4.75,0.999962068708904
2164,12.1,A pointer is a variable that stores the address of another variable.,5.0,5.0,5.0,0.9999329603115125
2165,12.1,A pointer is a variable that holds a memory address or location of another variable.,5.0,5.0,5.0,0.999959888549552
2166,12.1,A data type that points to an address in memory which contains certain information. Used for pass-by-reference to save memory.,5.0,5.0,5.0,0.9999549469356067
2167,12.1,a pointer points to a location in memory of a certain data type,4.5,5.0,4.75,0.9999219570729254
2168,12.1,A pointer is a variable that points to the address location of another variable.  Represented by (*).,5.0,5.0,5.0,0.9999515117946758
2169,12.1,A pointer is a variable that holds the address of a given variable (and of a given data type),5.0,5.0,5.0,0.999952164886986
2170,12.1,pointer is a programming data type whose value points to another value stored in computer memory by its address.,5.0,5.0,5.0,0.9999374071225532
2171,12.1,A data type that points to a specific memory address.,5.0,5.0,5.0,0.9999430389052746
2172,12.1,Its like a variable except it only holds the address in memory of the variable not the physical information.,5.0,5.0,5.0,0.9999595341034617
2173,12.1,a pointer is a reference to a memory location. ,5.0,5.0,5.0,0.9999052244829376
2174,12.1,A pointer is an alias to an object in memory.,3.5,4.25,3.875,0.9999241038808352
2175,12.1,"A pointer is a variable that contains a memory address for something that you can use, such as a value, array, or even a function.",5.0,5.0,5.0,0.9999404707011612
2176,12.1,its a data type with a memory address and a value,1.5,5.0,3.25,0.9999265045674945
2177,12.1,a form of storing data that keeps the location in memory of an data type or object.,5.0,5.0,5.0,0.9999523171796146
2178,12.1,it contains a object's memory address,5.0,5.0,5.0,0.9999077961620212
2179,12.1,variable that contains the memory address of a data object.,5.0,5.0,5.0,0.9999699841241516
2180,12.1,A pointer is an element that references a memory location.,5.0,5.0,5.0,0.9999383739102898
2181,12.1,"an object that points to a specific place in memory, where a variable or value is stored.",5.0,5.0,5.0,0.999940780249109
2182,12.1,a variable that stores the address of a memory location,5.0,5.0,5.0,0.999943463506759
2183,12.1,"A pointer is a variable that points to an address in memory, which contains some data. The pointer does not contain or point to any data, only a memory address.",5.0,5.0,5.0,0.9999464658550306
2184,12.1,Pointer is a variable which have a memory address of a variable.,5.0,5.0,5.0,0.9999338500810258
2185,12.1,a pointer points to a location in memory where data is stored,5.0,5.0,5.0,0.9999337812781633
2186,12.1,a variable that holds the address of another variable and can access the contents of the variable. ,5.0,5.0,5.0,0.9999517014114805
2187,12.1,a pointer is a memory address that points to a data member,5.0,5.0,5.0,0.99991254498999
2188,12.1,A data type that stores the memory address of another variable.,5.0,5.0,5.0,0.9999372333153873
2189,12.1,its like a variable but only holds an address in meomrry not the physical address. ,1.0,5.0,3.0,0.9999371054486903
2190,12.2,"Try several sets of data on an algorithm that includes worst case, best case, and random cases.  Also try and run the same program on a different computer with the same specs",5.0,3.75,4.375,0.9999523990163
2191,12.2,not answered,0.0,0.0,0.0,0.9995603538385917
2192,12.2,time complexity using big O  logarthmic O(log n) linear O(n) exponential O(n^2) quadratic O(n^k) k&gt;=1 Polynomial O(a^n) n&gt;1 ,1.5,3.0,2.25,0.9999408192316802
2193,12.2,Using some sort of counting principle of the number of operations performed in an algorithm.,5.0,3.75,4.375,0.9999595031154223
2194,12.2,Experimental means you would actually write a prototype of the algorithm and measure the time it takes to run given certain parameters.,5.0,5.0,5.0,0.9999792915857164
2195,12.2,measuring the relationship of running an algorithm with different input sizes.,5.0,3.75,4.375,0.9999856960130719
2196,12.2,"Oposite of a theoretical assessment of the algorithm to determine runtime, but to run the code first to determine the the runtime.  This is not recommended because it is a limited test.  It does not include all possibilities of the data, nor the hardware used to process the data.",5.0,4.25,4.625,0.9999811693894873
2197,12.2,not answered,0.0,0.0,0.0,0.9995603538385917
2198,12.2,The experimental approach for measuring the running time is by using the Big O equation which tells you the running time.,1.5,3.75,2.625,0.9999777946070656
2199,12.2,"You create and run  the algorithm multiple times, while measuring the amount of time it takes, you then average the results.",5.0,5.0,5.0,0.9999759319401916
2200,12.2,keep a value of how many operations it takes and add to this value each time a function is called.,3.0,3.75,3.375,0.9999527542544524
2201,12.2,BIG-OH,1.5,3.0,2.25,0.9995399748939657
2202,12.2,Running the program with various input data and measuring the running time with system time.,5.0,5.0,5.0,0.9999689670056898
2203,12.2,"You run a program with different data sizes, like 10^x.  As you increase x and measure the completion speeds for the program, you can find patterns and attempt the measure the running time.  It's very important to keep the same software and hardware however, which makes experimental testing inferior to theoretical in the eyes of most.",5.0,3.0,4.0,0.9999854062170469
2204,12.2,to run the program through and see how many times each thing is called and the runtime of each function is based on that.,5.0,3.5,4.25,0.9998952698440751
2205,12.2,the number of times a specific segments get called per unit work.,3.0,3.0,3.0,0.9999496704175692
2206,12.2,"For every call into memory, add/ multiply it into an equation of type O(n)",1.5,3.0,2.25,0.9999686597209169
2207,12.2,"adding a time marker at the before the algorithm is called and another time marker immediately after so that you have the change in time, then you can calculate the efficiency by the speed of the computers cpu.",3.0,4.25,3.625,0.9999752806884029
2208,12.2,Big O(h) notation,1.5,3.0,2.25,0.9998878318162802
2209,12.2,the experimental approach measures actual running time in t.  t= seconds.,5.0,5.0,5.0,0.999963993010753
2210,12.2,running an algorithm on a specific set of data,5.0,3.0,4.0,0.9999416449724108
2211,12.2,"In experimental terms, the running time of an algorithm is measured by the number of operations required to complete the function. This number can usually be expressed in big-O notation.",2.5,3.75,3.125,0.9999794235294899
2212,12.2,"run the code for n-times and get average values, drop the constant and lowest number. for example if             f(x) = 3n +1 the running time will bef  f(x) = O(n)",2.5,4.5,3.5,0.9999718880292136
2213,12.2,to measure the actual time of the program to run. and calculate the running time using the input and operations done,5.0,5.0,5.0,0.9999412812432783
2214,12.2,adding up the number of operations performed based on the worst case possible.,2.0,3.0,2.5,0.9999652697894281
2215,12.2,the experimental approach would be to run through the algorithm and see how long it takes,5.0,5.0,5.0,0.9999737043483667
2216,12.2,"trying it with different sets of inputs, and measuring the amount of time that the algorithm actually takes.",5.0,5.0,5.0,0.9999745796711321
2217,12.2,running the input with various inputs measuring the running time with  system time ,5.0,3.75,4.375,0.9999567359480398
2246,12.4,"it scans the list and selects the smallest(largest) element and places it in the front, increment the curPtr by one, scan the list again for the next smallest(largest) element and place it in with respect with the other sorted elements.",5.0,5.0,5.0,0.9998924350797737
2247,12.4,"Selection sort searches the array for the lowest value and swaps it with the first value in the array. Then searches for the next lowest value and swaps it with the second item in the array, and so on.",5.0,5.0,5.0,0.9999230939631075
2248,12.4,Compare the largest element to the front element and swap data according to value if needed.,4.0,3.75,3.875,0.9998623184472107
2249,12.4,"Selection sort is a sorting algorithm that divides a list in half and has two lists. It then compares the first elements in both these lists and puts these elements in another list, having the smaller element before the bigger one.",1.0,3.0,2.0,0.9998457624044725
2250,12.4,"Iterate through the list (assume list of integers), find the smallest one, and put it in a separate ""sorted"" list... then traverse again and find the next smallest, and move it to the sorted section... and repeat until you run out of elements to sort.",5.0,4.5,4.75,0.9998092034417102
2251,12.4,selection sort selects the smallest element out of the list then the second smallest ....and sorts them acordingly.,5.0,5.0,5.0,0.9998474475703301
2252,12.4,You select the smallest element and place it on the left.  You select the smallest element and sort it with respect the the item already on the left.  You continue this till the end of the collection of items.,5.0,5.0,5.0,0.9999349698737995
2253,12.4,"A selection sort scrolls through the data structure looking for the lowest (or highest) unsorted piece of data, moves it to the held spot, increments that spot by one, and starts the process over.",5.0,5.0,5.0,0.9998173891155603
2254,12.4,Selection sort works by finding the smallest element and then compares it with the largest and sorts the elements.,0.0,3.75,1.875,0.9998741683584895
2255,12.4,"Selection sort is usually a recursive sorting method where you divide the elements to be sorted in half repeatedly. You then sort the smallest case, then work your way up, sorting each until they are all sorted.",1.0,4.0,2.5,0.9998160048718983
2256,12.4,"goes to the middle of the list, checks to see if it is greater or less then the value given and moves through the list accordingly to add the value into the proper place.",0.0,3.75,1.875,0.9998858069072459
2257,12.4,selection sort finds the lowest element in the data set and places it behind the pivot point.,5.0,3.75,4.375,0.9998329577316207
2258,12.4,"Selection sort iterates through the array one element at a time, seeking the least value from the right and replacing the current value with it.",5.0,3.75,4.375,0.9998677741701731
2259,12.4,"Selection sort traverses an unsorted array looking for the smallest value, when it's found it is put at the beginning of the unsorted array.  Performed several times, this will output a sorted array.",5.0,5.0,5.0,0.9998260606889868
2260,12.4,it runs through the list and finds the smallest (or largest) value and puts it at the appropriate position,5.0,3.75,4.375,0.9998312292396809
2261,12.4,"pick a number, and set all values less than that number to the left, while all numbers on the right of that number is larger.",1.0,5.0,3.0,0.9998336090625348
2262,12.4,It takes the largest item in the unsorted array and swaps it with last item in the unsorted array.,5.0,3.75,4.375,0.9998544353631609
2263,12.4,"by selecting the first object and comparing it with the next objects to find one that is smaller, if it does it switches the two.  then it comes back the other way and sees if the objects previous to the last one is greater, if it does it switches them.  it does this while decreasing the range it looks at until it finishes in the middle.",1.0,3.75,2.375,0.99989356431743
2264,12.4,"Selection sorts works by going through a certain list. Goes through the unsorted list and selecting the largest item in the list and placing it in a sorted array. There are two arrays, unsorted and sorted. Complete these steps until the list is sorted.",5.0,3.75,4.375,0.9998301704936652
2265,12.4,"selection sort works by pulling all of the values off to the side, leaving one value in the list.  It will then insert a value into the list.  if the value is bigger it will go to the right, if smaller if will go to the left.",1.0,3.75,2.375,0.9999110861665114
2266,12.4,selection sort searches for the smallest element of the remaining data organization and places it at the largest point of the new data organization,5.0,3.75,4.375,0.999878809067976
2267,12.4,"Selection sort sorts an array one element at at time. It first finds the element with the smallest key and puts it into the first location within its array or list, then finds the next smallest and puts it in the second location, and so on.",5.0,5.0,5.0,0.9998880872217658
2268,12.4,"select an element compare it with 2nd element if it is greater, swap it ",1.0,4.5,2.75,0.9998301941994232
2269,12.4,"it selects the smallest element in a list and switches it with the element in its correct position, then it selects the next smallest and does the same...",5.0,4.25,4.625,0.999850048823867
2270,12.4,It starts at the first element and replaces it with the smallest element found to the right. It then repeats with the next element in the list.,5.0,4.25,4.625,0.9999027513956567
2271,12.4,"selection sort is when you pick a data member and put it in a new array, then you pick another data member and put it in order with the new array, then pick another and insert it in the correct place in the new array, etc etc",1.0,5.0,3.0,0.9999078196759985
2272,12.4,"it searches through the entire data set for the best element to go in the current position, then it moves up a position and searches through the remainder of the set for the best element for the new position.",5.0,3.0,4.0,0.9999361314698456
2273,12.4,selection sort  iterates through the array one element @ a time searching for the right and replacing current value with it. ,5.0,3.0,4.0,0.9998311768948537
2274,12.5,A link list can grow to a infinite size as a array has a fixes size.,5.0,5.0,5.0,0.9999523528739983
2275,12.5,The advantage of linked lists is that they are not limited in size like arrays.,5.0,5.0,5.0,0.9999786693964511
2276,12.5,link lists dont have a fixed size,5.0,5.0,5.0,0.9999515663696128
2277,12.5,"Linked Lists can be of variable size, where arrays have fixed size.",5.0,5.0,5.0,0.9999836664487625
2278,12.5,"Linked lists do not have a definite size. They can be as big or as small as needed, and they don't have to allocate extra memory for elements you don't need. Arrays size must be defined.",5.0,5.0,5.0,0.9999712094721536
2279,12.5,"a linked list has a dynamic size , but an array only has a fixed size and takes allot of extra operations to increase its size.",5.0,5.0,5.0,0.9999790604496918
2280,12.5,You do not have to predetermine your list size as you do with arrays. Linked list have the ability to be as large as you want them adding memory as needed.,5.0,5.0,5.0,0.9999584732533231
2281,12.5,The main advantage to a linked list is that it can have it's size adjusted during runtime.,5.0,5.0,5.0,0.9999605416023846
2282,12.5,Linked lists are able to grow in size. So elements can be added to the list.,5.0,5.0,5.0,0.9999707769975001
2283,12.5,"Linked lists are not confined to a specific size, and can have elements added and removed far easier. They are also easier to traverse.",4.5,5.0,4.75,0.9999906296930083
2284,12.5,There is no predetermined length,5.0,5.0,5.0,0.9999395025775107
2285,12.5,"Inserts into a linked list are far cheaper than an insert into an array. With an array, all items after the one being inserted must me shifted, with a linked list, only the pointers are replaced.",4.0,5.0,4.5,0.9999732745669492
2286,12.5,Linked lists may be dynamically grown.,5.0,5.0,5.0,0.9999715548065139
2287,12.5,"Linked lists are very dynamic in that they can change and be added/subtracted to very easily because they are not linear in memory.   Arrays are pre-specified in size to be cast over a certain amount of disk space.  This makes insertion into Arrays difficult because all elements must be shifted, and if you reach the end of the array, you are done even if you have more data to input.  Linked Lists do not run into these problems.",5.0,5.0,5.0,0.9999758791917459
2288,12.5,"linked lists have an indefinite size, whereas arrays are a specific size.",5.0,5.0,5.0,0.9999766409428448
2289,12.5,"Linked lists have no predefined length, and thus you can have virtually unlimited items in that list.",5.0,5.0,5.0,0.9999770916344352
2290,12.5,"They grow dynamically, unlike the fixed size array",5.0,5.0,5.0,0.9999792842400654
2291,12.5,"you can add as many nodes as you like without having to specify a list size, if an array gets too big you have to copy its entire contents to another larger array to get more room",5.0,5.0,5.0,0.9999649940927873
2292,12.5,Linkded list does not have a fixed size. Arrays have a fixed size.,5.0,5.0,5.0,0.999935592937941
2293,12.5,"Linked lists have a dynamic size, where as arrays have a static size.",5.0,5.0,5.0,0.9999675330241568
2294,12.5,linked lists do not have a memory constraint other than total memory,5.0,5.0,5.0,0.9999078021543519
2295,12.5,"The primary advantage of linked lists over arrays is their ability to become larger or smaller as data is added and removed from the list, whereas arrays may waste memory for small data sets, and run out of space for large data sets.",5.0,5.0,5.0,0.9999869534059741
2296,12.5,"Array have fixed size, in Link List are flexible for adding or deleting an element. ",5.0,5.0,5.0,0.9999662012535908
2297,12.5,they are resizeable,5.0,5.0,5.0,0.9999566297803458
2298,12.5,Linked lists can be dynamically allocated and their size can change as needed.,5.0,5.0,5.0,0.9999777170565345
2299,12.5,"linked lists do not have to have a specified size, they are easier to add to and remove from",5.0,5.0,5.0,0.9999166124746544
2300,12.5,"they dont have a fixed size, no shiftnig needs to be done for insertion/deletion.",5.0,5.0,5.0,0.999980668758152
2301,12.5,linked list many be dynamically grown. It has not limit  ,5.0,5.0,5.0,0.99995486217926
2302,12.6,A data structure in C++ where the the first element in the queue is the first element taken out of the queue.,5.0,5.0,5.0,0.9999736852434343
2303,12.6,A queue is an abstract data type that performs operations on both ends of the list and exhibits first-in first-out behavior.,5.0,5.0,5.0,0.9999867952483974
2304,12.6,First in first out.,4.0,5.0,4.5,0.9998495887601262
2305,12.6,"A queue is an abstract data type that involves putting an element at the back of the list. Queues use the FIFO, first in first out, idea where the first element in the list is the first that comes out.",5.0,5.0,5.0,0.9999775274922176
2306,12.6,"A data structure that implements first in, first out. The element that has been there the longest is the first to get served.",5.0,5.0,5.0,0.9999593433974586
2307,12.6,a data structure that inserts elements at the end of it and removes elements from the front.,5.0,5.0,5.0,0.9999910000468821
2308,12.6,A queue is a collection of elements with the characteristics of first in first out (FIFO).  The first item in is the first item out.  All additional items are added to the end of the list.,5.0,5.0,5.0,0.9999769410294598
2309,12.6,"A queue is a data structure that inserts data into a FIFO configuration, that is, data input to the structure is always at it's end, and data taken is always from the beginning.",5.0,5.0,5.0,0.99998301756545
2310,12.6,It is a particular set of entities that are put in to a certain order by the enqueue and the dequeue functions.,1.5,5.0,3.25,0.9999871607039947
2311,12.6,A queue is a data type that operates under a FILO (First In Last Out) method. This means that the first element inserted into the queue is the first element removed.,5.0,2.5,3.75,0.999980603681681
2312,12.6,like a linked list except it is first in last out,0.0,5.0,2.5,0.9998206758542834
2313,12.6,A queue is like a stack except it follows FIFO (First in first out) .,5.0,5.0,5.0,0.9999458322158867
2314,12.6,A queue is a data structure where the first node in is the first node out.,5.0,5.0,5.0,0.9999490072476002
2315,12.6,A queue is a First in First out data structure much like a line for a movie theatre.  The first object in line is the first object to be handled or enacted upon.  ,5.0,5.0,5.0,0.9999669081511069
2316,12.6,"its a lot like a stack, except that the first item put into the list is the first item to be taken from the list.",5.0,5.0,5.0,0.9999157942996801
2317,12.6,"a first in first out list of items, like if you put 5, 4, 3, 2, and 1 in the queue it will when you dequeue items remove the items in the same order as put in, so thus it will put out, 5, 4, 3, 2, and 1 in that exact order.",5.0,5.0,5.0,0.9998768028468993
2318,12.6,"A linked list with a First In, Out structure dequeue at the head of the list enqueue at the end of the list",5.0,5.0,5.0,0.9999479885663389
2319,12.6,"a list of objects that follow the rule first in first out, essentially a linked list that goes in order of the first object in the list is the first to be taken off.",5.0,5.0,5.0,0.9999264272264823
2320,12.6,A queue is an abstract data type that is based off of the priniple of first in first out. FIFO. The first item inserted into the list will the first item taken out.,5.0,5.0,5.0,0.999980902803828
2321,12.6,"It is a ""first in first out"" data structure.  It can be implemented with either a linked list or an array.",5.0,5.0,5.0,0.9999372773440369
2322,12.6,an ordered list that performs task in the order of first in first out. adding items to the queue places items behind the rest of them. taking items off the queue takes the one that has waited the longest.,5.0,5.0,5.0,0.999927658598215
2323,12.6,"A queue is a linear, first-in first-out data structure. Data must be accessed in the same order it was put into the queue, so only the oldest item in the queue is accessible at any time. Main functions defined are enqueue and dequeue.",5.0,5.0,5.0,0.9999851992783104
2324,12.6,"Queue is a buffer, it follows the rule of First In and First out. Queue is very useful in computer science for scheduleing .",5.0,5.0,5.0,0.9999676985348095
2325,12.6,a queue is a set of elements where the first element inserted is the first element to be removed,5.0,5.0,5.0,0.9999717861753218
2326,12.6,Is a list of items where the the user only has access to the first element and each new element is added at the end.,5.0,5.0,5.0,0.9998955796366413
2327,12.6,"a queue is a list of data that follows the fifo principle, an example of this would be when you get into a line at a movie theater...the first one there gets to buy a ticket first",5.0,5.0,5.0,0.9999569613525211
2328,12.6,"A queue is a data structure that holds a set of objects, which has a FIFO (first in first out) priority.",5.0,5.0,5.0,0.999954421206639
2329,12.6,like a linked list expect first in last out ,0.0,2.5,1.25,0.9999013525792114
2330,12.7,push and pop,5.0,5.0,5.0,1.0
2331,12.7,"Pop, which removes the head, or least recently inserted node from the stack. Push, which inserts a new node at the head of the stack.",5.0,5.0,5.0,0.9998865917905523
2332,12.7,Push and pop,5.0,5.0,5.0,0.9999329413601467
2333,12.7,The Push function and the Pop function.,5.0,5.0,5.0,0.9998338242350521
2334,12.7,push and pop,5.0,5.0,5.0,1.0
2335,12.7,push - puts an element on the stack pop- takes an element off the stack,5.0,5.0,5.0,0.9998419074664121
2336,12.7,Push  and pop.,5.0,5.0,5.0,0.9999297962221582
2337,12.7,Push and Pop,5.0,5.0,5.0,0.9999181391853679
2338,12.7,push and pop.,5.0,5.0,5.0,0.9999811224801012
2339,12.7,"Push and Pop. Push adds an element to the stack, while Pop removes the top element from a stack.",5.0,5.0,5.0,0.9999233912682193
2340,12.7,pop and push,5.0,5.0,5.0,0.9999638571713609
2341,12.7,"push,pop,search,isEmpty",4.0,5.0,4.5,0.9998721591068075
2342,12.7,push and pop,5.0,5.0,5.0,1.0
2343,12.7,"Push, Pop, isEmpty, isFull  Maybe List to show all elements or an operation to count how many elements in the stack.",4.5,5.0,4.75,0.9999079673269835
2344,12.7,"pop, push",5.0,5.0,5.0,0.9998960665847104
2345,12.7,"isempty, push and pop, along with usually, ",5.0,5.0,5.0,0.9999237419175375
2346,12.7,push and pop,5.0,5.0,5.0,1.0
2347,12.7,push and pop. push puts objects into the stack and pop takes them out following the first in last out rule.,5.0,5.0,5.0,0.9999265388641895
2348,12.7,"The main operations in a stack are push and pop. Push adds an item to the top of the stack, pop removes the top item from the stack.",5.0,5.0,5.0,0.999904485796041
2349,12.7,push and pop,5.0,5.0,5.0,1.0
2350,12.7,"push, which adds an item to the top of the stack, and pop, which takes the first item off the top to the stack",5.0,5.0,5.0,0.9999100827127423
2351,12.7,"the main functions defined for a stack are push, which puts an element on the top of the stack, and pop, which removes an item from the top.",5.0,5.0,5.0,0.9999129632830913
2352,12.7,Push() Pop() Full() IsEmpty(),4.5,5.0,4.75,0.9997808763892353
2353,12.7,pop and push to remove an element and to insert an element,5.0,5.0,5.0,0.9999186388133617
2354,12.7,"Push, Pop",5.0,5.0,5.0,0.9998090668028653
2355,12.7,push and pop,5.0,5.0,5.0,1.0
2356,12.7,push - Add an element to the top of the stack pop - remove the top element from the stack,5.0,5.0,5.0,0.9998000585078709
2357,12.7,push and pop ,5.0,5.0,5.0,1.0
2358,12.8,When you traverse a tree of any size you will visit each node three times.  Its on the order of 3n or O(n) running time.,5.0,3.0,4.0,0.9998958414476797
2359,12.8,"The Euler tour traversal of a tree begins at the root and visits each node in the tree from the left, then bottom, then right sides.",5.0,5.0,5.0,0.9999123959400062
2360,12.8,Where you visit the in order according to its data value.,2.5,3.0,2.75,0.9998730293824594
2361,12.8,"It is a tree that shows how it functions. It contains parents, children, siblings, ancestors and descendents. The use of tree type algorithm is also an alternative sorting algorithm. ",0.0,3.75,1.875,0.9998349077301768
2362,12.8,"Start from the root, circle around the _whole_ ""tree"", naming each node as you see it.",5.0,4.25,4.625,0.9999184577070144
2363,12.8,it is where you visit the parent then you vistit the children,0.0,3.0,1.5,0.9998701228962484
2364,12.8,"To start from the root , traveling left and visiting ever child along the way till you return to the root from the right.",4.0,4.25,4.125,0.9999162895376776
2365,12.8,"Traversing a tree down to it's terminal child and then all of it's siblings, then it traverses up the terminal child's parent and all of it's siblings (repeating the first step if those siblings have children) until the root node has been visited.",4.0,4.25,4.125,0.9998792946682379
2366,12.8,The Euler tour traversal of a tree the function that iteratively keeps track of the pointer on each node.,1.5,3.75,2.625,0.9998776906115868
2367,12.8,"You travel the outside edge of the tree, clockwise, while naming each node.",4.5,3.0,3.75,0.9999039408366741
2368,12.8,children to root,0.0,3.75,1.875,0.9998475563951735
2369,12.8,go to the bottom of the left sub tree and visit the parent and then its children,2.0,3.75,2.875,0.9999153921807833
2370,12.8,The Euler tour traverses through the tree in a rubber-band style shape.,3.5,3.0,3.25,0.9998474687466774
2371,12.8,"The Euler tour traversal of a tree is a specific way of navigating a tree that involves following the tree starting at the very top and moving along the left side of the tree first, cupping in to visit the parents of children nodes.  It allows for each node to be visited from the left, the right and the bottom.  The Euler tour first progresses to a left child if there is one, then progresses to it's parent, then it's next child, then it's parent's parent.",5.0,3.75,4.375,0.9999146801717999
2372,12.8,it runs through the parents and the children in order ,2.5,3.0,2.75,0.9998949874741424
2373,12.8,"it starts node on the left of the root and then proceeds to visits each node in a left to right order, visits the root, and then proceeds to repeat the previous step on the right side of the tree.",2.5,3.75,3.125,0.9999078084018913
2374,12.8,"Travel from the root to the farthest left child Backup, travel the leftmost children in the right side repeat until reaching the rightmost child.",3.5,5.0,4.25,0.9999069087609694
2375,12.8,"has preorder, in order, and postorder of a tree.  preorder = puts the parent node in front of the child node(s).  in order = puts the parent node between the left child and right child node(s).  postorder = puts the parent node after the child node(s).",2.5,3.75,3.125,0.9999270034540353
2376,12.8,"The Euler traveral is when you go through a tree looking for nodes to put in the order of left, root, right. Like inOrder traversal. ",2.5,5.0,3.75,0.9998960298159586
2377,12.8,"An Euler traversal is a traversal that begins with the root, and travels around the outside of the tree.  Each element in the tree is visited 3 times.  From the left, from the bottom and from the right.",5.0,5.0,5.0,0.9998955905548544
2378,12.8,Euler tour traversal of a tree traverses down each branch straight to one leaf then starts again at the root and repeats until all elements have been traversed.,4.0,3.75,3.875,0.9998569454270273
2379,12.8,"The Euler tour visits every node in a tree, starting with the root and working around the tree counterclockwise. in-order, post-order, and pre-order traversals can be seen as variations of the Euler tour traversal.",4.0,4.5,4.25,0.9998698053500502
2380,12.8,not answered,0.0,0.0,0.0,0.9995603538385917
2381,12.8,to traverse going down to the left then go to the right of last children and back to the top.. kind of like going around the tree,5.0,4.5,4.75,0.999887405313579
2382,12.8,"You recursively visit every node on the list. You visit the node from the left, the bottom, and from the right.",5.0,5.0,5.0,0.9999257766128029
2383,12.8,"the euler tour is a way to traverse a tree where you come into contact with each node three times, from the left, from the right, and from the bottom",5.0,5.0,5.0,0.9999324464798228
2384,12.8,traversing a tree level by level,0.0,3.0,1.5,0.9998546479758957
2385,12.8,The Euler traversal through the tree in a rubber band style shape.,3.5,3.0,3.25,0.9998631297754522
2386,12.9,"if root, set root to NULL else if deleting right leaf, set rightPtr of parent node to NULL else if deleting left leaf, set leftPtr of parent node to NULL else if deleting a left or right subtree child node, set the max leaf child in the left subtree as the new child node.",4.5,4.0,4.25,0.9999693759917871
2387,12.9,"Traverse the tree and find the node, if the node has no children, simply delete it; otherwise set the node's data equal to the data of one of its children then set the pointer for that child to NULL.",3.0,3.75,3.375,0.9999525820905497
2388,12.9,first attaching the elements from the node to be deleting to alternate nodes and then deleting that node.    delete node; ,3.0,3.75,3.375,0.9999598304410686
2389,12.9,"If you delete a node from a tree, you have to link that nodes parents to the children of that node.",2.5,3.75,3.125,0.9999373637578524
2390,12.9,"Must delete the information that the node contains (to free up memory/ ""garbage collect"") and also delete the pointer (in that node's ""parent"") that points to the node you wish to delete.",0.5,3.0,1.75,0.9999578086566923
2391,12.9,you replace the node with the largest element of its left subtree or replace it with the smallest element of the right subtree.,5.0,5.0,5.0,0.9999719963653879
2392,12.9,"You traverse the tree till you find the node you are wanting to delete.  If the node has no children you delete it.  If the node has children, before you delete, you find the left-most of its children and attach it to the root then you can delete the node.",3.5,4.25,3.875,0.9999567777819719
2393,12.9,Link the to-be-deleted's left child to the to-be-deleted's parent's left child pointer.,3.5,5.0,4.25,0.9999501785309687
2394,12.9,The way you delete a node from a binary search tree is first you have take the root and then see the nodes that are coming from the root. And delete the nodes and set the root to NULL.,0.0,3.75,1.875,0.9999579769211068
2395,12.9,You remove the element from the tree and move the next highest element from the left into its place.,5.0,3.75,4.375,0.9998567111245913
2396,12.9,delete node;,0.0,3.0,1.5,0.9997115072439424
2397,12.9,"the deletion of a node depends upon if it has children and if it is an AVL binary search tree. Assuming it is not an AVL tree, and the node being deleted has no children, you just set its pointer to null. If it has a left child or a right child exclusively, that child replaces the deleted node, if it has two children, the left most child of the right sub tree (or right most child of the left subtree)will replace it",5.0,5.0,5.0,0.9999545534283404
2398,12.9,"If the node is a leaf, just set it's parent's pointer to null and delete it, if it has a single child, set the parent's pointer to the child and delete; if it has two children, set the node to one of the middle children and remove that child from its previous position as a leaf (rightmost child of the left subtree or leftmost child of the right subtree).",5.0,5.0,5.0,0.9998737647610804
2399,12.9,"In a binary search tree, you must first establish a proper replacement for the node you are about to delete, usually a child from the soon to be deleted node.  Once that replacement node has been found, you simply reassign it to where the node that is going to be deleted is.  After the deleted node has been usurped, you remove the deleted node from memory so it may be used again. ",4.0,3.75,3.875,0.9999650407597961
2400,12.9,It all depends on where the node is located. If its a child it can just be deleted but for a node inside the tree it must be replaced with another node that works in its place.,3.0,3.75,3.375,0.9999326898060698
2401,12.9,"if the node has no children, delete it right away, otherwise, put either the furthest right node on the left side or the furthest left node on the right side in that place and perform a the above on that node to guarantee that it's children get handled properly.",5.0,5.0,5.0,0.9999736904075379
2402,12.9,Create a temp Node  Set temp's values to the Node after head  or NULL in the case of only head Node in the list.   Set head equal to temp. Delete temp ,0.0,3.75,1.875,0.999896111237103
2403,12.9,"by searching down the tree until you find the node, and replacing the link to that node with the greatest child node on the left subtree or the least child node on the right subtree.",5.0,4.25,4.625,0.9999647817109096
2404,12.9,"Set the nodes to NULL, where that it doesn't point to anything, and the use the DELETE opertator to clear space from memory.",0.0,3.0,1.5,0.9999732372324621
2405,12.9,"You must first traverse the tree to find the appropriate value.  Then you must make sure that the node is a leaf node.  If it is, then you can delete the pointer to that specific node.",1.5,3.75,2.625,0.9999534853620853
2406,12.9,"if the node is a leaf, you set it's parent's pointer to null. if the node is in the tree you must replace the node with one in the tree: either the largest in the left of the tree or the smallest in the right of the tree. this can be done recursively if needed.",5.0,5.0,5.0,0.9999070397273032
2407,12.9,"if the node is a leaf it can simply be deallocated/deleted from memory, and its parent's reference to it changed to NULL. If the node has a single child, the pointer to it should be made to point to its child before deleting the node. Should the node have two children, the easiest solution may be to copy the node's entire subtree to a new array or tree, delete the node and all descendants, then add the elements taken from the subtree back into the main tree.",4.0,4.5,4.25,0.9999722154605929
2408,12.9,not answered,0.0,0.0,0.0,0.9995603538385917
2409,12.9,you cannot delete a node because that can cause a node to have more than 2 children,0.0,2.5,1.25,0.9999096196576972
2410,12.9,"You search the tree for the node using recursion. When you find the node, you determine whether it is a leaf or a internal node. If it is a leaf, you just delete it and set the parent pointer to that node to NULL. If it is a  node, you replace the node with either of the children nodes.",3.5,3.75,3.625,0.9999481040250735
2411,12.9,"to delete the node, you would have to link the children nodes that are connected to the node to be deleted to the remaining nodes of the tree in such a way that nodes on the right of the parent node are larger than the parent and nodes on the left of the parent node are smaller",3.0,5.0,4.0,0.9999665167170494
2412,12.9,"if it has no children, you just delete it. if it only has one child, just replace the node with whichever child it has. if it has both children, replace it with one of its children, and send the other child down along the other side of the new node.",3.5,3.75,3.625,0.9998883776781334
2413,12.9,pointer to the child and delete it has 2 children set the node to the child and delete it. the node to th middle will then take its place ,2.0,3.75,2.875,0.9998756612522184
2414,12.11,Log(n) where n is the number of nodes.,4.5,5.0,4.75,0.9999069489444217
2415,12.11,log(n) steps,4.5,5.0,4.75,0.9998236911774429
2416,12.11,The number of levels and the height of the tree,5.0,5.0,5.0,0.9999234054898823
2417,12.11,It is the same as the height of the tree.,5.0,5.0,5.0,0.9999629725083834
2418,12.11,"Given n elements, it would take n/2 steps to find the search criteria.",0.0,3.0,1.5,0.999919701072471
2419,12.11,log n,4.5,5.0,4.75,0.999773964354746
2420,12.11,Depends on the location of the node you are looking for. If it is the root it is one step.  else If it is smaller than the current you are on node you go to the left.  If it is larger than the current node you are on go to the right.,0.0,3.75,1.875,0.9997964783225092
2421,12.11,2^n where n is the # of levels the binary tree has,0.0,3.75,1.875,0.9999340294206309
2422,12.11,The number of steps to search a node is the function n-1.,2.5,4.0,3.25,0.999935623795619
2423,12.11,"It would take n/2 elements, given n.",0.0,3.0,1.5,0.9999014522614034
2424,12.11,log(n),4.5,5.0,4.75,0.9998137991477475
2425,12.11,O(log n),4.5,5.0,4.75,0.9998689648017788
2426,12.11,O( Log (n) ),4.5,5.0,4.75,0.9998569111969493
2427,12.11,"If the binary search tree is constructed efficiently, best case scenario is O(log n) time.  Where n is the number of items in the tree.  If the binary search tree is constructed poorly, with for instance the root of the tree being 1, and progressing downwards and to the right its children are each more than the last: you have a one-way linear linked list.  That worse case scenario would be a full traversal at O(n) time. Where n is the number of items in the tree.",5.0,5.0,5.0,0.9999421929494754
2428,12.11,"N, n being the number of nodes.",2.5,5.0,3.75,0.9999259141970562
2429,12.11,"depending on the way that the tree is ordered, it could be anywhere between log(n) and N steps.",5.0,5.0,5.0,0.9999364885757585
2430,12.11,log(n),4.5,5.0,4.75,0.9998137991477475
2431,12.11,"worst case scenario = the number of levels of the tree, ie: the node at the farthest position from the root node.  best case = 1 step if its the root node.",5.0,5.0,5.0,0.9999300232574502
2432,12.11,3 steps at most.  There are 3 cases.,0.0,3.0,1.5,0.9999323208177935
2433,12.11,log(n)    where n equals the total number of nodes in the tree.,4.5,5.0,4.75,0.9999440961608499
2434,12.11,the same number of steps as the number of levels or generations in the tree,5.0,5.0,5.0,0.9999327319733963
2435,12.11,to find a node in a binary search tree takes at most the same number of steps as there are levels of the tree.,5.0,5.0,5.0,0.9999335829111187
2436,12.11,"three steps visit the root node, then go to right subtree, after visiting right subtree visit left subtree",0.0,4.5,2.25,0.9999197072347437
2437,12.11,log n,4.5,5.0,4.75,0.999773964354746
2438,12.11,( n(n-1) ) / 2  ,0.0,3.0,1.5,0.9998853212290876
2439,12.11,2n-1,0.0,4.75,2.375,0.9995075840495637
2440,12.11,"it takes at most h steps, where h is the height of the tree.",5.0,5.0,5.0,0.9999356973119777
2441,12.11,it depends on the install search tree then from there for whatever the case is the it repeats it back along the case of the primary node,0.0,3.0,1.5,0.999931551802014
